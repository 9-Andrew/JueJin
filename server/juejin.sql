/*
 Navicat Premium Data Transfer

 Source Server         : mysql_local
 Source Server Type    : MySQL
 Source Server Version : 50527 (5.5.27)
 Source Host           : localhost:3306
 Source Schema         : juejin

 Target Server Type    : MySQL
 Target Server Version : 50527 (5.5.27)
 File Encoding         : 65001

 Date: 22/10/2023 10:45:11
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;


CREATE DATABASE IF NOT EXISTS juejin;
USE juejin;
-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `cover` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type_id` int(11) NULL DEFAULT 1,
  `like_num` int(11) NULL DEFAULT 0,
  `star_num` int(11) NULL DEFAULT 0,
  `view_num` int(11) NULL DEFAULT 0,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `status` int(11) NULL DEFAULT 0 COMMENT '默认为0，0表示草稿文章，1表示已发布的文章',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `type_id`(`type_id`) USING BTREE,
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `article_ibfk_2` FOREIGN KEY (`type_id`) REFERENCES `article_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 172 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 7, 'iOS 创建framework依赖cocoapods', '### 前言\r\n\r\n在iOS开发的过程中，经常会使用Framework静态库。今天主要讲解一下如何在开发Framework的时候，用pod来依赖。当然，可以直接将pod库再用内部依赖的方式引入，但是这种依赖风险很大。比如Framework内部引用了YYModel，那么在不修改前缀或者替换函数名称。在其他人引用Framework时，会带来极大的兼容性问题。所以，还是建议外部依赖最为稳妥。\r\n\r\n##### 创建Framework\r\n\r\n1.示例起名：TestKit，可以根据自身需求来命名。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62817f2fc6eb42cd9156f795a81e0604~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n2.设置最低版本\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/477cf57e7d8b4f74a88949e551ba0a89~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n3.TARGETS->Build Settings->Mach-O Type，设为 Static Library。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f166eec33064916bd413cb5e561f8b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n4.Build Libraries for Distribution 设置为Yes （如果是swift语言的时候需要）\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff573a2d377a48f7bc8f3f5b30890998~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n5.添加pod文件\r\n\r\narduino\r\n\r\n复制代码\r\n\r\n`platform :ios, \'11.0\' post_install do |installer|   installer.pods_project.build_configurations.each do |config|     config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"   end end target \'TestKit\' do   pod \'SVProgressHUD\' end`\r\n\r\n6.创建调用代码 .h + .m\r\n\r\nobjectivec\r\n\r\n复制代码\r\n\r\n`#import <Foundation/Foundation.h> NS_ASSUME_NONNULL_BEGIN @interface TestShowTool : NSObject + (void)test_showInfo:(NSString *)info; @end NS_ASSUME_NONNULL_END`\r\n\r\nobjectivec\r\n\r\n复制代码\r\n\r\n`#import \"TestShowTool.h\" #import <SVProgressHUD.h> @implementation TestShowTool + (void)test_showInfo:(NSString *)info{     [SVProgressHUD showInfoWithStatus:info]; } @end`\r\n\r\n7.将.h文件暴露为public\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2b0d7154554b8d8e84ee90301039d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n8.TestKit.h声明想要暴露的Header类\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186192d3f5844716bbc32c8f3ae50a95~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n### 生成构建框架\r\n\r\n在模拟器和真机状态下编辑一遍，确保成功\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06534a79daae40cf801a7188bbd002a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6243cc3e1ae498db06dec6ebe1b70a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n### 生成通用框架-> 自动生成Framework\r\n\r\n1.TARGETS 左下角加号，添加一个 Aggregate，命名为 TestMark\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9161e18c6b6d449cad7b2bdf50ad36dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n2.Build Phases->左上角加号->New Run Script Phase\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf0744afb3d46c8bfe9c33d43eeb98e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n3.添加如下代码，将 /Users/xxx/Desktop 中的xxx 替换为你自己的Mac名称输出到桌面，也可以输入 pwd查看。\r\n\r\nbash\r\n\r\n复制代码\r\n\r\n`if [ \"true\" == ${ALREADYINVOKED:-false} ] then echo \"RECURSION: Detected, stopping\" else export ALREADYINVOKED=\"true\" UNIVERSAL_OUTPUTFOLDER=/Users/xxx/Desktop # 输出文件夹 mkdir -p \"${UNIVERSAL_OUTPUTFOLDER}\" xcodebuild -target \"${TARGET_NAME}\" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos  BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\" build xcodebuild -target \"${TARGET_NAME}\" -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\" build cp -R \"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework\" \"${UNIVERSAL_OUTPUTFOLDER}/\" SIMULATOR_SWIFT_MODULES_DIR=\"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/.\" if [ -d \"${SIMULATOR_SWIFT_MODULES_DIR}\" ]; then cp -R \"${SIMULATOR_SWIFT_MODULES_DIR}\" \"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule\" fi lipo -create -output \"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}\" \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/${PROJECT_NAME}\" \"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework/${PROJECT_NAME}\" fi`\r\n\r\n4.  确定生成构建框架后，选择Target为TestMark。command + B 即可在桌面看到生成Framework了。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a5f44f3e664651b31ae4f794d0604b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11978c1c29a048c38430507aae34161c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)', '', 4, 6, 1, 308, '2023-09-07 17:06:48', 1);
INSERT INTO `article` VALUES (2, 2, 'Android进阶宝典 -- 自升级方案基础之PKMS源码分析', '其实提到自升级，相信大多数的伙伴们更多想到的是通过热修复的方式，从dex文件入手利用类加载机制完成bugfix。当然这也是应用自升级的一种方案，像Tinker、Robust这些成熟的框架已经帮我们做了很多基础的工作，但是如果我们是在做ROM，或者智能硬件（车载座舱、电视、汽车等）方面的工作，我们维护的可能就不只是一个app，从系统应用到自研应用少则10几个，多则20+，30+，如果对每个app都做热修复继承，显然是有点儿浪费资源了。\r\n\r\n因为业务升级迭代的速度是很快的，但是ROM已经是比较稳定的，如果每次业务升级都需要配合ROM显然是比较重的一次操作，因此在业务快速迭代的阶段，我们对某些app做统一的自升级，\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a14e67d5adf48728014812e40500bf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n不同的版本升级新的功能，就类似于我们在研发阶段不断地install本地debug应用测试，其实就相当于将v1.0版本的业务app卸载掉，然后重新安装v1.1版本的业务app，那么系统哪个服务可以完成这一系列的操作呢，就是PKMS。\r\n\r\n# 1 PKMS介绍\r\n\r\n什么是PKMS，全称为PackageManagerService，从字面意思上来看，就是包管理服务，或者是apk的管理服务，可以完成apk的信息查询、安装以及卸载。当我们打开手机之后进入到Launcher页面之后，我们看到所有的应用展示都是通过PKMS查询到的，以ListView的形式展示出来，包括我们长按应用卸载，也是调用了PKMS的能力。\r\n\r\n## 1.1 PKMS进程间通信\r\n\r\n通过前面我们对于系统启动流程的分析，我们知道当SystemServer进程启动之后，就会启动像AMS、PKMS等核心服务，所以PKMS是属于SystemServer进程的，此时客户端想要调用PKMS服务的能力，必然涉及到了跨进程通信，我们先看下跨进程通信是如何完成的。\r\n\r\n一般在客户端想要调用PKMS的能力，首先需要获取到PackageManager对象，这是一个抽象类，\r\n\r\nkotlin\r\n\r\n复制代码\r\n\r\n`packageManager.getPackageInfo(\"com.lay.pkms\",0)`\r\n\r\n具体实现类为ApplicationPackageManager，我们看下它的源码，这里就会有进程间通信的实现，因为肯定是调用到了PKMS的能力，我们拿getPackageInfo这个方法来看。\r\n\r\n注意这个类是一个隐藏类，因此想要查看具体的实现需要从源码中查找，路径如下：\r\n\r\n### [frameworks](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks\")/[base](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base\")/[core](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core\")/[java](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java\")/[android](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java/android \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java/android\")/[app](https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java/android/app \"https://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/base/core/java/android/app\")/ApplicationPackageManager.java\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`public class ApplicationPackageManager extends PackageManager {     private static final String TAG = \"ApplicationPackageManager\";     private final static boolean DEBUG_ICONS = false;     private static final int DEFAULT_EPHEMERAL_COOKIE_MAX_SIZE_BYTES = 16384; // 16KB     // Default flags to use with PackageManager when no flags are given.     private final static int sDefaultFlags = PackageManager.GET_SHARED_LIBRARY_FILES;     private final Object mLock = new Object();     @GuardedBy(\"mLock\")     private UserManager mUserManager;     @GuardedBy(\"mLock\")     private PackageInstaller mInstaller;     @GuardedBy(\"mLock\")     private ArtManager mArtManager;     @GuardedBy(\"mDelegates\")     private final ArrayList<MoveCallbackDelegate> mDelegates = new ArrayList<>();     @GuardedBy(\"mLock\")     private String mPermissionsControllerPackageName;     UserManager getUserManager() {         synchronized (mLock) {             if (mUserManager == null) {                 mUserManager = UserManager.get(mContext);             }             return mUserManager;         }     }     @Override     public int getUserId() {         return mContext.getUserId();     }     @Override     public PackageInfo getPackageInfo(String packageName, int flags)     throws NameNotFoundException {         return getPackageInfoAsUser(packageName, flags, mContext.getUserId());     }     @Override     public PackageInfo getPackageInfoAsUser(String packageName, int flags, int userId)     throws NameNotFoundException {         try {             PackageInfo pi = mPM.getPackageInfo(packageName, flags, userId);             if (pi != null) {                 return pi;             }         } catch (RemoteException e) {             throw e.rethrowFromSystemServer();         }         throw new NameNotFoundException(packageName);     } }`\r\n\r\n我们看到在调用getPackageInfo方法时，最终调用了getPackageInfoAsUser方法，在这个方法中，我们看到有一个变量mPM，看样子就是PKMS的一个代理对象，所以我们只需要确定mPM是哪个类的对象即可。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`private final IPackageManager mPM;`\r\n\r\n从源码中可以看到，mPM是IPackageManager的一个实例对象，而IPackageManager就是 SystemServer和客户端进程间通信的aidl，其路径在下面：\r\n\r\n### [frameworks](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks\")/[base](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base\")/[core](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core\")/[java](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java\")/[android](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android\")/[content](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content\")/[pm](https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content/pm \"https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content/pm\")/IPackageManager.aidl\r\n\r\n因为这个文件里的方法太多了，我就不贴出来了，有兴趣的伙伴可以自行查看。\r\n\r\n那么mPM是在什么时候初始化的呢？\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`protected ApplicationPackageManager(ContextImpl context,     IPackageManager pm) {     mContext = context;     mPM = pm; }`\r\n\r\n通过源码我们发现，在ApplicationPackageManager的构造方法中，我们看到会对其进行赋值，因此我们前面看到getPackageManager方法调用时，应该就是创建了ApplicationPackageManager对象。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`@Override public PackageManager getPackageManager() {     if (mPackageManager != null) {         return mPackageManager;     }     IPackageManager pm = ActivityThread.getPackageManager();     if (pm != null) {         // Doesn\'t matter if we make more than one instance.         return (mPackageManager = new ApplicationPackageManager(this, pm));     }     return null; }`\r\n\r\n所以在getPackageInfoAsUser方法中，就是调用了PKMS的getPackageInfo方法，所以C/S之间的通信方式如下：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c60b68574afb49f5b4e29b929d98efb6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n## 1.2 PKMS启动流程分析\r\n\r\n前面我们提了一嘴，在SystemServer进程启动之后，就会启动PKMS，现在我们详细分析一下，PKMS的启动流程到底干了什么事。\r\n\r\n### 1.2.1 SystemServer引导服务启动流程\r\n\r\n具体的SystemServer启动流程，感兴趣的伙伴可以去前面的文章中看，我们直接进入到SystemServer的startBootstrapServices方法中。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`try {     Watchdog.getInstance().pauseWatchingCurrentThread(\"packagemanagermain\");     mPackageManagerService = PackageManagerService.main(mSystemContext, installer,             mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); } finally {     Watchdog.getInstance().resumeWatchingCurrentThread(\"packagemanagermain\"); }`\r\n\r\n跳过其他服务的启动，我们看到在启动PackageManagerService服务的时候，是直接调用了其mian方法。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`// Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions.  We need this to complete before we initialize other services. t.traceBegin(\"StartInstaller\"); Installer installer = mSystemServiceManager.startService(Installer.class); t.traceEnd();`\r\n\r\n在此之前，我们先关注一个Installer服务，通过注释我们发现这个服务还是挺重要的，**在初始化其他服务之前，首先要保证Installer服务的启动已经完成。**\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`Only run \"core\" apps if we\'re encrypting the device. String cryptState = VoldProperties.decrypt().orElse(\"\"); if (ENCRYPTING_STATE.equals(cryptState)) {     Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\");     mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) {     Slog.w(TAG, \"Device encrypted - only parsing core apps\");     mOnlyCore = true; }`\r\n\r\n然后会判断手机是否加密了，例如设置了手机密码，那么就只会解析core app，像做车载应用，通常都会将这个变量写死为false，因为没有隐私相关的app可以使用，一般车载也不会有设置密码这个选项。\r\n\r\n然后就会调用PackageManagerService的main方法，这里我们看到是把installer服务、手机是否加密作为变量参数传进去了。**伙伴们注意一下，这个方法是一个耗时方法，而且在手机开启启动的时候会慢，也是这个方法在捣鬼。**\r\n\r\n在启动PKMS完成之后，会根据手机设备是否加密，来决定是否启动OtaDexoptService服务。OtaDexoptService主要用来管理A/B升级和OTA升级以及dex文件优化，对于这两个升级名词如果做过系统升级的伙伴可能会了解，当系统升级时，端上会调用OS与A/B升级和OTA升级相关的接口，完成系统升级。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`// Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename // A/B artifacts after boot, before anything else might touch/need them. // Note: this isn\'t needed during decryption (we don\'t have /data anyways). if (!mOnlyCore) {     boolean disableOtaDexopt = SystemProperties.getBoolean(\"config.disable_otadexopt\",             false);     if (!disableOtaDexopt) {         t.traceBegin(\"StartOtaDexOptService\");         try {             Watchdog.getInstance().pauseWatchingCurrentThread(\"moveab\");             OtaDexoptService.main(mSystemContext, mPackageManagerService);         } catch (Throwable e) {             reportWtf(\"starting OtaDexOptService\", e);         } finally {             Watchdog.getInstance().resumeWatchingCurrentThread(\"moveab\");             t.traceEnd();         }     } }`\r\n\r\n当然更新策略也是根据app等级划分，core app > system app > other app，所以硬件设备是否支持加密（设置密码），对OTA升级有着直接影响。\r\n\r\n对于dex的优化，就是在引导服务流程结束之后，在startOtherServices方法中进行的。\r\n\r\n### 1.2.2 其他服务启动startOtherServices\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`private void startOtherServices(@NonNull TimingsTraceAndSlog t) {     // ......     if (!mOnlyCore) {         t.traceBegin(\"UpdatePackagesIfNeeded\");         try {             Watchdog.getInstance().pauseWatchingCurrentThread(\"dexopt\");             mPackageManagerService.updatePackagesIfNeeded();         } catch (Throwable e) {             reportWtf(\"update packages\", e);         } finally {             Watchdog.getInstance().resumeWatchingCurrentThread(\"dexopt\");         }         t.traceEnd();     }     // ......          try {         //完成磁盘清理维护         mPackageManagerService.performFstrimIfNeeded();     } catch (Throwable e) {         reportWtf(\"performing fstrim\", e);     }          // ......     mPackageManagerService.systemReady(); }`\r\n\r\n这里只看与PKMS相关的处理；首先会判断手机是否加密，如果没有加密，那么就会判断是否有package需要更新，dex是否需要优化。\r\n\r\n然后会调用performFstrimIfNeeded进行磁盘清理，最后重要的一步就是会调用systemReady方法，表示PKMS准备就绪了，如果这个时候服务出现异常，那么后续服务就不会再初始化，就会导致手机开启死机。\r\n\r\n那么这里我们总结一下，PKMS准备就绪需要的环节：\r\n\r\n-   启动Installer服务，是阻塞的，后续服务初始化的前提；\r\n-   判断手机是否加密，如果加密，则mOnlyCore = true，否则为false；\r\n-   执行PKMS的main方法，耗时阻塞的；\r\n-   根据mOnlyCore决定启动升级服务OtaDexoptService；\r\n-   根据mOnlyCore判断是否需要检查包更新，即调用PKMS的updatePackagesIfNeeded；\r\n-   调用PKMS的performFstrimIfNeeded方法进行磁盘清理；\r\n-   执行PKMS的systemReady方法，表示PKMS已经准备就绪了。\r\n\r\n所以当手机启动比较慢的时候，分析原因就可以从这几个方向入手。\r\n\r\n# 2 PKMS main方法分析\r\n\r\n前面主要介绍了PKMS在启动时到准备就绪的7个步骤，其中在第3步中调用了PKMS的main方法，我们看下在main方法中的处理逻辑。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`public static PackageManagerService main(Context context, Installer installer,         boolean factoryTest, boolean onlyCore) {     // Self-check for initial settings.     PackageManagerServiceCompilerMapping.checkProperties();     final TimingsTraceAndSlog t = new TimingsTraceAndSlog(TAG + \"Timing\",             Trace.TRACE_TAG_PACKAGE_MANAGER);     t.traceBegin(\"create package manager\");     final Object lock = new Object();     final Object installLock = new Object();     Injector injector = new Injector(             context, lock, installer, installLock, new PackageAbiHelperImpl(),             (i, pm) ->                     new ComponentResolver(i.getUserManagerService(), pm.mPmInternal, lock),             (i, pm) ->                     PermissionManagerService.create(context, lock),             (i, pm) ->                     new UserManagerService(context, pm,                             new UserDataPreparer(installer, installLock, context, onlyCore),                             lock),             (i, pm) ->                     new Settings(Environment.getDataDirectory(),                             i.getPermissionManagerServiceInternal().getPermissionSettings(),                             lock),             new Injector.LocalServicesProducer<>(ActivityTaskManagerInternal.class),             new Injector.LocalServicesProducer<>(ActivityManagerInternal.class),             new Injector.LocalServicesProducer<>(DeviceIdleInternal.class),             new Injector.LocalServicesProducer<>(StorageManagerInternal.class),             new Injector.LocalServicesProducer<>(NetworkPolicyManagerInternal.class),             new Injector.LocalServicesProducer<>(PermissionPolicyInternal.class),             new Injector.LocalServicesProducer<>(DeviceStorageMonitorInternal.class),             new Injector.SystemServiceProducer<>(DisplayManager.class),             new Injector.SystemServiceProducer<>(StorageManager.class),             new Injector.SystemServiceProducer<>(AppOpsManager.class),             (i, pm) -> AppsFilter.create(pm.mPmInternal, i),             (i, pm) -> (PlatformCompat) ServiceManager.getService(\"platform_compat\"));     PackageManagerService m = new PackageManagerService(injector, onlyCore, factoryTest);     t.traceEnd(); // \"create package manager\"     injector.getCompatibility().registerListener(SELinuxMMAC.SELINUX_LATEST_CHANGES,             packageName -> {                 synchronized (m.mInstallLock) {                     final AndroidPackage pkg;                     final PackageSetting ps;                     final SharedUserSetting sharedUser;                     final String oldSeInfo;                     synchronized (m.mLock) {                         ps = m.mSettings.getPackageLPr(packageName);                         if (ps == null) {                             Slog.e(TAG, \"Failed to find package setting \" + packageName);                             return;                         }                         pkg = ps.pkg;                         sharedUser = ps.getSharedUser();                         oldSeInfo = AndroidPackageUtils.getSeInfo(pkg, ps);                     }                     if (pkg == null) {                         Slog.e(TAG, \"Failed to find package \" + packageName);                         return;                     }                     final String newSeInfo = SELinuxMMAC.getSeInfo(pkg, sharedUser,                             m.mInjector.getCompatibility());                     if (!newSeInfo.equals(oldSeInfo)) {                         Slog.i(TAG, \"Updating seInfo for package \" + packageName + \" from: \"                                 + oldSeInfo + \" to: \" + newSeInfo);                         ps.getPkgState().setOverrideSeInfo(newSeInfo);                         m.prepareAppDataAfterInstallLIF(pkg);                     }                 }             });     m.installWhitelistedSystemPackages();     ServiceManager.addService(\"package\", m);     final PackageManagerNative pmn = m.new PackageManagerNative();     ServiceManager.addService(\"package_native\", pmn);     return m; }`\r\n\r\n在main方法中是存在返回值的，返回的就是PKMS实例对象，在main方法中，也是通过new出来了一个PackageManagerService对象，我们看下PKMS的构造方法。\r\n\r\n如果看过源码的伙伴会发现，PKMS的构造方法有上千行代码，这里只看核心方法即可，通过构造方法打印的日志，可以分为5个阶段进行分析。\r\n\r\n## 2.1 阶段1- BOOT\\_PROGRESS\\_PMS\\_START\r\n\r\n这个阶段可以认为是启动阶段，主要做一些初始化的操作。\r\n\r\n## 2.2 阶段2- BOOT\\_PROGRESS\\_PMS\\_SYSTEM\\_SCAN\\_START\r\n\r\n在这个阶段开始，进入到系统扫描阶段，在这个阶段里会扫描/system/app，system/priv-app等系统目录下的app，例如蓝牙apk、相机apk，以及各个业务存储的/system/app（如果需要预置权限）业务apk，统统都会扫描到，存储在PKMS当中，此时在开启启动的时候，就已经拿到了手机当中存在的所有apk，那么在进入到Launcher之后，就会拿到这些apk的信息，展示在ListView列表当中。\r\n\r\n## 2.3 阶段3- BOOT\\_PROGRESS\\_PMS\\_DATA\\_SCAN\\_START\r\n\r\n第三个阶段为扫描普通应用阶段，前面主要是从系统目录中扫描系统apk，那么用户从应用商店下载的应用会存储在user分区，那么此时就会从sAppInstallDir目录中去查找。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`if (!mOnlyCore) {     EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,             SystemClock.uptimeMillis());     scanDirTracedLI(sAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0,             packageParser, executorService); }`\r\n\r\n我们先看下sAppInstallDir具体是哪个目录，就是存储在/data/app目录下的全部应用；\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`/** Directory where installed applications are stored */ private static final File sAppInstallDir =         new File(Environment.getDataDirectory(), \"app\");`\r\n\r\n所以普通应用的扫描就是从scanDirTracedLI方法开始。\r\n\r\n-   第一步，调用scanDirLI方法\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`private void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime,         PackageParser2 packageParser, ExecutorService executorService) {     final File[] files = scanDir.listFiles();     //......     ParallelPackageParser parallelPackageParser =             new ParallelPackageParser(packageParser, executorService);     // Submit files for parsing in parallel     int fileCount = 0;     for (File file : files) {         final boolean isPackage = (isApkFile(file) || file.isDirectory())                 && !PackageInstallerService.isStageName(file.getName());         if (!isPackage) {             // Ignore entries which are not packages             continue;         }         //         parallelPackageParser.submit(file, parseFlags);         fileCount++;     }     // Process results one by one     for (; fileCount > 0; fileCount--) {         ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();         Throwable throwable = parseResult.throwable;         int errorCode = PackageManager.INSTALL_SUCCEEDED;         if (throwable == null) {             // TODO(toddke): move lower in the scan chain             // Static shared libraries have synthetic package names             if (parseResult.parsedPackage.isStaticSharedLibrary()) {                 renameStaticSharedLibraryPackage(parseResult.parsedPackage);             }             try {                 addForInitLI(parseResult.parsedPackage, parseFlags, scanFlags,                         currentTime, null);             } catch (PackageManagerException e) {                 errorCode = e.error;                 Slog.w(TAG, \"Failed to scan \" + parseResult.scanFile + \": \" + e.getMessage());             }         } else if (throwable instanceof PackageParserException) {             PackageParserException e = (PackageParserException)                     throwable;             errorCode = e.error;             Slog.w(TAG, \"Failed to parse \" + parseResult.scanFile + \": \" + e.getMessage());         } else {             throw new IllegalStateException(\"Unexpected exception occurred while parsing \"                     + parseResult.scanFile, throwable);         }         if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0 && errorCode != INSTALL_SUCCEEDED) {             mApexManager.reportErrorWithApkInApex(scanDir.getAbsolutePath());         }         // Delete invalid userdata apps         if ((scanFlags & SCAN_AS_SYSTEM) == 0                 && errorCode != PackageManager.INSTALL_SUCCEEDED) {             logCriticalInfo(Log.WARN,                     \"Deleting invalid package at \" + parseResult.scanFile);             removeCodePathLI(parseResult.scanFile);         }     } }`\r\n\r\n首先创建一个ParallelPackageParser对象，这个类的主要作用就是内部维护了线程池和阻塞队列。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`class ParallelPackageParser {     private static final int QUEUE_CAPACITY = 30;     private static final int MAX_THREADS = 4;     private volatile String mInterruptedInThread;     private final BlockingQueue<ParseResult> mQueue = new ArrayBlockingQueue<>(QUEUE_CAPACITY);     static ExecutorService makeExecutorService() {         return ConcurrentUtils.newFixedThreadPool(MAX_THREADS, \"package-parsing-thread\",                 Process.THREAD_PRIORITY_FOREGROUND);     } }`\r\n\r\n然后会遍历/data/app目录下全部的文件，找到apk文件，调用ParallelPackageParser的subimt方法，将其入队。\r\n\r\n-   第二步：调用ParallelPackageParser的submit方法\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`/**  * Submits the file for parsing  * @param scanFile file to scan  * @param parseFlags parse flags  */ public void submit(File scanFile, int parseFlags) {     mExecutorService.submit(() -> {         ParseResult pr = new ParseResult();         Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parallel parsePackage [\" + scanFile + \"]\");         try {             pr.scanFile = scanFile;             pr.parsedPackage = parsePackage(scanFile, parseFlags);         } catch (Throwable e) {             pr.throwable = e;         } finally {             Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);         }         try {             mQueue.put(pr);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();             // Propagate result to callers of take().             // This is helpful to prevent main thread from getting stuck waiting on             // ParallelPackageParser to finish in case of interruption             mInterruptedInThread = Thread.currentThread().getName();         }     }); }`\r\n\r\n这个方法比较简单，就是通过线程池，在内部封装了一个ParseResult对象，将apk文件作为其对象参数，最终将ParseResult对象加入BlockQueue队列中。\r\n\r\n-   第三步：PackageParser2.parsePackage\r\n\r\n这里为啥要开线程池，一个就是考虑并发的问题，再一个就是我们看到会调用parsePackage方法解析，通过PackageParser2进行解析。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`protected ParsedPackage parsePackage(File scanFile, int parseFlags)         throws PackageParser.PackageParserException {     return mPackageParser.parsePackage(scanFile, parseFlags, true); }`\r\n\r\n我们看下PackageParser2中的parsePackage方法，这个方法会返回一个解析过的package对象ParsedPackage。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`@AnyThread public ParsedPackage parsePackage(File packageFile, int flags, boolean useCaches)         throws PackageParserException {     // ......          ParseResult<ParsingPackage> result = parsingUtils.parsePackage(input, packageFile, flags);     if (result.isError()) {         throw new PackageParserException(result.getErrorCode(), result.getErrorMessage(),                 result.getException());     }     ParsedPackage parsed = (ParsedPackage) result.getResult().hideAsParsed();     long cacheTime = LOG_PARSE_TIMINGS ? SystemClock.uptimeMillis() : 0;     if (mCacher != null) {         mCacher.cacheResult(packageFile, flags, parsed);     }     if (LOG_PARSE_TIMINGS) {         parseTime = cacheTime - parseTime;         cacheTime = SystemClock.uptimeMillis() - cacheTime;         if (parseTime + cacheTime > LOG_PARSE_TIMINGS_THRESHOLD_MS) {             Slog.i(TAG, \"Parse times for \'\" + packageFile + \"\': parse=\" + parseTime                     + \"ms, update_cache=\" + cacheTime + \" ms\");         }     }     return parsed; }`\r\n\r\n在这个方法内部，会调用ParsingPackageUtils的parsePackage方法，最终会返回解析的结果。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`public ParseResult<ParsingPackage> parsePackage(ParseInput input, File packageFile,         int flags)         throws PackageParserException {     if (packageFile.isDirectory()) {         return parseClusterPackage(input, packageFile, flags);     } else {         return parseMonolithicPackage(input, packageFile, flags);     } }`\r\n\r\n在parsePackage方法中，首先会判断传进来的文件是文件夹还是文件；如果是文件夹，那么就会调用parseClusterPackage方法，如果是文件，那么就会调用parseMonolithicPackage方法。\r\n\r\n因为我们传进来的是apk文件，我们关注下parseMonolithicPackage这个方法。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`/**  * Parse the given APK file, treating it as as a single monolithic package.  * <p>  * Note that this <em>does not</em> perform signature verification; that  * must be done separately in {@link #getSigningDetails(ParsingPackageRead, boolean)}.  */ private ParseResult<ParsingPackage> parseMonolithicPackage(ParseInput input, File apkFile,         int flags) throws PackageParserException {     ParseResult<PackageParser.PackageLite> liteResult =             ApkLiteParseUtils.parseMonolithicPackageLite(input, apkFile, flags);     if (liteResult.isError()) {         return input.error(liteResult);     }     final PackageParser.PackageLite lite = liteResult.getResult();     if (mOnlyCoreApps && !lite.coreApp) {         return input.error(INSTALL_PARSE_FAILED_ONLY_COREAPP_ALLOWED,                 \"Not a coreApp: \" + apkFile);     }     final SplitAssetLoader assetLoader = new DefaultSplitAssetLoader(lite, flags);     try {         //核心函数         ParseResult<ParsingPackage> result = parseBaseApk(input,                 apkFile,                 apkFile.getCanonicalPath(),                 assetLoader.getBaseAssetManager(), flags);         if (result.isError()) {             return input.error(result);         }         return input.success(result.getResult()                 .setUse32BitAbi(lite.use32bitAbi));     } catch (IOException e) {         return input.error(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION,                 \"Failed to get path: \" + apkFile, e);     } finally {         IoUtils.closeQuietly(assetLoader);     } }`\r\n\r\n在这个方法中，核心代码为parseBaseApk方法的调用，这个方法用于对单体apk进行解析，最终返回解析之后的结果。\r\n\r\n-   第四步：parseBaseApk方法调用\r\n\r\n在parseBaseApk方法中，会调用其重载方法，我们关注下这个重载方法，看代码注释是用于解析apk的manifest清单文件。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`/**  * Parse the manifest of a <em>base APK</em>. When adding new features you  * need to consider whether they should be supported by split APKs and child  * packages.  *  * @param apkPath The package apk file path  * @param res     The resources from which to resolve values  * @param parser  The manifest parser  * @param flags   Flags how to parse  * @return Parsed package or null on error.  */ private ParseResult<ParsingPackage> parseBaseApk(ParseInput input, String apkPath,         String codePath, Resources res, XmlResourceParser parser, int flags)         throws XmlPullParserException, IOException, PackageParserException {     final String splitName;     final String pkgName;     ParseResult<Pair<String, String>> packageSplitResult =             ApkLiteParseUtils.parsePackageSplitNames(input, parser, parser);     if (packageSplitResult.isError()) {         return input.error(packageSplitResult);     }     Pair<String, String> packageSplit = packageSplitResult.getResult();     pkgName = packageSplit.first;     splitName = packageSplit.second;     if (!TextUtils.isEmpty(splitName)) {         return input.error(                 PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME,                 \"Expected base APK, but found split \" + splitName         );     }     //解析Manifest     final TypedArray manifestArray = res.obtainAttributes(parser, R.styleable.AndroidManifest);     try {         final boolean isCoreApp =                 parser.getAttributeBooleanValue(null, \"coreApp\", false);         final ParsingPackage pkg = mCallback.startParsingPackage(                 pkgName, apkPath, codePath, manifestArray, isCoreApp);         final ParseResult<ParsingPackage> result =                 parseBaseApkTags(input, pkg, manifestArray, res, parser, flags);         if (result.isError()) {             return result;         }         return input.success(pkg);     } finally {         manifestArray.recycle();     } }`\r\n\r\n在这个方法中，首先会解析manifest清单文件拿到一个TypedArray，其中记录了当前apk清单文件中每个节点的信息，调用parseBaseApkTags方法。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`private ParseResult<ParsingPackage> parseBaseApkTags(ParseInput input, ParsingPackage pkg,         TypedArray sa, Resources res, XmlResourceParser parser, int flags)         throws XmlPullParserException, IOException {     ParseResult<ParsingPackage> sharedUserResult = parseSharedUser(input, pkg, sa);     if (sharedUserResult.isError()) {         return sharedUserResult;     }    //设置apk存储位置 pkg.setInstallLocation(anInteger(PackageParser.PARSE_DEFAULT_INSTALL_LOCATION,             R.styleable.AndroidManifest_installLocation, sa))             .setTargetSandboxVersion(anInteger(PackageParser.PARSE_DEFAULT_TARGET_SANDBOX,                     R.styleable.AndroidManifest_targetSandboxVersion, sa))             /* Set the global \"on SD card\" flag */             .setExternalStorage((flags & PackageParser.PARSE_EXTERNAL_STORAGE) != 0);     boolean foundApp = false;     final int depth = parser.getDepth();     int type;     //解析清单文件     while ((type = parser.next()) != XmlPullParser.END_DOCUMENT             && (type != XmlPullParser.END_TAG             || parser.getDepth() > depth)) {         if (type != XmlPullParser.START_TAG) {             continue;         }         String tagName = parser.getName();         final ParseResult result;         // TODO(b/135203078): Convert to instance methods to share variables         // <application> has special logic, so it\'s handled outside the general method         // 核心代码         if (PackageParser.TAG_APPLICATION.equals(tagName)) {             if (foundApp) {                 if (PackageParser.RIGID_PARSER) {                     result = input.error(\"<manifest> has more than one <application>\");                 } else {                     Slog.w(TAG, \"<manifest> has more than one <application>\");                     result = input.success(null);                 }             } else {                 foundApp = true;                 result = parseBaseApplication(input, pkg, res, parser, flags);             }         } else {             result = parseBaseApkTag(tagName, input, pkg, res, parser, flags);         }         if (result.isError()) {             return input.error(result);         }     }     if (!foundApp && ArrayUtils.size(pkg.getInstrumentations()) == 0) {         ParseResult<?> deferResult = input.deferError(                 \"<manifest> does not contain an <application> or <instrumentation>\",                 DeferredError.MISSING_APP_TAG);         if (deferResult.isError()) {             return input.error(deferResult);         }     }     if (!ParsedAttribution.isCombinationValid(pkg.getAttributions())) {         return input.error(                 INSTALL_PARSE_FAILED_BAD_MANIFEST,                 \"Combination <feature> tags are not valid\"         );     }     convertNewPermissions(pkg);     convertSplitPermissions(pkg);     // At this point we can check if an application is not supporting densities and hence     // cannot be windowed / resized. Note that an SDK version of 0 is common for     // pre-Doughnut applications.     if (pkg.getTargetSdkVersion() < DONUT             || (!pkg.isSupportsSmallScreens()             && !pkg.isSupportsNormalScreens()             && !pkg.isSupportsLargeScreens()             && !pkg.isSupportsExtraLargeScreens()             && !pkg.isResizeable()             && !pkg.isAnyDensity())) {         adjustPackageToBeUnresizeableAndUnpipable(pkg);     }     return input.success(pkg); }`\r\n\r\nparseBaseApkTags从方法名中就可以猜到，其实就是解析apk的参数，也就是Manifest清单文件的解析。\r\n\r\n-   核心代码\r\n\r\n在解析清单文件时，判断是否为application标签。\r\n\r\nxml\r\n\r\n复制代码\r\n\r\n`<?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"     package=\"com.example.appbuilder\">     <application         android:allowBackup=\"true\"         android:icon=\"@mipmap/ic_launcher\"         android:label=\"@string/app_name\"         android:roundIcon=\"@mipmap/ic_launcher_round\"         android:supportsRtl=\"true\"         android:theme=\"@style/AppTheme\">         <activity android:name=\".MainActivity\">             <intent-filter>                 <action android:name=\"android.intent.action.MAIN\" />                 <category android:name=\"android.intent.category.LAUNCHER\" />             </intent-filter>         </activity>     </application> </manifest>`\r\n\r\n如果是application标签，因为foundApp默认为false，就会将其置为true，代表找到了application，此时会调用parseBaseApplication方法。\r\n\r\n后续这个foundApp标志位判断，如果为false，那么就会报错，因为没有application标签，具体异常可以看代码，我们接下来看parseBaseApplication方法。\r\n\r\n-   第五步：parseBaseApplication解析application标签\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`private ParseResult<ParsingPackage> parseBaseApplication(ParseInput input,         ParsingPackage pkg, Resources res, XmlResourceParser parser, int flags)         throws XmlPullParserException, IOException {     final String pkgName = pkg.getPackageName();     int targetSdk = pkg.getTargetSdkVersion();     TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestApplication);     try {         // TODO(b/135203078): Remove this and force unit tests to mock an empty manifest         // This case can only happen in unit tests where we sometimes need to create fakes         // of various package parser data structures.         if (sa == null) {             return input.error(\"<application> does not contain any attributes\");         }         String name = sa.getNonConfigurationString(R.styleable.AndroidManifestApplication_name,                 0);         if (name != null) {             String packageName = pkg.getPackageName();             String outInfoName = ParsingUtils.buildClassName(packageName, name);             if (PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME.equals(outInfoName)) {                 return input.error(\"<application> invalid android:name\");             } else if (outInfoName == null) {                 return input.error(\"Empty class name in package \" + packageName);             }             pkg.setClassName(outInfoName);         }         TypedValue labelValue = sa.peekValue(R.styleable.AndroidManifestApplication_label);         if (labelValue != null) {             pkg.setLabelRes(labelValue.resourceId);             if (labelValue.resourceId == 0) {                 pkg.setNonLocalizedLabel(labelValue.coerceToString());             }         }         parseBaseAppBasicFlags(pkg, sa);         String manageSpaceActivity = nonConfigString(Configuration.NATIVE_CONFIG_VERSION,                 R.styleable.AndroidManifestApplication_manageSpaceActivity, sa);         if (manageSpaceActivity != null) {             String manageSpaceActivityName = ParsingUtils.buildClassName(pkgName,                     manageSpaceActivity);             if (manageSpaceActivityName == null) {                 return input.error(\"Empty class name in package \" + pkgName);             }             pkg.setManageSpaceActivityName(manageSpaceActivityName);         }         if (pkg.isAllowBackup()) {             // backupAgent, killAfterRestore, fullBackupContent, backupInForeground,             // and restoreAnyVersion are only relevant if backup is possible for the             // given application.             String backupAgent = nonConfigString(Configuration.NATIVE_CONFIG_VERSION,                     R.styleable.AndroidManifestApplication_backupAgent, sa);             if (backupAgent != null) {                 String backupAgentName = ParsingUtils.buildClassName(pkgName, backupAgent);                 if (backupAgentName == null) {                     return input.error(\"Empty class name in package \" + pkgName);                 }                 if (PackageParser.DEBUG_BACKUP) {                     Slog.v(TAG, \"android:backupAgent = \" + backupAgentName                             + \" from \" + pkgName + \"+\" + backupAgent);                 }                 pkg.setBackupAgentName(backupAgentName)                         .setKillAfterRestore(bool(true,                                 R.styleable.AndroidManifestApplication_killAfterRestore, sa))                         .setRestoreAnyVersion(bool(false,                                 R.styleable.AndroidManifestApplication_restoreAnyVersion, sa))                         .setFullBackupOnly(bool(false,                                 R.styleable.AndroidManifestApplication_fullBackupOnly, sa))                         .setBackupInForeground(bool(false,                                 R.styleable.AndroidManifestApplication_backupInForeground, sa));             }             TypedValue v = sa.peekValue(                     R.styleable.AndroidManifestApplication_fullBackupContent);             int fullBackupContent = 0;             if (v != null) {                 fullBackupContent = v.resourceId;                 if (v.resourceId == 0) {                     if (PackageParser.DEBUG_BACKUP) {                         Slog.v(TAG, \"fullBackupContent specified as boolean=\" +                                 (v.data == 0 ? \"false\" : \"true\"));                     }                     // \"false\" => -1, \"true\" => 0                     fullBackupContent = v.data == 0 ? -1 : 0;                 }                 pkg.setFullBackupContent(fullBackupContent);             }             if (PackageParser.DEBUG_BACKUP) {                 Slog.v(TAG, \"fullBackupContent=\" + fullBackupContent + \" for \" + pkgName);             }         }         if (sa.getBoolean(R.styleable.AndroidManifestApplication_persistent, false)) {             // Check if persistence is based on a feature being present             final String requiredFeature = sa.getNonResourceString(R.styleable                     .AndroidManifestApplication_persistentWhenFeatureAvailable);             pkg.setPersistent(requiredFeature == null || mCallback.hasFeature(requiredFeature));         }         // TODO(b/135203078): Should parsing code be responsible for this? Maybe move to a         //  util or just have PackageImpl return true if either flag is set         // Debuggable implies profileable         pkg.setProfileableByShell(pkg.isProfileableByShell() || pkg.isDebuggable());         if (sa.hasValueOrEmpty(R.styleable.AndroidManifestApplication_resizeableActivity)) {             pkg.setResizeableActivity(sa.getBoolean(                     R.styleable.AndroidManifestApplication_resizeableActivity, true));         } else {             pkg.setResizeableActivityViaSdkVersion(                     targetSdk >= Build.VERSION_CODES.N);         }         String taskAffinity;         if (targetSdk >= Build.VERSION_CODES.FROYO) {             taskAffinity = sa.getNonConfigurationString(                     R.styleable.AndroidManifestApplication_taskAffinity,                     Configuration.NATIVE_CONFIG_VERSION);         } else {             // Some older apps have been seen to use a resource reference             // here that on older builds was ignored (with a warning).  We             // need to continue to do this for them so they don\'t break.             taskAffinity = sa.getNonResourceString(                     R.styleable.AndroidManifestApplication_taskAffinity);         }         ParseResult<String> taskAffinityResult = ComponentParseUtils.buildTaskAffinityName(                 pkgName, pkgName, taskAffinity, input);         if (taskAffinityResult.isError()) {             return input.error(taskAffinityResult);         }         pkg.setTaskAffinity(taskAffinityResult.getResult());         String factory = sa.getNonResourceString(                 R.styleable.AndroidManifestApplication_appComponentFactory);         if (factory != null) {             String appComponentFactory = ParsingUtils.buildClassName(pkgName, factory);             if (appComponentFactory == null) {                 return input.error(\"Empty class name in package \" + pkgName);             }             pkg.setAppComponentFactory(appComponentFactory);         }         CharSequence pname;         if (targetSdk >= Build.VERSION_CODES.FROYO) {             pname = sa.getNonConfigurationString(                     R.styleable.AndroidManifestApplication_process,                     Configuration.NATIVE_CONFIG_VERSION);         } else {             // Some older apps have been seen to use a resource reference             // here that on older builds was ignored (with a warning).  We             // need to continue to do this for them so they don\'t break.             pname = sa.getNonResourceString(                     R.styleable.AndroidManifestApplication_process);         }         ParseResult<String> processNameResult = ComponentParseUtils.buildProcessName(                 pkgName, null, pname, flags, mSeparateProcesses, input);         if (processNameResult.isError()) {             return input.error(processNameResult);         }         String processName = processNameResult.getResult();         pkg.setProcessName(processName);         if (pkg.isCantSaveState()) {             // A heavy-weight application can not be in a custom process.             // We can do direct compare because we intern all strings.             if (processName != null && !processName.equals(pkgName)) {                 return input.error(                         \"cantSaveState applications can not use custom processes\");             }         }         String classLoaderName = pkg.getClassLoaderName();         if (classLoaderName != null                 && !ClassLoaderFactory.isValidClassLoaderName(classLoaderName)) {             return input.error(\"Invalid class loader name: \" + classLoaderName);         }         pkg.setGwpAsanMode(sa.getInt(R.styleable.AndroidManifestApplication_gwpAsanMode, -1));     } finally {         sa.recycle();     }     boolean hasActivityOrder = false;     boolean hasReceiverOrder = false;     boolean hasServiceOrder = false;     final int depth = parser.getDepth();     int type;     while ((type = parser.next()) != XmlPullParser.END_DOCUMENT             && (type != XmlPullParser.END_TAG             || parser.getDepth() > depth)) {         if (type != XmlPullParser.START_TAG) {             continue;         }         final ParseResult result;         String tagName = parser.getName();         boolean isActivity = false;         switch (tagName) {             case \"activity\":                 isActivity = true;                 // fall-through             case \"receiver\":                 ParseResult<ParsedActivity> activityResult =                         ParsedActivityUtils.parseActivityOrReceiver(mSeparateProcesses, pkg,                                 res, parser, flags, PackageParser.sUseRoundIcon, input);                 if (activityResult.isSuccess()) {                     ParsedActivity activity = activityResult.getResult();                     if (isActivity) {                         hasActivityOrder |= (activity.getOrder() != 0);                         pkg.addActivity(activity);                     } else {                         hasReceiverOrder |= (activity.getOrder() != 0);                         pkg.addReceiver(activity);                     }                 }                 result = activityResult;                 break;             case \"service\":                 ParseResult<ParsedService> serviceResult =                         ParsedServiceUtils.parseService(mSeparateProcesses, pkg, res, parser,                                 flags, PackageParser.sUseRoundIcon, input);                 if (serviceResult.isSuccess()) {                     ParsedService service = serviceResult.getResult();                     hasServiceOrder |= (service.getOrder() != 0);                     pkg.addService(service);                 }                 result = serviceResult;                 break;             case \"provider\":                 ParseResult<ParsedProvider> providerResult =                         ParsedProviderUtils.parseProvider(mSeparateProcesses, pkg, res, parser,                                 flags, PackageParser.sUseRoundIcon, input);                 if (providerResult.isSuccess()) {                     pkg.addProvider(providerResult.getResult());                 }                 result = providerResult;                 break;             case \"activity-alias\":                 activityResult = ParsedActivityUtils.parseActivityAlias(pkg, res,                         parser, PackageParser.sUseRoundIcon, input);                 if (activityResult.isSuccess()) {                     ParsedActivity activity = activityResult.getResult();                     hasActivityOrder |= (activity.getOrder() != 0);                     pkg.addActivity(activity);                 }                 result = activityResult;                 break;             default:                 result = parseBaseAppChildTag(input, tagName, pkg, res, parser, flags);                 break;         }         if (result.isError()) {             return input.error(result);         }     }     if (TextUtils.isEmpty(pkg.getStaticSharedLibName())) {         // Add a hidden app detail activity to normal apps which forwards user to App Details         // page.         ParseResult<ParsedActivity> a = generateAppDetailsHiddenActivity(input, pkg);         if (a.isError()) {             // Error should be impossible here, as the only failure case as of SDK R is a             // string validation error on a constant \":app_details\" string passed in by the             // parsing code itself. For this reason, this is just a hard failure instead of             // deferred.             return input.error(a);         }         pkg.addActivity(a.getResult());     }     if (hasActivityOrder) {         pkg.sortActivities();     }     if (hasReceiverOrder) {         pkg.sortReceivers();     }     if (hasServiceOrder) {         pkg.sortServices();     }     // Must be run after the entire {@link ApplicationInfo} has been fully processed and after     // every activity info has had a chance to set it from its attributes.     setMaxAspectRatio(pkg);     setMinAspectRatio(pkg);     setSupportsSizeChanges(pkg);     pkg.setHasDomainUrls(hasDomainURLs(pkg));     return input.success(pkg); }`\r\n\r\n这个方法中，其实就会解析application标签中所有的信息，包括内部的四大组件标签activity/service/receiver/contentprovider，每解析一个，都会存储在ParsingPackage当中。\r\n\r\njava\r\n\r\n复制代码\r\n\r\n`ParsingPackage addActivity(ParsedActivity parsedActivity); ParsingPackage addService(ParsedService parsedService);`\r\n\r\n**那么这么做的好处就是，当我们每次启动一个Activity的时候，不需要每次都去解析Activity相关信息，例如launchMode，直接去ParsingPackage中获取即可。**\r\n\r\n至此，PKMS的main方法基本算是执行结束了，当然还有剩余的2个阶段，这里不做过多赘述，所以如果我们的手机安装了很多应用，那么开启速度上可能会受到影响，但是这个是用户可以接受的，这也为我们后续启动应用或者启动Activity提供了强力的数据支撑，不需要在启动的时候解析Activity的相关参数信息。\r\n\r\n所以这里可能会有一些问题，需要伙伴们注意一下：\r\n\r\n-   问题1：当Activity A跳转到Activity B的时候，Activity B的launchMode是什么时候解析的？\r\n\r\n因为在手机启动的时候，会扫描所有apk的清单文件，对于每个Activity的launchMode也是写在清单文件当中，所以在第三阶段就拿到了launchMode信息，存储在了PKMS内存当中。\r\n\r\n-   问题2：所有静态广播是什么时候注册的？\r\n\r\n通过上一个问题，我们也能猜到，因为在PKMS扫描阶段会扫描所有apk的清单文件，对于静态广播也是放在清单文件当中的，所以也是在第三阶段进行注册的。\r\n\r\n-   问题3：系统是如何安装apk的？\r\n\r\n当系统安装apk时，会将apk拷贝到/data/app目录下，类似于adb push的操作，然后重启PKMS会扫描到新安装的应用，并存储信息到PKMS中。\r\n\r\n通过这一节我们大概能够了解PKMS在启动时到底干了什么事，以及客户端在调用PKMS接口时内部进程间通信的具体逻辑，这也对我们后续的自升级方案有一定的理论基础。', '', 3, 3, 3, 469, '2023-09-09 10:55:28', 1);
INSERT INTO `article` VALUES (3, 5, 'md-editor-v3', '## 😲 md-editor-v3\n\nMarkdown Editor for Vue3, developed in jsx and typescript, support different themes、beautify content by prettier.\n\n### 🤖 Base\n\n**bold**, <u>underline</u>, _italic_, ~~line-through~~, superscript<sup>26</sup>, subscript<sub>1</sub>, `inline code`, [link](https://imzbf.cc)\n\n> quote: I Have a Dream\n\n1. So even though we face the difficulties of today and tomorrow, I still have a dream.\n2. It is a dream deeply rooted in the American dream.\n3. I have a dream that one day this nation will rise up.\n\n- [ ] Friday\n- [ ] Saturday\n- [x] Sunday\n\n![Picture](https://imzbf.github.io/md-editor-rt/imgs/mark_emoji.gif)\n\n## 🤗 Code\n\n```vue\n<template>\n  <MdEditor v-model=\"text\" />\n</template>\n\n<script setup>\nimport { ref } from \'vue\';\nimport { MdEditor } from \'md-editor-v3\';\nimport \'md-editor-v3/lib/style.css\';\n\nconst text = ref(\'Hello Editor!\');\n</script>\n```\n\n## 🖨 Text\n\nThe Old Man and the Sea served to reinvigorate Hemingway\'s literary reputation and prompted a reexamination of his entire body of work.\n\n## 📈 Table\n\n| nickname | from             |\n| -------- | ---------------- |\n| zhijian  | ChongQing, China |\n\n## 📏 Formula\n\nInline: $x+y^{2x}$\n\n$$\n\\sqrt[3]{x}\n$$\n\n## 🧬 Diagram\n\n```mermaid\nflowchart TD\n  Start --> Stop\n```\n\n## 🪄 Alert\n\n!!! note Supported Types\n\nnote、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote、hint、caution、error、attention\n\n!!!\n\n## ☘️ em...\n', '', 1, 5, 3, 952, '2023-09-09 11:43:36', 0);
INSERT INTO `article` VALUES (4, 5, 'Mr.', 'How we spend our days is, of course, how we spend our lives. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. Actually it is just in an idea when feel oneself can achieve and cannot achieve. What you get by achieving your goals is not as important as what you become by achieving your goals. The reason why a great man is great is that he resolves to be a great man. The Synchronize to Database function will give you a full picture of all database differences. Secure Sockets Layer(SSL) is a protocol for transmitting private documents via the Internet. A query is used to extract data from the database in a readable format according to the user\'s request. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. Remember that failure is an event, not a person. Secure SHell (SSH) is a program to log in into another computer over a network, execute commands on a remote server, and move files from one machine to another. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. Anyone who has ever made anything of importance was disciplined. I may not have gone where I intended to go, but I think I have ended up where I needed to be. It wasn’t raining when Noah built the ark. The first step is as good as half over. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. A man’s best friends are his ten fingers. In the middle of winter I at last discovered that there was in me an invincible summer. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview.', '', 1, 3, 0, 140, '2023-09-06 15:44:03', 0);
INSERT INTO `article` VALUES (5, 7, '常见Vue原理面试题，看你翅膀硬了没', '我正在参加「掘金·启航计划」\n\n___\n\n## 1\\. Vue的响应式原理是什么？请详细说明Object.defineProperty()和Proxy的区别和用法。\n\n响应式原理：Vue中采用了数据劫持的方式，通过Object.defineProperty()函数来监听数据变化，并在数据变化时触发对应的更新函数。 Object.defineProperty()与Proxy的区别：前者只能监听属性的读取和修改，后者可以监听数组的变化等更多场景，且性能更高。\n\n```\n\n// 实现observe函数，对data对象中的所有属性进行数据劫持\nfunction observe(data) {\n  if (!data || typeof data !== \'object\') {\n    return\n  }\n  Object.keys(data).forEach(key => {\n    defineReactive(data, key, data[key])\n  })\n}\n\n// 定义defineReactive函数，通过Object.defineProperty()函数来监听数据变化\nfunction defineReactive(obj, key, val) {\n  observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      console.log(\'get value:\', val)\n      return val\n    },\n    set: function reactiveSetter(newVal) {\n      console.log(\'set value:\', newVal)\n      val = newVal\n    }\n  })\n}\n\n// 测试代码\nconst obj = { name: \'Tom\', age: 18 }\nobserve(obj)\nobj.age = 20\nconsole.log(obj.age) // 输出：20\n```\n\n## 2\\. Vue的模板编译原理是什么？请说明它的优化策略和实现方式。并手动实现一个简单的模板编译器。\n\n模板编译原理：Vue中将用户写好的模板转换成渲染函数，实际渲染时调用该函数进行渲染。模板编译主要包括三个阶段：解析、优化和生成。\n\n优化策略：Vue在模板编译阶段会对模板进行静态节点标记和静态根节点标记，从而可以避免不必要的重复渲染和提升整体渲染性能。\n\n实现方式：Vue通过将模板解析成抽象语法树(AST)，再转换成render函数的方式来实现模板编译。最终生成的render函数就是一个虚拟DOM的描述对象，然后通过虚拟DOM的diff算法进行渲染更新。\n\n```\n// 简化版的 Vue 模板编译器\nfunction compile(template) {\n  var element = document.createElement(\'div\');\n  element.innerHTML = template;\n\n  Array.from(element.childNodes).forEach(function(node) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      var reg = /\\{\\{(.+)\\}\\}/;\n      var match = node.textContent.match(reg);\n      if (match) {\n        var key = match[1].trim();\n        node.textContent = \'{{\' + key + \'}}\';\n        node._key = key;\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      Array.from(node.attributes).forEach(function(attr) {\n        if (attr.name.startsWith(\'v-\')) {\n          if (attr.name === \'v-model\') {\n            node.value = \'\';\n            node.addEventListener(\'input\', function(event) {\n              vm[attr.value] = event.target.value;\n            });\n          }\n          node.removeAttribute(attr.name);\n        }\n      });\n    }\n\n    if (node.childNodes.length > 0) {\n      compile(node.innerHTML);\n    }\n  });\n\n  return element.innerHTML;\n}\n\nvar vm = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello, World!\'\n  },\n  template: \'<div><h1>{{message}}</h1></div>\'\n});\n\ndocument.getElementById(\'app\').innerHTML = compile(vm.template);\n\n```\n\n## 3\\. Vue中的虚拟DOM算法是什么？请说明其原理和优化策略。\n\n虚拟DOM算法：Vue中通过比较新旧虚拟DOM树之间的差异来最小化更新操作，从而提高渲染效率。虚拟DOM算法主要包括两个步骤：Diff算法和更新操作。\n\n原理：Vue将模板编译成虚拟DOM树，并将其与上一个虚拟DOM树进行比较，找出需要更新的节点并进行更新操作。\n\n优化策略：Vue采用了一些策略来减少比较的次数，优化了虚拟DOM树的构建和比较的性能。\n\n```\n\n// 旧的虚拟DOM树\nconst prevVNode = {\n  tag: \'div\',\n  props: { id: \'container\' },\n  children: [\n    { tag: \'h1\', children: \'Hello, World!\' },\n    { tag: \'p\', children: \'Welcome to my website.\' }\n  ]\n}\n\n// 新的虚拟DOM树\nconst nextVNode = {\n  tag: \'div\',\n  props: { id: \'container\' },\n  children: [\n    { tag: \'h1\', children: \'Hello, Vue!\' },\n    { tag: \'p\', children: \'Welcome to the Vue world.\' }\n  ]\n}\n\n// 执行diff算法，得到需要更新的节点\nfunction diff(prevVNode, nextVNode) {\n  if (prevVNode.tag === nextVNode.tag) {\n    const patchProps = {}\n    const prevChildren = prevVNode.children\n    const prevProps = prevVNode.props\n    const nextChildren = nextVNode.children\n    const nextProps = nextVNode.props\n\n    // diff props\n    for (const key in nextProps) {\n      const prevVal = prevProps[key]\n      const nextVal = nextProps[key]\n      if (prevVal !== nextVal) {\n        patchProps[key] = nextVal\n      }\n    }\n\n    // diff children\n    if (prevChildren.length !== nextChildren.length) {\n      patchProps.children = nextChildren\n    } else {\n      const patchChildren = []\n      for (let i = 0; i < nextChildren.length; i++) {\n        const childPatch = diff(prevChildren[i], nextChildren[i])\n        patchChildren.push(childPatch)\n      }\n      patchProps.children = patchChildren\n    }\n\n    return { type: \'update\', props: patchProps }\n  } else {\n    return { type: \'replace\', node: nextVNode }\n  }\n}\n\n// 执行更新操作，将差异应用到真实DOM树上\nfunction patch(node, patchProps) {\n  switch (patchProps.type) {\n    case \'replace\':\n      const newNode = createDOMElement(patchProps.node)\n      node.parentNode.replaceChild(newNode, node)\n      break\n    case \'update\':\n      updateDOMProps(node, patchProps.props)\n      for (const patchChild of patchProps.children) {\n        patch(node.children[patchChild.index], patchChild.props)\n      }\n      break\n  }\n}\n```\n\n## 4\\. Vue中的组件通信有哪些方式？请分别说明它们的特点和应用场景。\n\n组件通信方式：\n\n1.  父子组件通信：通过props传递数据和事件监听。 特点：简单易用，适用于父子组件之间的数据交互。 应用场景：父子组件之间的状态传递和操作。\n    \n2.  子父组件通信：通过 `$emit` 触发自定义事件和 `$on` 监听事件。 特点：适用于子组件向父组件传递数据和状态变更。 应用场景：子组件向父组件传递用户输入或其他数据。\n    \n3.  兄弟组件通信：通过`$emit/ $on`或vuex进行数据共享。 特点：适用于兄弟组件之间的状态共享和协同工作。 应用场景：多个组件之间需要共享状态或数据。\n    \n4.  跨级组件通信：通过`provide/ inject`进行跨级数据传递。 特点：适用于祖先组件向后代组件传递数据。 应用场景：多级嵌套组件之间的状态共享和传递。\n    \n\n```\n\n// 子组件\n<template>\n  <div>\n    <h1>{{ title }}</h1>\n    <button @click=\"handleClick\">点击我</button>\n  </div>\n</template>\n<script>\nexport default {\n  props: [\'title\'],\n  methods: {\n    handleClick() {\n      this.$emit(\'change\', \'子组件按钮被点击了\')\n    }\n  }\n}\n</script>\n\n// 父组件\n<template>\n  <div>\n    <h2>{{ subtitle }}</h2>\n    <child :title=\"title\" @change=\"handleChange\"></child>\n  </div>\n</template>\n<script>\nimport Child from \'./Child.vue\'\nexport default {\n  components: { Child },\n  data() {\n    return {\n      title: \'父子组件通信示例\',\n      subtitle: \'\'\n    }\n  },\n  methods: {\n    handleChange(msg) {\n      this.subtitle = msg\n    }\n  }\n}\n</script>\n```\n\n## 5\\. Vue中的v-model指令在表单元素上的使用方式有哪些？请分别说明它们的区别和注意事项。\n\nv-model指令在表单元素上的使用方式：\n\n1.  v-model=\"value\"：用于单选框、复选框和选择框的数据绑定，绑定的是选择的值。 区别：单选框和复选框绑定的是选中状态，而选择框绑定的是选中的值。 注意事项：当多个单选框或复选框绑定同一个数据时，需要为每个元素添加不同的value属性。\n    \n2.  v-model=\"value\"：用于输入框等表单元素的双向数据绑定，绑定的是输入框的值。 区别：v-model与value属性的实现方式不同，v-model实现了双向绑定的效果。 注意事项：需要为输入框添加type属性，并且该元素必须支持input事件或change事件。\n    \n\n```\n\n// 单选框\n<template>\n  <div>\n    <input type=\"radio\" v-model=\"gender\" value=\"male\">男\n    <input type=\"radio\" v-model=\"gender\" value=\"female\">女\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      gender: \'\'\n    }\n  }\n}\n</script>\n\n// 输入框\n<template>\n  <div>\n    <input type=\"text\" v-model=\"message\">\n    <p>输入的内容是：{{ message }}</p>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      message: \'\'\n    }\n  }\n}\n</script>\n```\n\n## 6\\. Vue中的计算属性computed和侦听器watch有什么区别？请举例说明它们的使用场景。\n\ncomputed和watch的区别：\n\n1.  computed是基于依赖缓存的，只有当依赖的数据发生变化时才会重新计算；watch则是通过监听数据变化来触发回调函数。\n2.  computed适用于多个值之间的计算和处理，而watch则适用于单独的数据变化后执行异步或复杂的操作。\n\n```\n\n// 计算属性\n<template>\n  <div>\n    <p>商品数量：{{ quantity }}</p>\n    <p>商品总价：{{ totalPrice }}</p>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      price: 10,\n      quantity: 3\n    }\n  },\n  computed: {\n    totalPrice() {\n      return this.price * this.quantity\n    }\n  }\n}\n</script>\n\n// 侦听器\n<template>\n  <div>\n    <input type=\"text\" v-model=\"message\">\n    <p>输入的消息是：{{ message }}</p>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      message: \'\'\n    }\n  },\n  watch: {\n    message(newVal, oldVal) {\n      console.log(\'输入的消息发生了变化：\', newVal, oldVal)\n      // 执行异步操作\n      this.$http.get(\'/api/messages\', { params: { message: newVal } }).then(res => {\n        console.log(res.data)\n      })\n    }\n  }\n}\n</script>\n\n```\n\n## 7\\. 简述 Vue 中的异步更新队列原理。\n\nVue 在更新视图时会将所有数据变化的 watcher（观察者）加入到一个异步更新队列中，等到下一个事件循环时才执行更新操作。这样做的好处是避免频繁的更新视图，提高性能。\n\n1.  在 watcher 对象构造函数中，将当前 watcher 对象 push 到全局的异步更新队列 queue 中；\n2.  在下一个事件循环方式中，通过 flushQueue 函数逐个遍历 queue 数组中的 watcher，调用其 run 方法进行更新；\n3.  清空 queue 数组，以待下一次更新。\n\n```\n// 定义全局异步更新队列\nvar queue = [];\n\n// 异步更新队列处理函数\nfunction flushQueue() {\n  queue.forEach(function(watcher) {\n    watcher.run();\n  });\n  queue = [];\n}\n\n// 定义 Watcher 类\nclass Watcher {\n  constructor() {\n    queue.push(this); // 将当前 watcher 加入到异步更新队列中\n  }\n\n  run() {\n    console.log(\'更新视图！\'); // 执行更新操作\n  }\n}\n\n// 创建多个 Watcher 对象\nvar watcher1 = new Watcher();\nvar watcher2 = new Watcher();\n\n// 延迟一定时间，再执行异步更新操作\nsetTimeout(function() {\n  flushQueue(); // 清空异步更新队列，逐个执行更新\n}, 0);\n\n```\n\n## 8\\. 简述 Vue 中的事件机制原理，并手动实现一个简单的事件总线。\n\nVue 中的事件机制是利用事件总线 EventBus 进行封装实现的。事件总线将事件的发送和接收解耦，通过一个中心化的事件分发器（Event Bus）来管理，使得多个组件间的通信变得简单而灵活。\n\n```\n// 定义 EventBus 类\nclass EventBus {\n  constructor() {\n    this.events = {};\n  }\n\n  $on(name, callback) {\n    if (!this.events[name]) {\n      this.events[name] = [];\n    }\n    this.events[name].push(callback);\n  }\n\n  $emit(name, ...args) {\n    if (this.events[name]) {\n      this.events[name].forEach(function(callback) {\n        callback(...args);\n      });\n    }\n  }\n}\n\n// 创建 EventBus 实例\nvar bus = new EventBus();\n\n// 定义事件处理函数\nfunction handleMessage(message) {\n  console.log(`收到消息：${message}`);\n}\n\n// 绑定 message 事件处理函数\nbus.$on(\'message\', handleMessage);\n\n// 触发 message 事件，并传递参数\nbus.$emit(\'message\', \'Hello, World!\');\n\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d528a9f5403a4c3c9985c2ab7514c005~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)', 'public/uploads/1694354345672.png', 4, 4, 0, 645, '2023-09-10 14:00:38', 1);
INSERT INTO `article` VALUES (6, 5, 'iOS crash 报告分析系列 - 符号化', '### 前言\r\n\r\n何谓符号化？简单来说就是把看不懂的十六机制地址转换为看得懂的函数名的这一过程，即为符号化。\r\n\r\n当一个 app 发生 crash 时，操作系统会收集 app 发生崩溃时的各种诊断信息。其中对我们开发者最重要的一部分就是 thread backtraces，它会包含一系列的十六进制地址。开发者将其符号化之后，再根据相关的信息去定位崩溃的原因。\r\n\r\n### 如何判断当前报告是否符号化\r\n\r\n当你定位问题时，一份完整的符号化报告肯定是你最需要的，因为未符号化的报告都是十六进制地址，对我们来说是没有什么价值的。\r\n\r\n#### 完整符号化报告\r\n\r\n一份完整的符号化报告，backtrace 的每一帧都会包含函数名，而不是十六进制的内存地址。每一帧则代表某一个具体线程上单个函数调用。下面是一个完整符号化报告的例子：\r\n\r\ncss\r\n\r\n复制代码\r\n\r\n`6 CrashDemo 0x104a69e0c -[ViewController touchesBegan:withEvent:] + 152`\r\n\r\n具体每一行代表什么含义可以参见[这篇文章](https://juejin.cn/post/7238802590661476412 \"https://juejin.cn/post/7238802590661476412\")。\r\n\r\n#### 部分符号化报告\r\n\r\n完整的符号化报告，每一帧都会包含函数名字。而部分符号化报告则是某些帧会包含函数名字，而有些帧则是包含十六进制地址。即使部分符号化报告提供了定位问题的线索，我们也应该将其完全符号化，来确保得到完整的线索。下面是一个部分符号化报告的例子：\r\n\r\ncss\r\n\r\n复制代码\r\n\r\n`5 CoreFoundation  0x19157c158 0x1022c0000 + 49064 6 CrashDemo 0x104a69e0c -[ViewController touchesBegan:withEvent:] + 152`\r\n\r\n#### 未符号化报告\r\n\r\n未符号化报告的每一帧都只包含十六进制地址，它对我们定位问题是没啥帮助的。下面是一个完整符号化报告的例子：\r\n\r\n复制代码\r\n\r\n`5 CoreFoundation  0x19157c158 0x1022c0000 + 49064`\r\n\r\n### 符号化的两种方式\r\n\r\n#### 用 Xcode 符号化\r\n\r\n用 Xcode 符号化是官方推荐的一种方式，因为它会同时使用 Mac 上所有可用的 DSYM 文件来对报告进行符号化。\r\n\r\nTips：崩溃报告必须是 `.crash` 的文件后缀。如果文件没有后缀或者是别的后缀，比如 txt。必须将后缀改为 crash 再进行符号化。\r\n\r\n-   选择 Xcode 的 Window - Devices and Simulators window\r\n-   点击 Device Logs ![WeChat3a9e078ebd9eff6daeef55718eb1aba6.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c617d6353ba04d968a81e30d6e0d6368~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n-   将报告拖到空白处即可 ![WeChate14154604fe9022fa2c2e06abba21c65.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038a388cdf09467fa71e216bcca13d1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n如果执行完上面的操作，Xcode 并没有成功的将报告符号化，那你需要下面的步骤了：\r\n\r\n-   如果是系统库没有被符号化，则你需要去找跟崩溃报告中系统库版本匹配的设备。\r\n-   如果是自己的 app、app extension 或者 framework 未被符号化，你需要找到相应的 DSYM 文件。\r\n\r\n#### 用命令行符号化\r\n\r\n当你没有完整的报告，只有某些未符号化的帧时，可以使用命令行工具来对每一帧进行符号化。\r\n\r\n由 LLDB 提供的 `atos` 可以将十六进制的地址转为函数名和行号：\r\n\r\nxml\r\n\r\n复制代码\r\n\r\n`atos -arch <BinaryArchitecture> -o <PathToDSYMFile>/Contents/Resources/DWARF/<BinaryName> -l <LoadAddress> <AddressesToSymbolicate>`\r\n\r\nTips:dSYM 文件是 macOS 包，其中包含带有调试符号的文件。当调用 atos 时，必须在包内提供此文件的路径，而不仅仅是外部 dSYM 包的路径。\r\n\r\n下面是官网的示例图，标注了具体哪个参数对应哪个：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bfe929a02c443afa24e608f77bad4fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n根据上图，atos 的命令如下：\r\n\r\nbash\r\n\r\n复制代码\r\n\r\n`atos -arch arm64 -o TouchCanvas.app.dSYM/Contents/Resources/DWARF/TouchCanvas -l 0x1022c0000 0x00000001022df754`\r\n\r\n输出如下：\r\n\r\nscss\r\n\r\n复制代码\r\n\r\n`ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304`\r\n\r\n### 总结\r\n\r\n本文主要讲述了何为符号化、以及如何使用 Xcode 或 atos 进行报告符号化。希望本文会对大家进行线上崩溃问题定位时有帮助。', '', 4, 2, 0, 600, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (7, 2, '现代化 Android 开发：基础架构', '`Android` 开发经过 10 多年的发展，技术在不断更迭，软件复杂度也在不断提升。到目前为止，虽然核心需求越来越少，但是对开发速度的要求越来越高。高可用、流畅的 UI、完善的监控体系等都是现在的必备要求了。国内卷的方向又还包括了跨平台、动态化、模块化。\r\n\r\n目前的整体感觉就是，移动开发基本是奄奄一息了。不过也不用过于悲观：一是依旧有很多存量的 App 堪称屎山，是需要有维护人员的，就跟现在很多人去卷 `framework` 层一样，千万行代码中找 `bug`。 二是 `AI` 日益成熟，那么应用层的创新也会出现，在没有更简洁的设备出现前，手机还是主要载体，总归是需要移动开发去接入的，如果硬件层越来越好，模型直接跑在手机上也不是不可能，所以对跨平台技术也会是新一层的考验，有可能直接去跨平台化了。毕竟去中台化也成了历史的选择。\r\n\r\n因而，在这个存量市场，虽然竞争压力很大，但是如果技术过硬，还是能寻求一席之地的。因而我决定用几篇文章来介绍下，当前我认为的现代化 `Android` 开发是怎样的。其目录为：\r\n\r\n-   现代化 Android 开发：基础架构（本文）\r\n-   现代化 Android 开发：数据类\r\n-   现代化 Android 开发：逻辑层\r\n-   现代化 Android 开发：组件化与模块化的抉择\r\n-   现代化 Android 开发：多 Activity 多 Page 的 UI 架构\r\n-   现代化 Android 开发：Jetpack Compose 最佳实践\r\n-   现代化 Android 开发：性能监控\r\n\r\n# Scope\r\n\r\n提到 `Android` 基础架构，大家可能首先想到的是 `MVC`、`MVP`、`MVVM`、`MVI` 等分层架构。但针对现代化的 `Android` 开发，我们首要有的是 `scope` 的概念。其可以分两个方面：\r\n\r\n-   结构化并发之 `CoroutineScope`：目前协程基本已经是最推荐的并发工具了，`CoroutineScope` 的就是对并发任务的管理，例如 `viewModelScope` 启动的任务的生命周期就小于 `viewModel` 的存活周期。\r\n-   依赖注入之 `KoinScope`：虽然官方推荐的是 `hilt`，但其实它并没有 `koin` 好用与简洁，所以我还是推荐 `koin`。`KoinScope` 是对实例对象的管理，如果 `scope` 结束， 那么 `scope` 管理的所有实例都被销毁。\r\n\r\n一般应用总会有登录，所以大体的 `scope` 管理流程图是这样的：\r\n\r\n![scope](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcbca9003ab7405d813f6439c93dd157~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\r\n\r\n-   我们启动 `app`， 创建 `AppScope`，对于 `koin` 而言就是用于存放单例，对于协程来说就是全局任务\r\n-   当我们登录后，创建 `AuthSessionScope`, 对于 `koin` 而言，就是存放用户相关的单例，对于协程而言就是用户执行相关的任务。当退出登录时，销毁当前的 `AuthSessionScope`，那么其对应的对象实例、任务全部都会被销毁。用户再次登录，就再次重新创建 `AuthSessionScope`。目前很多 `App` 对于用户域内的实例，基本上还是用单例来实现，退出登录时，没得办法，就只能杀死整个进程再重启, 所以会有黑屏现象，实现不算优雅。而用 `scope` 管理后，就是一件很自然而实现的事情了。所以尽量用依赖注入，而不要用单例模式\r\n-   当我们进入界面后，一般都是从逻辑层获取数据进行渲染，所以依赖注入没多大用了。而协程的 `lifecycleScope`、`viewModelScope` 就比较有用，管理界面相关的异步任务。\r\n\r\n所以我们在做架构、做某些业务时，首要考虑 `scope` 的问题。我们可以把 `CoroutineScope` 也作为实例存放到 `KoinScope` 里，也可以把 `KoinScope` 作为 `Context` 存放到 `CorutineScope` 里。\r\n\r\n岐黄小筑是将 `CoroutineScope` 放到 `koin` 里去以便依赖查找\r\n\r\nkotlin\r\n\r\n复制代码\r\n\r\n`val sessionCoroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob() + coroutineLogExceptionHandler(TAG)) val sessionKoinScope = GlobalContext.get().createScope(...) sessionKoinScope.declare(sessionCoroutineScope)`\r\n\r\n> 其实我们也完全可以用 `CoroutineScope` 的 `Context` 来做实例管理，而移除 `koin` 的使用。但是 `Context` 的使用并没有那么便捷，或许以后它可以进化为完全取代 `koin`。\r\n\r\n# 架构分层\r\n\r\n随着软件复杂度的提升，`MVC`、`MVP`、`MVVM`、`MVI` 等先后被提出，但我觉得目前所有的开发，都大体遵循某一模式而又不完全遵循，很容易因为业务的节奏，很容易打破，变成怎么方便怎么来。所以使用简单的分层 + 足够优秀的组件化，才是保证开发模式不被打破的最佳实践。下图是岐黄小筑的整体架构图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cf2f99ac6f44bb19a72f27aa05f64dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\r\n\r\n整体架构不算复杂，其实重点是在于组件库，`emo` 已经有 20 个子库了，然后岐黄小筑有一些对于通用逻辑的抽象与封装，使得逻辑层虽然都集中在 `logic` 层，但整体都是写模板式的代码，可以面向 `copy-paste` 编程。\r\n\r\n以 `BookLogic` 为例：\r\n\r\nkotlin\r\n\r\n复制代码\r\n\r\n``// 通过依赖注入传参， 拿到 db 层、网络层、以及用户态信息的应用 class BookLogic(     val authSession: AuthSession,     val kv: EmoKV,     val db: AccountDataBase,     private val bookApi: BookApi ) {     // 并发请求复用管理     private val concurrencyShare = ConcurrencyShare(successResultKeepTime = 10 * 1000L)     // 加载书籍信息，使用封装好的通用请求组件     fun logicBookInfo(bookId: Int, mode: Int = 0) = logic(         scope = authSession.coroutineScope, // 使用用户 session 协程 scope，因为有请求复用，所以退出界面，再进入，会复用之前的网络请求         mode = mode,         dbAction = { // 从 db 读取本地数据             db.bookDao().bookInfo(bookId)         },         syncAction = { // 从网络同步数据             concurrencyShare.joinPreviousOrRun(\"syncBookInfo-$bookId\") {                 bookApi.bookInfo(bookId).syncThen { _, data ->                     db.runInTransaction {                         db.userDao().insert(data.author)                         db.bookDao().insert(data.info)                     }                     SyncRet.Full                 }             }         }     )     // 类似的模板代码     suspend fun logicBookClassicContent(bookId: Int, mode: Int = 0) = logic(...)     suspend fun logicBookExpoundContent(bookId: Int, mode: Int = 0) = logic(...)     ... } //将其注册到 `module` 中去，目前好像也可以通过注解的方式来做，不过我还没采用那种方式： scopedOf(::BookLogic)``\r\n\r\n`ViewModel` 层浮层从 `Logic` 层读取数据，并可以进行特殊化处理：\r\n\r\nkotlin\r\n\r\n复制代码\r\n\r\n`class BookInfoViewModel(navBackStackEntry: NavBackStackEntry) : ViewModel() {     val bookId = navBackStackEntry.arguments?.getInt(SchemeConst.ARG_BOOK_ID) ?: throw RuntimeException(\"book_id is required!.\")     val bookInfoFlow = MutableStateFlow(logicResultLoading<BookInfoPojo>())     init {         viewModelScope.launch {             runInBookLogic {                 logicBookInfo(bookId, mode).collectLatest {                     bookInfoFlow.emit(it)                 }             }         }     } }`\r\n\r\n`Compose` 界面再使用 `ViewModel`：\r\n\r\nkotlin\r\n\r\n复制代码\r\n\r\n`@ComposeScheme(     action = SchemeConst.ACTION_BOOK_INFO,     alternativeHosts = [BookActivity::class] ) @SchemeIntArg(name = SchemeConst.ARG_BOOK_ID) @Composable fun BookInfoPage(navBackStackEntry: NavBackStackEntry) {     LogicPage(navBackStackEntry = navBackStackEntry) {         val infoVm = schemeActivityViewModel<BookInfoViewModel>(navBackStackEntry)         val detailVm = schemeViewModel<BookDetailViewModel>(navBackStackEntry)         val bookInfo by infoVm.bookInfoFlow.collectAsStateWithLifecycle()         //...     } }`\r\n\r\n这样整个数据流从网络加载、到存储到数据库、到传递给 `UI` 进行渲染的整个流程就结束了。\r\n\r\n对于其中更多的细节，例如逻辑层具体是怎么封装的？`UI` 层具体是怎么使用多 `Activity` 多 `Page`？可以期待下之后的文章。', '', 3, 3, 0, 653, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (8, 3, 'Vue Hooks: 让Vue开发更简单与高效', '## 前言\n\nHooks是React等函数式编程框架中非常受欢迎的工具，随着VUE3 Composition API 函数式编程风格的推出，现在也受到越来越多VUE3开发者的青睐，它让开发者的代码具有更高的复用度且更加清晰、易于维护。\n\n本文将快速略过并了解Hooks的使用基础以及自定义HOOK开发相关的要点，快速入门。\n\n本文含有参考自官方文档、他人文章的内容，侵删。\n\n## Hooks简介\n\n**1\\. 什么是Hooks**\n\nHooks并不是VUE特有的概念，实际上它原本被用于指代一些特定时间点会触发的勾子。而在React16之后，它被赋予了新的意义：\n\n> 一系列以 `use` 作为开头的方法，它们提供了让你可以完全避开 `class式写法`，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力\n> \n> `Hooks最核心的价值来自于内部的状态管理`\n\n在VUE3中，`Hooks`的概念结合了VUE的响应式系统，被称为`组合函数`。组合函数是VUE3组合式API中提供的新的逻辑复用的方案，是一类利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数\n\n简单来说，它就是一个`创建工具的工具`\n\n**2\\. Hooks与composition Api**\n\nHooks是一种`基于闭包`的函数式编程思维产物，所以通常我们会在`函数式风格`的框架或组件中使用Hook，比如VUE的组合式API(Composition Api)。Hooks在VUE2所使用的`选项式风格API`中也不是不可以使用，毕竟Hook本质只是一个函数，只要hook内部所使用的api能够得到支持，我们可以在任何地方使用它们，只是可能需要额外的支持以及效果没有函数式组件中那么好，因为仍会被选项分割。\n\nVUE3推出时为开发者带来了全新的Composition API即组合式API。它是一种通过函数来描述组件逻辑的开发模式。组合式API为开发者带来了更好的逻辑复用能力，通过`组合函数`来实现更加简洁高效的逻辑复用。\n\n```\n<script setup>\nimport { ref, onMounted } from \'vue\'\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n## 为什么要使用Hook\n\n**1\\. Mixin/Class的局限性**\n\n在以往VUE2的选项式API中，主要通过Mixin或是Class继承来实现逻辑复用，但这种方式有三个明显的`短板`：\n\n-   **不清晰的数据来源**：当使用了多个mixin/class时，哪个数据是哪个模块提供的将变得难以追寻，这将提高维护难度\n    \n-   **命名空间冲突**：来自多个class/mixin的开发者可能会注册同样的属性名，造成冲突\n    \n-   **隐性的跨模块交流**：不同的mixin/class之间可能存在某种相互作用，产生未知的后果\n    \n\n以上三种主要的缺点导致在大型项目的开发中，多mixin/class的组合将导致逻辑的混乱以及维护难度的提升，因而在VUE3的官方文档中不再继续推荐使用，保留mixin也只是为了迁移的需求或方便VUE2用户熟悉。\n\n**2\\. Hooks的优势**\n\n其实Mixin/Class的缺点反过来就是Hooks的优点：\n\n-   清晰一目了然的源头：Hooks不是一个类，没有将状态、方法存放在对象中，然后通过导出对象的形式实现复用，也就不会有对象间过度`耦合`、`干扰`等问题。Hooks中的各类状态是封装在内部的，与外界隔离，仅暴露部分函数、变量，这使得其来源、功能`清晰可辨`且`不易被干扰`\n    \n-   没有命名冲突的问题：Hooks本质是闭包函数，内部所导出的变量、方法支持重命名，因而同一个Hook在同一个组件中可以N次使用而不冲突\n    \n-   精简逻辑：一个Hook开发完成后，在使用Hook时不需要关心其内部逻辑，只需知道有什么效果、如何使用即可，专注于其他核心业务逻辑，可以节省大量重复代码\n    \n\n```\n<script lang=\"ts\" setup>\nimport { useAutoRequest } from \'/@/utils/hooks\'\nimport m from \'/@/utils/message\'\n\n// 使用Hook\nconst [loadingWithHook, newApiWithHook] = useAutoRequest(testApi, {\n  onSuccess: xxxData => {\n    xxxData // 做些什么\n  },\n  onCatch: err => {\n    err // 做些什么\n  },\n  message: \'调用成功\',\n})\n\nnewApiWithHook()\n\n// 不使用Hook\nconst loading = ref(false)\nconst fetchData = async () => {\n  try {\n    loading.value = true\n    const xxxData = await testApi()\n    xxxData //做些什么\n    m.success(\'调用成功\')\n  } catch (err) {\n    err // 做些什么\n  } finally {\n    loading.value = false\n  }\n}\n\nfetchData()\n\n// 模拟接口\n\ninterface Response {\n  name: string\n  age: number\n}\n\nfunction testApi(): Promise<Response> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const result = { name: \'test\', age: 18 }\n\n      resolve(result)\n    }, 1000)\n  })\n}\n</script>\n```\n\n可以看到在不使用Hook时，实现一个loading功能需要创建一个变量并手动控制它，而且需要使用try catch或者promise链式调用处理原来的接口的各种情况，这将产生大量的重复代码且可能因粗心而产生不必要的BUG\n\n而在使用了Hook的情况下，loading状态以及接口的状态区分已经在内部处理好，仅需添加对应的参数即可，规范了写法、节省代码量、便捷且不易出错\n\n**3\\. 组合式API的优点**\n\n组合式API有一个很重要的优点，在组合式API中可以实现`更灵活的代码组织`： ![b3680785b61c4af8befdbe2b9ca18c90~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b54e14a895874668b463d20df0c11440~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 在选项式API中，人为地将代码分为了多个模块，非常有益于开发者上手，但是在模块复杂、代码量多的情况下将带来一些问题：\n\n`模块复杂`的情况下，查阅相同逻辑的内容时，需要`反复翻阅`组件的内容，对于开发者特别是非原本组件开发者而言，这会极大地`加重负担`，而如果使用组合式API，因为整个组件都是基于响应式变量以及函数，我们可以把处理相同业务逻辑的内容放在同一个区域，这样可以方便阅读理解，并且在抽离、复用时提供了很大的便利，在大型项目维护中非常重要。\n\n以下是使用组合式API组织代码的示例：\n\n```\n<script lang=\"ts\" setup>\nimport { getAllForSelect, type UserInfo } from \'/@/api\'\nimport { useAutoRequest } from \'/@/utils/hooks\'\n\ninterface Option {\n  label: string\n  value: string | number\n}\n\nconst emit = defineEmits([\'update:modelValue\'，\'focus\', \'clear\', \'blur\', \'change\'])\n\nconst props = defineProps({...})\nconst { modelValue } = toRefs(props)\n\nconst selectedValue = ref<string | number>(\'\')\n\nwatch(modelValue, val => (selectedValue.value = val), { immediate: true })\n\nconst options = ref<Array<Option>>([])\n\n// 使用Hook创建自动loading的请求接口\nconst [loading, getOptions] = useAutoRequest(getAllForSelect, {\n    onSuccess: res => options.value = res.map(...)\n})\n\nonBeforeMount(getOptions)\n\nconst onChange = (v: number | string) => (emit(\'update:modelValue\', v), emit(\'change\', v))\nconst onFocus = () => emit(\'focus\')\nconst onBlur = () => emit(\'blur\')\nconst onClear = () => emit(\'clear\')\n\nconst selectRef = ref<any>(null)\n\nconst blur = () => selectRef.value.blur()\nconst focus = () => selectRef.value.focus()\n\ndefineExpose({ blur, focus })\n</script>\n```\n\n使用选项式API写同样功能的代码则需要将各个变量、函数置于不同的模块中，在模块复杂时，将增加维护难度\n\n## 怎么开始玩Hooks\n\n**1\\. Hooks的各类规范**\n\n在开始使用/创建Hook之前，我们需要明白它的一些`规范`，以下是创建/使用hook时的一些要求：\n\n1.  通常来讲，一个Hook的命名需要以use开头，比如useTimeOut，这是约定俗成的，开发者看到useXXX即可明白这是一个Hook。Hook的名称需要清楚地表明其功能。\n    \n2.  ~只在组件生命周期中调用Hook，而不在普通函数中调用Hook~ (React中规定，但在Hook概念扩大化后，其实并非绝对)\n    \n3.  只在当前关注的最顶级作用域使用Hook，而不要在嵌套函数、循环中调用Hook\n    \n\n补充：\n\n-   函数必须是纯函数，没有副作用\n    \n-   返回值是一个函数或数据，供外部使用\n    \n-   Hook内部可以使用其他的Hook，组合功能\n    \n-   数据必须依赖于输入，不依赖于外部状态，保持数据流的明确性\n    \n-   在Hook内部处理错误，不要把错误抛出到外部，否则会增加hook的使用成本\n    \n-   Hook是单一功能的，不要给一个Hook设计过多功能。单个Hook只负责做一件事，复杂的功能可以使用多个Hook互相组合实现，如果给单个Hook增加过多功能，又会陷入过于臃肿、使用成本高、难维护的问题中\n    \n\n规范化使用Hook可以使得除了开发者本人之外的其他协作者也可以快速上手他人代码。\n\n> Hooks虽然有很多规定，但它们并不是铁律，在充分理解了Hook的工作原理，特殊情况下可以打破部分规范，前提是清楚这么做不会有意料之外的后果，但大部分情况下还是遵守规范比较好\n\n**2\\. 如何使用Hooks**\n\n在VUE中，使用Hooks时，需要使用组合式API，因而最好在VUE3中使用，VUE2想要使用组合式API则需要配合`@vue/composition-api`，并且版本需要`高于VUE2.6`。\n\nHooks的使用十分简单，这也是它们被设计的意义所在，只需引入并调用函数即可。\n\n```\n<script lang=\"ts\" setup>\nimport { useScroll } from \'@vueuse/core\'\n\nconst el = ref<HTMLElement | null>(null)\nconst { x, y, isScrolling, arrivedState, directions } = useScroll(el)\n</script>\n\n<template>\n  <div ref=\"el\"></div>\n</template>\n```\n\nVUE社区有很多优秀的Hooks库，比如VueUse，它是由部分VUE核心成员开发的VUE Hook库，提供了很多非常好用的hook，查看、学习它的源码也非常有助于开发自己的hook\n\n**3\\. 如何创建自己的自定义Hook**\n\n在设计一个定制的Hook之前，应当至少明白以下几点：\n\n-   明确自己想要的功能以及实现的效果\n-   遵守Hook的命名规范以及其他注意事项\n-   尽可能好的性能表现以及精简的代码\n-   使用TypeScript\n\n我们在开发自己的Hook时应该明确它的设计目的，遵守各项规范，最好使用TypeScript，特别是复杂的Hook\n\n> 当一个Hook内部较为复杂，配置项较多时，为了避免被错误使用，也为了尽早地发现可能的BUG，使用TypeScript的类型检查是非常有必要的，甚至为了更好的使用体验，应该结合TS类型计算，约束输入以及做到对输出内容的更好的类型提示\n\n以下是一个简单的分页模块Hook示例：\n\n```\ninterface UsePaginationResponse {\n  currentPage: Ref<number>\n  pageSize: Ref<number>\n  totalCount: Ref<number>\n  skipCount: Ref<number>\n  reset: () => void\n}\n\nexport function usePagination(defaultPageSize?: number): UsePaginationResponse {\n  const pageSize = ref(defaultPageSize ?? 20)\n  const currentPage = ref(1)\n  const totalCount = ref(0)\n  const skipCount = computed(() => (currentPage.value - 1) * pageSize.value)\n\n  return { currentPage, pageSize, totalCount, skipCount, reset }\n\n  function reset() {\n    currentPage.value = 1\n    totalCount.value = 0\n  }\n  // 根据实际需求增加更多功能，比如自动管理接口数据等\n}\n\n// 使用\nconst { currentPage, pageSize, totalCount, skipCount, reset } = usePagination()\n```\n\n这样就可以创建一个简单的分页功能hook，只需在需要分页的VUE组件中引入调用usePagination，就可以轻松创建分页模块，高效且清晰。\n\n创建复杂Hook时，需要尽可能地对各种情况做好预先的处理，以保证它代码的健壮性\n\n`Hooks在一定程度上可以取代传统的VUE组件`\n\n**4\\. 使用TypeScript类型计算的Hook**\n\n以下是一个自动创建携带Loading状态的接口的Hook：\n\n```\nimport m from \'/@/utils/message\'\n\ntype TApiFun<TData, TParams extends Array<any>> = (...params: TParams) => Promise<TData>\ntype AutoRequestResult<TData, TParams extends Array<any>> = [Ref<boolean>, TApiFun<TData, TParams>]\ninterface AutoRequestOptions<T> {\n  /**\n   * @description 默认的loading状态\n   *\n   * @default false\n   */\n  loading?: boolean\n  /**\n   * @description 成功时是否自动提示\n   */\n  message?: string\n  /**\n   * @description 接口调用成功时的回调\n   */\n  onSuccess?: (data: T) => unknown | Promise<unknown>\n  /**\n   * @description 接口调用失败时的回调\n   */\n  onCatch?: (err: Error) => unknown | Promise<unknown>\n}\n\n/**\n * @description loading状态hooks\n * @param fun 接口方法\n * @param options 配置选项:设置默认loading状态、接口回调与自动提示开关\n * @returns [loading，接口]\n */\nexport default function useAutoRequest<TData, TParams extends any[] = any[]>(\n  fun: TApiFun<TData, TParams>,\n  options?: AutoRequestOptions<TData>,\n): AutoRequestResult<TData, TParams> {\n  const { loading = false, onSuccess, onCatch, message } = options ?? { loading: false }\n\n  const requestLoading = ref(loading)\n\n  const run: TApiFun<TData, TParams> = (...params) => {\n    requestLoading.value = true\n\n    return fun(...params)\n      .then(async res => {\n        onSuccess && (await onSuccess(res))\n        message && m.success(message)\n        return res\n      })\n      .catch(async err => {\n        onCatch && (await onCatch(err))\n        throw new Error(err)\n      })\n      .finally(() => {\n        requestLoading.value = false\n      })\n  }\n\n  return [requestLoading, run]\n}\n\n// 使用\nconst [loading,apiWithLoading] = useAutoRequest(originApi, { message:\'success\' })\n```\n\n这是一个自动创建loading状态的Hook，在使用时只需传入原始接口以及一些配置项即可快捷创建自动loading状态，节省了大量重复的loading控制代码，使用该Hook后只需调用apiWithLoading即可实现loading变量的自动控制，且继承原接口的类型\n\n如果不使用TS进行处理，那么新创建的apiWithLoading在使用时将会丢失类型，无法提供像原本接口originApi一样的类型支持，使得出错的风险增加，而经过处理后的useAutoRequest可以在外部使用时自动推断apiWithLoading的类型，也可以在填入onSuccess时提供更好的类型支持：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98c1bb95c1f24f3681da26c330515553~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**5\\. Hooks与普通工具函数的区别**\n\n简单来讲，Hooks是`创建工具的工具`而普通工具函数则是纯粹的`工具`。实际上根据开发者的喜好，一个普通的工具函数也可以被创建成Hooks的形式，但并不是很有必要，因为作为工具本身它已经很好用了，一定要包装成Hook反而多饶了一层，而且可能没有利用到Hook的优势\n\n什么情况下适合创建为Hooks呢？\n\n-   具有一定泛用性的功能\n-   具有一定复杂度，需要外部提供初始条件，由模块内部进行状态管理的功能\n-   若干相关的、共享状态的业务功能\n-   等等\n\n`当需要内部状态管理时，才需要创建Hook`\n\n## 总结\n\nHooks是VUE3中利用组合式API响应式的特性的，实现简单高效的逻辑复用、提高开发效率、提高VUE模块可维护性的工具。Hooks的组合可以让组件低代价、高效率地实现高复杂度业务，Hooks之间通常相互独立，没有过度耦合，降低后期陷入`维护地狱`的风险，而且可以使得功能模块更加`易于测试`\n\n使用开源的Hook将为开发带来很多方便，而开发自定义Hook则需要花费一些时间，但在实现后，高度的定制化将为项目开发带来巨大的便利\n\nHooks的出现不意味着抛弃Class，Hooks也有自己的缺点比如内存泄漏和可能的性能问题。Class更加易于上手，在经验丰富、技术深厚的开发者手中也可以一定程度上避开Class的缺点\n\n## 建议\n\n**1\\. 插件**\n\n-   项目中可以加入类似unplugin-auto-import的插件，配置后可以实现自动引入VUE函数、类型或一些指定的内容，可以节省反复引入VUE API的时间\n    \n-   Type Challenges插件，提供很多不同难度的类型体操题目，可以提升对TS类型运算的理解\n    \n\n**2\\. TypeScript**\n\n-   TS严格模式：使用TS时，要开启tsconfig中的严格模式，如果关闭严格模式，类型检查的效果将大打折扣\n    \n-   避免AnyScript：使用TS时要进行严格的类型声明，避免过多的any，因为使用any将失去类型检查，如果实在难以描述类型，则可以考虑使用unknow。TS项目中如果存在很多的any，不如抛弃TypeScript\n    \n-   不要保留报错：各类报错通常是用来处理`边界情况`的，这正是此类报错存在的意义，需要重视并解决。有时候开发者会比TS更清楚数据的类型，此时一些不必要的类型报错可以通过`类型断言`解决。重视并解决所有报错可以为代码提供更好的`健壮性`\n    \n\n**3\\. 代码建议**\n\n-   规范、明确的命名： 在命名变量或函数时，名称应该尽可能的明确它的作用/功能，不要使用缩写特别是拼音缩写，这将导致代码可读性严重下降，复杂变量/方法使用注释进行注解\n    \n-   积极使用新的ES语法：包括可选链操作符(?.)、解构、剩余参数语法、空值合并运算符(??)等，合理地使用它们将有效地提高代码可读性\n    \n-   合理的代码组织：单个函数中，一些相关的函数内容写在一起可以有效的规范代码结构，在某个代码块比较复杂时，还可以提取为一个函数置于函数后部，前半部分仅`保留核心逻辑`，可以有效提升代码可读性。在VUE组件中也是类似的逻辑\n    \n-   语义化代码：在编写代码时，调用各类JSAPI时，应该注重`语义化`，比如要对数组进行某种批处理，就使用Array.map而不是使用Array.forEach或其他循环方式然后配合外部创建的另一个空数组进行处理。要实现什么效果就使用什么API，这样既可以让代码精简，也可以增强可读性，让代码`自己描述自己`，这是`增强代码可读性的关键`\n    \n-   基础功能使用工具类：在进行一些基础判断等操作时，尽量使用一些封装好的工具类，这样可以`避免`判断时的`疏漏`而产生错误；使用某功能时也先查询是否已有相关工具，同一类功能使用同一个封装好的工具将更`方便管理`，但要注意的是此类工具`不能过于复杂`，否则大范围应用后将会导致`难以维护`、牵一发而动全身\n    \n\n简单示例：\n\n```\nclass Info {\n  name: string = \"\";\n  age: number = 0;\n}\ninterface TestInfo extends Info {\n  other: any;\n}\n\nconst formState = ref<Info>({ name: \"\", age: 0 }); // new Info()\n\nconst updateFormState = (data?: TestInfo): void => {\n  clear();\n\n  const { other = \"empty\", ...stateInfo } = data ?? {};\n\n  formState.value = isNull(stateInfo) ? <Info>stateInfo : new Info();\n  other; // 使用other\n};\n\nconst clear = () => {};\n\n/////////////////////////////////////\n/**\n * @description 判断对象，数组，字符串，数字是否为空，例如:  NaN , undefined , null , \'\' , \'   \' , {}  , [] 全部判断为空\n */\nexport function isNull(value: any): boolean {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  if (typeof value === \"string\" && value.trim() === \"\") {\n    return true;\n  }\n  if (Array.isArray(value) && value.length === 0) {\n    return true;\n  }\n  if (value.constructor === Object && Reflect.ownKeys(value).length === 0) {\n    return true;\n  }\n  if (typeof value === \"number\" && isNaN(value)) {\n    return true;\n  }\n  return false;\n}\n\n```\n\n## 参考文章/拓展阅读\n\n-   [组合式 API 常见问答](https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fguide%2Fextras%2Fcomposition-api-faq.html \"https://cn.vuejs.org/guide/extras/composition-api-faq.html\")\n-   [浅谈：为啥vue和react都选择了Hooks](https://juejin.cn/post/7066951709678895141 \"https://juejin.cn/post/7066951709678895141\")\n-   [写hook三天，治好了我的组件封装强迫症](https://juejin.cn/post/7181712900094951483 \"https://juejin.cn/post/7181712900094951483\")\n-   [一文读懂 TypeScript 泛型及应用](https://juejin.cn/post/6844904184894980104 \"https://juejin.cn/post/6844904184894980104\")\n-   [为什么你需要TypeScript](https://juejin.cn/post/7248599585751515173 \"https://juejin.cn/post/7248599585751515173\")\n-   [TypeScript基础教程](https://link.juejin.cn/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1wR4y1377K \"https://www.bilibili.com/video/BV1wR4y1377K\")', 'public/uploads/1694314248508.png', 2, 4, 0, 719, '2023-09-10 02:50:49', 1);
INSERT INTO `article` VALUES (9, 6, '我觉得 antd 模态框不好用，所以选择了二开', '![WechatIMG456.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6274e6924134893971b0d61e59a8156~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 写在前面\n\n写文章水平有限，已经快一年没写过了，越不写越不会写，索性尝试写一些和大家分享讨论一下\n\n2022 年我从 Vue 切换到 React 开发，在这过去的一年多时间，我待过 2 个团队，毫无意外的都是 React + Ant Design。我相信这是国内绝大多数团队都有使用过的 UI 框架。当然国外的 MUI 也很棒。\n\n### modal 有哪些痛点\n\n1.  在没有统一使用 Provider 管理 Modal 的情况下， 我以及我的同事使用最多的方法就是在组件中导入antd Modal，然后使用 React.useState 定义一个 state 传递给 modal 的 ~visible~ open 属性。以受控的形式管理弹窗的显隐。并且还需要在 `onCancel` 和 `onOk` 回调中修改 state 来关闭弹窗。\n    \n2.  通常打开一个弹窗都伴随着用户点击操作，开发者需要手动对触发器添加 onClick 事件。\n    \n3.  antd Modal 提供了 `footer` 属性，假设我们的业务代码比较复杂，一股脑塞入 Modal children 会很臃肿，开发者不得不将其抽离出来。但是 footer 又和业务分离，不够内聚。导致我们需要将控制弹窗的开关透传下去。\n    \n4.  接第 3 点，antd Modal 提供了 `destroyOnClose` 属性，表示关闭时销毁子元素。这里经常遇到一个问题是，即使我加了这个属性，但是封装的组件包含的 state，然后直接在 children 里直接消费，这个属性的作用就不大了。\n    \n5.  antd 提供的输入组件都提供了受控和非受控能力，但是 Modal 的显隐却没有非受控设计。以至于开发者想 mount 组件时默认打开弹窗。这样的操作需要开发者二次封装或者设计。\n    \n6.  拖拽弹窗，一般情况下 Modal 打开都是固定位置，但是有时候输入时遮挡了用户观察，虽然我们可以使用 Drawer 代替，但有时候我们还是希望有一个可拖动的 Modal，尽管 antd 提供了可拖拽 Demo，但是我阅读起来还是有些难理解。（这条可能是一个 feature。不属于痛点。\n    \n\n### 怎么解决呢\n\n1.  第一种方式是去 antd 官方 仓库创建一个 RFC 进行讨论，如果被采纳则可以发起一个 PR。\n    \n2.  第二种方式就是二次开发， 所以有了这篇文章。\n    \n\n### easy-antd-modal\n\n它来了，我又重复造轮子了， github 仓库地址：[github.com/Wxh16144/ea…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FWxh16144%2Feasy-antd-modal \"https://github.com/Wxh16144/easy-antd-modal\")\n\n**使用方式**\n\n```\nimport { Button } from \'antd\';\nimport Modal from \'easy-antd-modal\';\n\nexport default () => (\n  <Modal \n    title=\"easy-antd-modal\"\n    trigger={<Button type=\"primary\">Click Me</Button>}\n  >\n    I ❤️ antd\n  </Modal>\n);\n```\n\n#### hook\n\n为了解决上诉痛点 1，2，3，4，5 我封装了 [useModalEnhanced](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FWxh16144%2Feasy-antd-modal%2Fblob%2Fmaster%2Fsrc%2Fhooks%2FuseModalEnhanced.ts \"https://github.com/Wxh16144/easy-antd-modal/blob/master/src/hooks/useModalEnhanced.ts\") hook 对弹窗的 props 进行了 HOC\n\n这个 hook 不仅仅可以对 Modal 进行增强，还可以对 antd Drawer 封装同样的能力，以及 antd mobile 的 Mask, Modal, Popup, Dialog 组件都适用。我都进行了二次开发。\n\n#### components\n\n至于可拖动的弹窗，我依赖了 @dnd-kit/core 库实现了可拖拽功能组件 [DragModal](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FWxh16144%2Feasy-antd-modal%2Fblob%2Fmaster%2Fsrc%2Fdrag-modal%2Findex.tsx \"https://github.com/Wxh16144/easy-antd-modal/blob/master/src/drag-modal/index.tsx\")\n\n社区好多组件都有一个 Provider 😅，我也不例外，也加入了 [EasyAntdModalProvider](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FWxh16144%2Feasy-antd-modal%2Fblob%2Fmaster%2Fsrc%2Fcontext%2Findex.tsx \"https://github.com/Wxh16144/easy-antd-modal/blob/master/src/context/index.tsx\") 组件。可以根据开发者喜好进行自定义 props 约定。\n\n### feature\n\n1.  所有 antd 支持的 props 都进行了透传，所以它支持 antd4 和 antd5\n2.  对 trigger 自动绑定 onClick 事件，open state 由内部维护。\n3.  content(children) 增强，支持调用 close 关闭弹窗。\n4.  保留以上功能的情况下支持拖拽，类似 Windows 弹窗。\n5.  同样的能力可以应用在 antd-mobile 组件上。\n6.  长期维护，有足够的单元测试支撑。欢迎 PR。\n\n具体文档/示例可以移步：[wxh16144.github.io/easy-antd-m…](https://link.juejin.cn/?target=https%3A%2F%2Fwxh16144.github.io%2Feasy-antd-modal%2F \"https://wxh16144.github.io/easy-antd-modal/\")\n\n### 最后\n\n欢迎大家进行讨论，分享大家在开发过程中遇到的问题以及对 antd 的吐槽。万一哪天被就被 antd 团队采纳了呢。\n\n也希望大家可以尝试并讨论我二开的组件，`npm install easy-antd-modal`。', 'public/uploads/1694336165679.png', 2, 4, 3, 71, '2023-09-10 08:56:07', 1);
INSERT INTO `article` VALUES (10, 4, '用 Compose 写 App 可以多快？', '> 这篇文章写于 2023 年 3 月初，原因是审核上线流程走了接近两个月，嘿嘿~\n\n休整半年多的我，在今年年后就在思考与尝试我的事业应该怎么走了。其实在去年年终总结中，我已经提及了我的几个方向。\n\n我最开始的方向就是迈入养生行业，虽然我有技术，也有医术，但是没客户，所以我大概需要很长的时间去累积客户，加上现在客户都迷恋让肌肉放松的推拿按摩，以及房租设备之类的开销。还不如找个小公司安心上班来得舒服。可是我又耐不住想折腾的心。\n\n所以我开启了 `PlanB`，去走中医知识学习领域，虽然现在市面上有一些这类的 `app`，不过他们都不是真正有中医知识的人主导的，只能说是一堆资源的简单聚合，或者为了卖课而存在。而根本不知道学习中医的痛点是什么，怎样才能真正的提升医术，这就是我的市场了。所以我从零做了一个 `app`，目前完成了首个版本了。这是真的做一个 `app` 满足自己的需求。虽然目前功能、数据还很少，但我认为它是有价值的，虽然可能没有钱途。\n\n![aa1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67fee075743d4c7aae7496dd6085667c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n`App` 已经在官网[villa.qhplus.cn](https://link.juejin.cn/?target=https%3A%2F%2Fvilla.qhplus.cn \"https://villa.qhplus.cn\")、华为、小米、应用宝、Oppo 的应用市场上架了， 但对于开发而言，并不会懂这个 `App` 的内容以及结构，毕竟不是为你们而设计的，但是你们可以体验下 `Compose` 已然是多么的丝滑了。因为这个 `app` 是全部用 `Compose` 开发。从立项开始到现在，仅用一个半月左右的时间完成开发，是时候让你们感受下 `Compose` 开发的速度了。先欣赏下设计稿的数量（辛苦我美丽动人的老婆大人了）。\n\n![aa2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0658c6d35794d95aed61b6b82ee2bfc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n并且我做的是全栈式的开发，其包括：\n\n1.  思考产品形态\n2.  用 `rust` 写后端服务\n3.  数据爬取、清洗与整理入库\n4.  用 `vue3` 写官网、隐私协议等 H5 界面\n5.  为了上架、登录、push 等要开一个壳公司，跑各种流程（最繁琐、最耗时的工作）\n\n即使是 `app` 端，也要有各种数据逻辑、上报、存储等逻辑，可想而知，能分配给写 `UI` 的时间能有多少？\n\n当然，这也归功于在去年修整期间我写的 `emo` 组件库，极大的加速了业务层的开发。\n\n问：为什么不考虑小程序开发，`Flutter` 开发，`RN` 开发？\n\n答：小程序挺好的，但是它却很封闭，我想要实现桌面小组件之类的功能，小程序就完全做到，但对于中医条文，用小组件来让我们每天回忆一条条文，是个我个人很喜欢的功能。\n\n而 `RN` 的性能太差，而且用它，就要牺牲诸如动画、复杂布局等各种场景。并且往往这些需要与原生交互的场景，就要用力十倍才能解决。\n\n不用 `Flutter`，首先当然是因为我不会，其次是它和 `RN` 都是 `UI` 层面，如果和数据层一起考虑，那就没那么简单了。 而我用 `Compose`，与整个 `Android` 生态都是打通的，所以性能又高，开发速度又快。何乐而不为？跨平台？各自写就行了，不再去入整体跨平台的坑了。跨平台的坑不仅是技术抽象应对各自生态不是那么稳定的坑，还有人力资源协调的坑。总会让人心累。\n\n下面我们可以来看看 `Compose` 和 `emo` 协同开发带来的一些爽点：\n\n## 界面管理\n\n用 `Compose` 加 `scheme` 路由的方式来处理界面跳转、曝光，就非常简单了, 每一个新界面就是一个 `Composable`，加上 `@ComposeScheme` 就完了\n\n```\n@ComposeScheme(\n    action = SchemeConst.ACTION_THINK_DETAIL,\n    alternativeHosts = [HolderActivity::class]\n)\n@SchemeLongArg(name = SchemeConst.ARG_ID)\n@SchemeLongArg(name = SchemeConst.ARG_COMMENT_ID)\n@Composable\nfun ThinkDetailPage(navBackStackEntry: NavBackStackEntry) {\n    LogicPage(navBackStackEntry = navBackStackEntry) {\n       // content\n    }\n}\n\n@Composable\nfun LogicPage(\n    navBackStackEntry: NavBackStackEntry,\n    saveToLatest: Boolean = false, \n    content: @Composable () -> Unit\n) {\n    content()\n    LaunchedEffect(navBackStackEntry) {\n        val scheme = navBackStackEntry.arguments?.getString(SchemeKeys.KEY_ORIGIN)?.let { Uri.decode(it) }\n        if (scheme != null) {\n            // 上报 scheme，作为曝光\n            // 保存 scheme，如果用户退出了，直接重入这个界面。 \n            // 这个在调试中很好用。例如某个界面，需要点5层才能进去，每次编译重启就要点5次才能看到这个界面，那就蛋疼了，所以如果每次把它记录起来，启动就进去，那开发就顺很多了\n        }\n    }\n}\n```\n\n## 界面状态\n\n很多界面基本上就是列表，然后就有空界面、错误提示情况，列表，列表可能还有加载更多。在原来 `View` 体系，就要做各种 `View` 的显示隐藏操作，写起来贼麻烦。 用 `Compose` 封装起来就简单了。 看我的封装结果\n\n```\nval logic by vm.thinkFlow.collectAsStateWithLifecycle()\nLogicBox(\n    modifier = Modifier\n        .fillMaxWidth()\n        .weight(1f),\n    logic = { logic },\n    reload = {\n        vm.reload()\n    },\n    emptyText = \"空\"\n) { list ->\n    // 列表数据\n}\n```\n\n把它往 `LogicPage` 里面套就完事了，当然这也是数据逻辑层我抽象了强大的 `logic` 逻辑。借助这个逻辑，可以分分钟完成数据的从网络数据拉取，再到读存 `DB`，再到界面的渲染，可以快速补充完成空界面、加载出错、加载更多、下拉刷新等功能。\n\n## 多级评论\n\n![aa3.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee5a6313c5da41279d2dd2379eb8de9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n看我这个思辨详情页面，假设以旧的 `RecyclerView` 体系来做这个，想想都痛苦。而我是数据逻辑层加`UI`一起两三个小时搞定, 毫无 `bug`。\n\n另外这里还有一个“从通知点击进来滚动到当前评论”的场景，如果是原生或者 `RN` 来做，最痛苦的事情就是滚动时机了，一般最终会使用 `post` 万能大法大法，然而总有没滚动的情况发生，然后产品就找过来了。\n\n而 `Compose` 也就是一小段代码的事了：\n\n```\nif (vm.targetCommentId > 0) {\n    val targetCommentIndex = remember(vo) {\n        indexOfTargetCommentId(vo, vm.targetCommentId)\n    }\n    if (targetCommentIndex > 0) {\n        LaunchedEffect(Unit) {\n            vm.listState.scrollToItem(targetCommentIndex, 0)\n        }\n    }\n}\n```\n\n## 嵌套滚动\n\n看看这个一般的嵌套滚动界面\n\n![aa4.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f879d275c3cd451e9346aa6bea4bb454~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n即使有 `NestedScroll` 或者 `CoordinatorLayout`，但新手用不懂，高手也容易遗忘某些配置而踩坑。\n\n那么 `Compose` 需要多少代码呢？\n\n```\nval nestedScrollConnection = remember {\n    object : NestedScrollConnection {\n        override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {\n            if (available.y < 0 && vm.scrollState.canScrollForward) {\n                scope.launch {\n                    vm.scrollState.scrollBy(-available.y)\n                }\n                return available\n            }\n            return super.onPreScroll(available, source)\n        }\n    }\n}\nColumn(\n    modifier = Modifier\n        .fillMaxSize()\n        .verticalScroll(vm.scrollState)\n        .nestedScroll(nestedScrollConnection)\n) {\n    BookInfoBasic(info)\n    BookInfoPageTabSegment(vm = vm)\n    HorizontalPager(...)\n}\n```\n\n这样就完成整个界面了，其实也是对 `nestedScroll` 的封装，道理和 `View` 体系一样，只是用起来更方便了。\n\n## ChatGPT\n\n`ChatGPT` 对于 `Compose` 而言，很不好，毕竟其训练依赖的是旧版本，所以会有很多错误，所以不能用的，但是它在逻辑层面就很好用了，例如文件上传、下载等，我都是让它写，写完自己校验下，就完工了。为了赶时髦，我当然也在 `app` 里接入了 `ChatGPT`，当然，我做了配置，目前对外不开放。\n\n![aa5.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf584aae13a14d3eac69065552cdd88c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 漫长的审核\n\n正如文章开始所说，开发我用了一个多月，但是后面的审核上线则是用了两个月左右，其实说到底还是对规则的不熟悉。在电子版权、安全评估报告等环节都是在处理一份之后才知道必须要另一个，所以化并行为串行了。并且做安全评估，给我的感觉就是我的 `app` 分分钟有上百万的日活，实际上整个圈子可能不过数万人，但我也得完成相应的功能，例如接入飞书机器人，在飞书群里完成内容审核功能。\n\n所以这两个月，最多的就是认识到了整个市场，在公司注册、记账、上架等各个环节衍生的无数商业行为，很多都是收智商税和信息差赚差价的。所以中国有商业头脑的人还是很多，在各个小环节拉拢豪绅、巧立名目，只要有信息差，我就可以无限拉高价格。因为也铸就了现在创业那高不可攀的围墙。\n\n当然，我已经进到墙内了，如果能够成功，那这个墙就是对我的保护了，毕竟干的又不是 `ChatGpt` 那种无法轻易复制的产品，所以这堵高墙就可以为我争取更多的成长时间了。\n\n在这两个月，我打造了另一款产品：[emo-ai](https://link.juejin.cn/?target=https%3A%2F%2Femo.qhplus.cn%2Fai%2Fdashboard%2Fchat \"https://emo.qhplus.cn/ai/dashboard/chat\")。最主要的功能就是 `ChatGpt` 的代理，目前维护了一个小用户群体，收到了第一桶小金。\n\n此外，我也了解了下 `StableDiffusion`，本地搭建了 `StableDiffusionWebUi` 的环境，了解它的 `prompt` 玩法、 `controlnet`、`lora` 之类的知识。绘图入魔怔~\n\n![aa6.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ad2281eee51461397c211c1dc30364a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 最后\n\n`ChatGPT` 的爆火，让人们见识到了 `AI` 的力量，开发、设计、文案等领域，都快被取代了。中医这个领域，虽然目前完全没有被波及，但我以前曾提过：\n\n\\*\\*治疗 = 根据【当前的症状/指标】推荐出【相应的药物】\n\n所以医学本质是一个推荐系统，西医强调靶向治疗，中医则是用阴阳五行之类的建立了一个巨大的模型，从这个角度上来讲，中医显然更胜一筹。\n\n但是深度神经网络时代，显然我们可以训练参数规模更大的模型，来完成辨证论治的过程。\n\n但是模型的训练，少不了数据的支撑以及模型的建立。\n\n数据来说，中医有几千年的数据积累，是世界上最大最全的资源，只是需要整合与结构化。\n\n而模型最为重要的是模型的结构是怎样的？损失函数、优化器如何定义？经过长久的学习，我已然有了一些思路，也是我跨领域融合所独有的见解。\n\n但目前数据还不是结构化的，`GPU` 也不是我能买得起的，所以这条路还很长，也是岐黄小筑想要承载的梦想。\n\n拥有梦想，也要脚踏实地，因为我目前做的事情就比较苦逼了。我要把一本本书籍的拆分出来，存成结构化的数据，并对内容做链接，用技术只能得到模糊的结果，最后还要自己去校对。录入系统的管理后台也还在建设中。\n\n所以， 最后再吹下 `Compose`， 为我节约了大量的时间。在 `View` 时代，鉴于喜欢写 `UI` 和能够写 `UI` 的人真的偏少，我大概能够一次性取代 6 个业务开发，那在 `Compose` 的加持下，也许取代 60 个业务开发也不是什么大问题了。', '', 3, 0, 0, 5, '2023-09-10 07:12:36', 1);
INSERT INTO `article` VALUES (11, 5, 'git代码分支操作整理', '_当我们的同一个项目中开发人员多时，分支也会多，这样一来一个分支操作规范就显得很有必要了。下面是自己对于项目建分支的想法和分支常用的操作整理_\n\n## 一、项目要创建多少分支\n\n我们的APP项目代码随着功能需求并行开发、bug修复等不断迭代，一个master分支是远远不够的，那么我们需要多少分支来管理代码呢？ 项目建多少个主要的分支要根据项目情况来决定，主要可以有以下几个分支：\n\n1.  **master分支**是主分支，这个分支记录着APP版本迭代历史，这个分支我们只接受分支合并的更改，这样能使提交记录更清晰；每次打包发布AppStore审核上线后可以打一个版本的tag来标记；一般会设置为只有管理员有权限更改。\n    \n2.  **feature分支**，一般是一个功能需求来临时，有开发人员自行从`master`切出一个分支。命名可以为`feature/yourName/desciption`. 需求开发完成 --》 打单需求测试包 --》功能测试没问题了 --》提交`merge request`到`release分支`(下面会讲到)。\n    \n3.  **release分支**，在确定了最近要上线的一个版本包含的功能之后，从`master`上切出`release分支`，命名可以为`release-xxxx`; 此分支将负责集成测试，由各个**feature分支**的功能测试完成后提交`merge request`到此分支；之后对于测试提出的bug或者修改 --》从最新的**release分支**切出一个分支，改好之后提交`merge request`再删除分支，这样做在**release分支**上的提交记录会非常清楚。\n    \n4.  **hotfix分支**是在master分支的线上版本发现bug时，需要切出`hotfix分支`来修复，命名可以为`hotfix/yourName/desciption`, 修复并测试通过后，如果是紧急发布，则在此分支发布审核并由管理员合并到`master`，打一个版本标签🏷；如果非紧急，则可以集成合并到最近的**release分支**上。\n    \n\n最终准备发布App Store审核了，要确保万一，我们可以在提交App Store的构建版本先发布一个`testflight`包给内部测试人员,没问题之后再发布审核。 [iOS使用TestFlight进行内部和外部人员测试](https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F94eb388b5a36 \"https://www.jianshu.com/p/94eb388b5a36\")\n\n## 二、在分支中回撤提交内容\n\n![git分区.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c2529a464104cd0b0567ffc5cf7cadd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 在一个分支中，如果发现中间有提交版本是有问题需要撤回，这个时候我们该如何去实现呢？为了以后能简单的解决这个问题，我们先来学习一下git的`reset`和`revert`两个操作：\n\n### 2.1 `git reset` 命令的作用是重置到某个提交版本, 具体的命令作用如下，是我自己手动测试过的，可信赖！\n\n```\n// git reset 操作主要学习3种类型：--hard、--soft 、--mixed\ngit reset --hard // 默认操作的是HEAD(当前分支)，等价于git reset --hard HEAD \n(1) 在本地更改还没有提交时，这个命令作用是将文件重置到未更改的状态。\n(2) 在执行了(add .）但是还没有（comit）时，作用同（1），并且暂存区不会保存这个更改。\n(3) 已经执行了(add .）和（comit）时，此时HEAD本身是未更改状态，所以不起作用。\n// 每次执行操作后可以通过git status命令来查看状态\n\ngit reset --hard HEAD^ // HEAD^代表上一个版本，^多一个版本就多一个，比如HEAD^代表上上个版本\n(1) 作用是会将内容重置到上一次提交的版本，并且丢弃上一次版本之后的更改内容\n\ngit reset --soft HEAD^ // 这里HEAD^不能省略, 代表上一个版本\n(1) 当前没有更改内容时，作用是将分支拉回到上一个版本，并且保留提交的内容在暂存区（就是git add .之后的状态）\n(2) 当前有更改内容未提交时, 作用同上，之后再执行git add .后，可以看到这次提交和上次提交的更改在暂存区\n\ngit reset --mixed HEAD^ // 这里HEAD^不能省略, 代表上一个版本\n(1) 作用是将分支拉回到上一个版本，并且将之前提交的内容恢复到未提交的状态；如果执行前有未提交内容，则恢复后内容和未提交内容都混合在未提交内容里面。\n```\n\n如果是reset时不小心重置过头了，有用的版本被reset了怎么办？\n\n```\n如果我们执行git reset --hard HEAD^时不小心多加了一个^, \n我们应该这样重置：\n1. 首先查看HEAD变更日志\ngit reflog -3// 这里之后会出现一个HEAD变更日志列表（3条）\n1536b76 (HEAD -> dev) HEAD@{0}: reset: moving to HEAD^^\nf9308d2 HEAD@{1}: commit: 重置测试而提交2\n70bffae HEAD@{2}: commit: 重置测试而提交1\n\n2. 根据日志列表来选择好自己要重置到的版本, 比如HEAD@{2}\n git reset HEAD@{2} // 这条执行后就会把HEAD@{2}版本的更改放置到工作区，我们重新git add . 和git commit 提交即可\n```\n\n### 2.2 `git revert`的作用是回撤某个提交的内容并产生一个新的提交，撤销时如果有冲突的地方，并不会立即产生一个新提交，需要自己改好冲突后，根据`git status`的提示去执行`git revert --continue`。\n\n```\ngit revert HEAD // 生成撤销最近提交的一个新提交\ngit revert HEAD^ // 生成撤销上上个提交内容的一个新提交\ngit revert commit_id // 生成撤销commit_id内容的一个新提交\n\n// 下面是一次撤销多个提交，-n代表不生成新的提交，由自己手动提交一次\ngit revert -n commitid1 commitid2 // 撤销多个提交，不自动生成新提交，需要手动改好后去提交\ngit revert -n commitid1..commitid2 // 撤销一个区间内的提交,不自动生成提交，区间代表的回撤是从commitid1之后到commitid2之内的提交\n\n// 如果我们不加-n参数，我们会发现一次只能回撤多个提交中的最后一个\ngit revert commitid1..commitid2 \n// 这样下来我们需要在上述执行后，填好commit后，查看当前revert的进度\ngit status // 查看当前状态，如果还有内容要revert，git会提示要继续执行即:\ngit revert --continue\n// 重复上述步骤，直到全部revert完成，中间有冲突则需要自己解决后执行git revert --continue\n// 我们上述会发现revert提交记录会有多次\n```\n\n-   `revert merge commit`，当回撤的提交版本遇到了分支合并情况 revert的提交中包含了分支合并的提交，我们直接使用git revert commitid并不能成功，原因是没有标明合并的两个分支哪个是主线。revert merge commit 操作需要添加 -m 选项，代表这次 revert 的是一个 merge commit, 具体做法如下：\n\n```\n// 先查看合并提交的信息\ngit show commitid // 之后会有下面的Merge一行信息\nMerge: d94a489 e5f08c4\n\n需要注意的是 -m 选项接收的参数是一个数字，\n数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个。\n1. 我们这里当前分支是主线，所以revert操作如下\n// 下面操作过后会把合并分支的内容撤回，如果没有冲突会生成提交，有冲突需要自己手动改好, 然后运行git status看回撤情况需不需要git revert --continue\ngit revert -m 1 commitid// （这个commitid是合并提交的id，别错写成主线id了😭）\n\n2. 如果我们上面错将1写成了2，则结果会变成什么? 😭\n我们惊奇的发现当前分支代码变成了2分支中合并前的代码，这很不妥！\n所以我们应该使用上面所说的git reset来回到原来的版本。\n然后进行git revert -m 1 commitid\n```\n\n**由上，我们发现reset与revert的区别主要在于回撤后，revert是将回撤内容作为一个新提交，reset是将当前节点重置到之前节点。**\n\n接下来我们应该很清楚该怎么选择回撤方式了。\n\n> 1.  撤回的`commitid`及后续都可不要的情况下\n> \n> -   如果是已经推送到远程的分支，那么我们就尽量选择revert 方式，这样能保持提交日志连续性。\n> -   如果是自己一个人的feature分支，自己不小心提交错了，那么reset也可。\n> \n> 2.  撤回的`commitid`后续有正确的提交需要保留的情况下，需要使用revert来完成，方法如上！\n\n## 三、merge和rebase操作\n\n### 3.1 当我们在feature-aaa分支开发完功能后，要合并到release分支，可以选择使用git merge：\n\n```\ngit checkout release\ngit pull origin release\ngit merge feature-a\n// 如果有冲突，则解决冲突后再提交，根据git status提示来干！\n```\n\n### 3.2 `git rebase`的作用主要如下：\n\n1、假设场景：从 `master` 拉出分支 `feature-a`和`release-x`。那么当 `release-x` 要合并 `feature-a` 的内容时，使用 `git merge feature-a`；如果在`release-x` 分支发布前`master`有一个新的发布提交，此时， `release-x` 需要同步 `master`上的这个提交以保持同步 ，这个时候可以使用 `git rebase master`。\n\n> `git rebase master` 的作用就是**将master分支上自切出分支`release-x`之后的所有提交插入到当前分支`release-x`的提交前面，这相当于将`release-x`变成跟从最新master切出的分支一样。** ![对应的souretree上的操作.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd77f06549a84698b3bdb4922957ef99~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n[feature分支执行git rebase后推送不成功](https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc48ea1eeb47e \"https://www.jianshu.com/p/c48ea1eeb47e\")\n\n2.  假设我们想删除\\\\交换提交，可以使用如下命令 可以学习vim编辑器操作: [vi/vim编辑器入门](https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fxing851483876%2Farticle%2Fdetails%2F84553945 \"https://blog.csdn.net/xing851483876/article/details/84553945\")\n\n```\n// 1.假设是删除倒数第二个提交\ngit rebase -i HEAD~2 \n// 执行后命令行会进入vim编辑器\n上下移动光标在指定行，按\'dd\'即可删除行，然后按esc退出输入:wq退出编辑，可以看到操作就完成了\n// 2. 假设是交换倒数第二个和倒数第一个提交\ngit rebase -i HEAD~2\n进入vim编辑器后，按\'dd\'删除第一行，移动到下面后按\'p\'会粘贴到下面，再退出编辑操作就完成了\n```\n\n3.  [更多rebase的操作可查看](https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fthe_power%2Farticle%2Fdetails%2F104651772%2F \"https://blog.csdn.net/the_power/article/details/104651772/\")\n\n## 四、`cherry pick` 分支中某个特定提交合并到当前分支\n\n在我们开发完了多个功能，并且测试、验收也通过了，但是即将要发布的一个版本只包含了其中的几个功能，这个时候，我们首先会从`master分支`切出一个`release分支`来集成发布版本，使用`git cherry pick` 来将特定的一些提交合并到`release分支`。 下面是一个例子：当前是`release-v1.0.1`, 要挑出的提交是`feture-xx`上倒数第二个提交`e5f08c475e513ec41332a4b99d19d3f212b25c18`\n\n```\ngit cherry-pick e5f08c475e513ec41332a4b99d19d3f212b25c18\n// 1. 如果cherry-pick时有冲突，可以根据git status的提示来操作\n// 2.如果是要cherry-pick多个提交时，可以使用区间来完成\ngit cherry-pick commitid1^.. commitid5\n```\n\n## 五、 其它几个常用git命令\n\n```\ngit config --global user.name dandy // 配置全局用户dandy用于提交信息\ngit config --global user.email  xxxx@163.com // 配置全局邮箱用于提交信息\ncat ~/.gitconfig  // 查看用户配置\n\ngit status // 查看当前git下的文件状态\ngit add . // 将更改的内容添加到暂存区\ngit commit -m 提交信息 // 将暂存区内容提交一个版本\ngit commit -a -m 提交信息 // 将更改的内容直接提交一个版本\n\ngit tag -a tag1 // 给当前分支添加一个tag1\ngit tag -l // 当前已有的tag\ngit tag v0.9 commitid // 给指定的提交commitid添加标签v0.9\ngit tag -d tag1 // 删除tag1\n\ngit remote add origin https://xxxx.git // 将本地git库添加到远程库，这个远程库地址是自己创建到网站上创建的\n如果地址关联错了可以修改\ngit remote set-url origin xxxxx.git // 方法一：设置为新的地址\ngit remote rm origin // 方法二：移除远程分支关联，后面再关联新的\n\ngit branch // 查看本地分支\ngit branch -r // 查看远程分支\ngit branch -a // 查看所有分支（包括远程分支和本地分支）\ngit pull origin branchname// 从远程分支中拉取合并内容，等同于 fetch + merge\ngit fetch origin branchName\ngit merge origin/branchName\n\ngit remote -v // 查看关联的远程地址\ngit push -u origin branchName // 将提交内容推送到远程branchName分支\ngit push --tags // 将所有tag推送到远程\n\ngit branch branchname // 在当前分支新建分支\ngit checkout branchname // 切换到branchname分支\ngit branch -m oldName  newName // 本地分支重命名\ngit branch -d branchname // 删除本地分支\ngit push origin  : branchName 或者git push origin --delete branchName // 删除远程分支\ngit remote // 查看远程仓库\ngit checkout orgin/远程分支名 // 检出一个远程分支\n\ngit stash save \"贮藏备注名\" // 将当前工作区的更改贮藏\ngit stash list // 查看当前贮藏的内容\ngit stash apply \"stash@{index}\" // 将贮藏stash@{index}运用的当前工作区\ngit stash drop \"stash@{index}\" // 删除贮藏stash@{index}\ngit stash pop \"stash@{index}\" // 运用贮藏stash@{index}，并删除贮藏\n\n//这里只是美化 log 的输出，实际使用时可以在 git lg 后面加命令参数，如： git lg -10 显示最近10条提交\ngit config --global alias.lg \"log --color --graph --pretty=format:\'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\' --abbrev-commit\"\n\ngit log -p -- 文件路径 // 查看单个文件的修改记录\n\n```\n\n## 六、gitignore规则不生效的解决办法:\n\n```\ngit rm -r --cached .\ngit add .\ngit commit -m \'update .gitignore\'\n```\n\n[ios 忽略文件 .gitignore](https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F292ab814bde5 \"https://www.jianshu.com/p/292ab814bde5\") [iOS开发相关文章](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftangqiaoboy%2FiOSBlogCN \"https://github.com/tangqiaoboy/iOSBlogCN\")', '', 5, 2, 1, 430, '2023-09-10 07:28:15', 1);
INSERT INTO `article` VALUES (12, 6, 'Mr.', 'Navicat provides powerful tools for working with queries: Query Editor for editing the query text directly, and Query Builder, Find Builder or Aggregate Builder for building queries visually. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. Anyone who has never made a mistake has never tried anything new. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. You must be the change you wish to see in the world. Creativity is intelligence having fun. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. Instead of wondering when your next vacation is, maybe you should set up a life you don’t need to escape from. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections.', '', 1, 4, 0, 476, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (13, 6, '高效开发大屏可视化项目：公共组件封装指南', 'If the plan doesn’t work, change the plan, but never the goal. SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. Navicat 15 has added support for the system-wide dark mode. How we spend our days is, of course, how we spend our lives. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored.## 高效开发大屏可视化项目：公共组件封装指南\n\n这是一个基于Vue 3、Echarts、高德地图和Pinia开发的大屏可视化项目，提供了如下功能\n\n-   大屏适配\n-   图表组件(Echarts)封装\n-   高德地图组件封装\n-   拖拽布局\n-   入场动画\n-   无缝滚动\n\n[源码地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvangleer%2Fes-big-screen \"https://github.com/vangleer/es-big-screen\")\n\n[在线示例](https://link.juejin.cn/?target=https%3A%2F%2Fvangleer.github.io%2Fes-big-screen \"https://vangleer.github.io/es-big-screen\")\n\n## 大屏适配\n\n大屏适配常用的方案有 `rem + vw/vh` 和 `scale` 两种方案\n\n1.  `rem + vw/vh` 方案是一种结合使用rem（相对于根元素字体大小的单位）和vw/vh（视窗宽度/高度的单位）来实现大屏的适配。\n    \n    -   优点: 灵活性高、兼容性好、适应性强\n    -   缺点: 需要进行许多计算，可能存在误差问题，且代码复杂度较高\n2.  `scale` 方案通过改变页面根元素的缩放比例来实现大屏适配。\n    \n    -   优点: 实现简单，不需要进行计算\n    -   缺点: 会存在像素失真问题\n\n下面我们选择使用 `scale` 缩放这种方式来实现适配\n\n```\n// src/utiles/useResize.ts\nimport { ref, onMounted, onBeforeUnmount } from \'vue\'\n\n// 默认适配宽高\nexport const width = 1920\nexport const height = 1080\n\ntype ResizeType = {\nw?: number\nh?: number\nfullScreen?: boolean\ndelay?: number\n}\n\nexport const useResize = (options: ResizeType = {}) => {\nconst {\nw = width,\nh = height,\nfullScreen = false,\ndelay = 100\n} = options\n// 缩放元素\nconst screenRef = ref()\n  const scale = ref(1)\n  function resize() {\n    // 浏览器宽高\n    const clientWidth = document.body.clientWidth\n    const clientHeight = document.body.clientHeight\n\n    // 计算宽高缩放比例\nconst scaleW = clientWidth / w\nconst scaleH = clientHeight / h\n\n    if (clientWidth / clientHeight > w / h) {\n// 如果浏览器的宽高比大于设计稿的宽高比，就取浏览器高度和设计稿高度之比\n      scale.value = scaleH\n    } else {\n// 如果浏览器的宽高比小于设计稿的宽高比，就取浏览器宽度和设计稿宽度之比\n      scale.value = scaleW\n    }\n\nif (fullScreen) {\n// 如果不在乎缩放失真的情况，可以设置全屏\nscreenRef.value.style.transform = `scale(${scaleW}, ${scaleH})`\n} else {\n// 否则选择适配比例缩放\nscreenRef.value.style.transform = \'scale(\' + scale.value + \')\'\n}\n  }\n\nconst resizeDelay = debounce(resize, delay)\n  onMounted(() => {\nif (screenRef.value) {\nresize()\n    window.addEventListener(\'resize\', resizeDelay)\n}\n  })\n\n  onBeforeUnmount(() => {\n    window.removeEventListener(\'resize\', resizeDelay)\n  })\n\n  return {\n    scale,\nscreenRef\n  }\n}\n```\n\n核心代码在resize函数中\n\n-   首先要确定我们的设计稿尺寸，默认是 `1920 x 1080`\n-   分别计算浏览器和设计图宽高比\n-   如果浏览器的宽高比大于设计稿的宽高比，就取浏览器高度:设计稿高度，否则取浏览器宽度:设计稿宽度\n-   如果想全屏缩放，就分别使用宽高比进行缩放\n-   出于对性能的考虑，useResize中使用了防抖，实现如下\n\n```\nfunction debounce(callback, delay) {\nlet timerId\nreturn function (event) {\n// 如果上次事件还没有真正处理, 清除\nif (timerId) {\nclearTimeout(timerId)\n}\n\n// 发事件发生指定事件后才调用处理事件的回调函数\n// 启动定时器, 只是准备真正处理\ntimerId = setTimeout(() => {\n// 正在处理事件\ncallback.call(null, event)\n// 删除准备处理的标记\ntimerId = null\n}, delay)\n}\n}\n```\n\n### 使用就非常简单了\n\n将 `useResize` 返回的 screenRef 赋值需要缩放的元素即可\n\n```\n\n<template>\n<div ref=\"screenRef\"></div>\n</template>\n\n<script setup lang=\'ts\'>\nimport { useResize } from \'@/utils/useResize\'\nconst { screenRef } = useResize()\n</script>\n\n```\n\n-   效果演示\n\n![01.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6af102eed149a18e6856f5717407bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 图表组件(Echarts)封装\n\n### 安装依赖\n\n```\nyarn add echarts\n```\n\n### 封装Char组件\n\n-   按需引入 `src/components/chart/index.ts`\n\n```\nimport Chart from \'./Chart.vue\'\n// Import the echarts core module, which provides the necessary interfaces for using echarts.\nimport * as echarts from \'echarts/core\'\n\n// Import bar charts, all suffixed with Chart\nimport {\nBarChart,\n} from \'echarts/charts\'\n\n// Import the tooltip, title, rectangular coordinate system, dataset and transform components\nimport {\n  TitleComponent,\n  TooltipComponent,\n  GridComponent,\n  DatasetComponent,\n  TransformComponent\n} from \'echarts/components\'\n\n// Features like Universal Transition and Label Layout\nimport { LabelLayout, UniversalTransition } from \'echarts/features\'\n\n// Import the Canvas renderer\n// Note that including the CanvasRenderer or SVGRenderer is a required step\nimport { CanvasRenderer } from \'echarts/renderers\'\nimport { App } from \'vue\'\n\nexport const install = (app: App) => {\napp.component(\'v-chart\', Chart)\n}\n\n// Register the required components\necharts.use([\nBarChart,\nTitleComponent,\nTooltipComponent,\nGridComponent,\nDatasetComponent,\nTransformComponent,\nLabelLayout,\nUniversalTransition,\nCanvasRenderer\n])\n\nexport default {\ninstall\n}\n\n```\n\n-   Chart 组件 `src/components/chart/Chart.vue`\n\n```\n\n<template>\n<div ref=\"chartRef\" className=\'es-chart\'></div>\n</template>\n\n<script setup lang=\'ts\'>\nimport { onMounted, PropType, shallowRef, watch } from \'vue\'\nimport * as echarts from \'echarts\'\nimport { ECharts, EChartsCoreOption } from \'echarts\'\n\nconst props = defineProps({\noption: {\ntype: Object as PropType<EChartsCoreOption>,\nrequired: true,\ndefault: () => ({})\n},\nloading: Boolean\n})\nconst chartRef = shallowRef<HTMLElement | null>(null)\n\nconst chart = shallowRef<ECharts | null>(null)\nfunction init() {\nif (props.option) {\nchart.value = echarts.init(chartRef.value!)\nsetOption(props.option)\n}\n}\nfunction setOption(option, notMerge?: boolean, lazyUpdate?: boolean) {\nchart.value!.setOption(option, notMerge, lazyUpdate)\n}\n\nfunction resize() {\nchart.value!.resize()\n}\n\nwatch(() => props.option, () => {\nsetOption(props.option)\n})\n\n// show loading\nwatch(() => props.loading, (val) => {\nif (!chart.value) return\nif (val) {\nchart.value!.showLoading()\n} else {\nchart.value!.hideLoading()\n}\n})\n\nonMounted(() => {\ninit()\n})\n\ndefineExpose({\nchart,\nsetOption,\nresize\n})\n</script>\n\n<style lang=\'scss\' scoped>\n.es-chart {\nwidth: 100%;\nheight: 100%;\n}\n</style>\n```\n\n-   注册组件 `src/main.ts`\n\n```\n\nimport { createApp } from \'vue\'\nimport App from \'./App.vue\'\nimport * as chart from \'./components/chart\'\ncreateApp(App).use(chart).mount(\'#app\')\n\n```\n\n```\n\n<template>\n<v-chart ref=\"chartRef\" :option=\"option\" />\n</template>\n\n<script setup lang=\'ts\'>\nimport { ref } from \'vue\'\nconst chartRef = ref()\nconst option = ref({\n  xAxis: {\n    type: \'category\',\n    data: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\']\n  },\n  yAxis: {\n    type: \'value\'\n  },\n  series: [\n    {\n      data: [120, 200, 150, 80, 70, 110, 130],\n      type: \'bar\',\n      showBackground: true,\n      backgroundStyle: {\n        color: \'rgba(180, 180, 180, 0.2)\'\n      }\n    }\n  ]\n})\n</script>\n\n```\n\n![02.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3c4148b5bc4b8c91d40a18eb7f6126~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 上面只是对echarts的简单封装，当组件挂载后我们可以使用 `chartRef.value.chart` echarts的实例，完成一些复杂的功能\n\n## 高德地图组件封装\n\n[高德地图 JS API 2.0](https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjsapi-v2 \"https://lbs.amap.com/api/jsapi-v2\")\n\n在开发大屏项目时可能也会遇到地图相关的需求，这就需要使用原生的地图，这里使用的是高德地图\n\n使用前需要注册开发者账号，申请API Key，服务平台选择 `Web端(JS API)`\n\n### 安装依赖\n\n```\n\nyarn add @amap/amap-jsapi-loader\nyarn add @amap/amap-jsapi-types -D\n\n```\n\n### vue 组件\n\n```\n<template>\n<div id=\"mapContainer\"></div>\n</template>\n\n<script setup lang=\'ts\'>\nimport { onMounted, shallowRef } from \'vue\'\nimport \'@amap/amap-jsapi-types\'\nimport AMapLoader from \'@amap/amap-jsapi-loader\'\n\nconst map = shallowRef<AMap.Map | null>(null)\n\nfunction initMap() {\n  AMapLoader.load({\nkey: \'\', // 申请好的Web端开发者Key，首次调用 load 时必填\nversion: \'2.0\', // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15\nplugins: [], // 需要使用的的插件列表，如比例尺\'AMap.Scale\'等\n}).then((MyAMap: typeof AMap)=>{\nmap.value = new MyAMap.Map(\'mapContainer\',{\nmapStyle: \'amap://styles/darkblue\'\n})\n}).catch(e=>{\nconsole.log(e);\n})\n}\n\nonMounted(() => {\ninitMap()\n})\n\ndefineExpose({\nmap\n})\n</script>\n\n<style lang=\'scss\'>\n#mapContainer {\nwidth: 100%;\nheight: 100%;\n}\n.amap-logo, .amap-copyright {\nopacity: 0;\n}\n</style>\n\n```\n\n![04.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61289f8d6adf42458ad9b08666fceb0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n因为直接选用的是AMap默认支持的主题，样式有点不协调(●\'◡\'●)，不过我们可以按照设计图要求去官网自定义主题\n\n## 拖拽布局\n\n这里我们使用了 SortableJS 来实现拖拽\n\nSortableJS是一个强大的JavaScript库，用于创建可排序、可拖放和可交互的列表。它提供了一种简单的方法来实现拖放排序功能，使用户可以通过拖动列表项来重新排序它们。\n\n### 安装依赖\n\n```\nyarn add sortablejs\n```\n\n### 封装useSortable\n\n```\n// src/utils/useSortable.ts\n\nimport { ref, onMounted, Ref } from \'vue\'\nimport Sortable from \'sortablejs\'\n\nexport const useSortable = (listRef: Ref<any[]>) => {\n\n// 容器元素\nconst containerRef = ref()\n\nonMounted(() => {\nSortable.create(containerRef.value!, {\nswapThreshold: 1,\nanimation: 150,\nonUpdate(e) {\nconst item = listRef.value[e.oldIndex]\nlistRef.value.splice(e.oldIndex, 1)\nlistRef.value.splice(e.newIndex, 0, item)\n}\n})\n})\n\nreturn {\ncontainerRef\n}\n}\n\n```\n\n### 使用方式\n\n```\n<template>\n<div ref=\"containerRef\">\n<component\nv-for=\"item in components\"\n:key=\"item.name\"\n:is=\"item.component\"\nclass=\"es-screen-right-item\"\n>\n{{ item.name }}\n</component>\n</div>\n</template>\n\n<script setup lang=\'ts\'>\nimport { shallowRef } from \'vue\'\nimport { useSortable } from \'@/utils/useSortable\'\nimport Right1 from \'./Right1.vue\'\nimport Right2 from \'./Right2.vue\'\nimport Right3 from \'./Right3.vue\'\nconst components = shallowRef([\n{ name: \'right1\', component: Right1 },\n{ name: \'right2\', component: Right2 },\n{ name: \'right3\', component: Right3 }\n])\n\nconst { containerRef } = useSortable(components)\n</script>\n\n<style lang=\'scss\' scoped>\n.es-screen-right-item {\nwidth: 100%;\nheight: 300px;\nbackground-color: var(--es-block-bg);\npadding: 16px;\n& + & {\nmargin-top: 20px;\n}\n}\n</style>\n\n```\n\nuseSortable 会返回父元素的ref将其挂载到列表标签上即可，如果希望列表数据也交换需要将列表传入到函数中\n\n效果演示\n\n![03.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a8d05a82a1d4a9e8514675f9490770f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 最后\n\n本文主要介绍了在开发大屏项目时的一些常见功能并对其进行了封装，为大屏可视化开发提供了一些基础的解决方案，你可以根据示例代码进行实践和定制\n\n关于 `入场动画`和 `无缝滚动` 请参考另一篇文章\n\n[入场动画和无缝滚动](https://juejin.cn/post/7253115535483207737 \"https://juejin.cn/post/7253115535483207737\")', 'public/uploads/1694336227656.png', 2, 3, 1, 548, '2023-09-10 08:57:10', 1);
INSERT INTO `article` VALUES (14, 5, '如何在项目中使用 SFSafariViewController', '### SFSafariViewController\n\n![](https://pic3.zhimg.com/v2-83b53e79f1eeeaff293e1c7d54e70132_b.jpg)\n\n使用 SFSafariViewController 的好处是它可以让你在 App 内提供一个跟 Safari 几乎一样功能方式来展示网页，不需要定制 UI，简单几行代码即可实现，并且数据也是跟 Safari 共享的，例如阅读器、自动填充账号密码、欺诈性网站检测和内容阻止等等。\n\n缺点时用户的活动和与 SFSafariViewController 的交互对你的应用来说是不可见的，因为应用无法访问自动填充数据、浏览历史记录或网站数据，这也保证了用户的安全。\n\n国内的 App 几乎很少见到用 SFSafariViewController 的，更多的还是用内嵌的 WKWebView，因为 WKWebView 灵活性更高。而国外的 App 如 Twitter、GitHub 等都有在用。\n\n### 在项目中使用 SFSafariViewController\n\nSFSafariViewController 不在 UIKit 中，而是在一个名为 SafariServices 框架，因此你需要导入才能使用它：\n\n然后在你需要打开网页的地方使用如下代码即可：\n\n```\nlet vc = SFSafariViewController(url: URL(string: \"https://apple.com\")!)\npresent(vc, animated: true)\n\n```\n\n上边的代码会在你的 App 内打开一个苹果的网页。\n\n### 自定义配置\n\nSFSafariViewController 还提供一个配置选项，支持配置不同的参数，这个配置是 `SFSafariViewController.Configuration` 类型。\n\n```\nlet config = SFSafariViewController.Configuration()\n\nlet vc = SFSafariViewController(url: URL(string: \"https://apple.com\")!, configuration: config)\npresent(vc, animated: true)\n\n```\n\n默认情况下，当页面往上滚动，顶部和底部的菜单栏会隐藏，如果不想隐藏可以设置：\n\n```\nconfig.barCollapsingEnabled = false\n\n```\n\n默认情况下，Safari 的阅读模式是禁用的，如果想打开，只需要设置：\n\n```\nconfig.entersReaderIfAvailable = true\n\n```\n\nSFSafariViewController 本身还有一些设置选项，以下代码是一个较全的配置：\n\n```\nlet config = SFSafariViewController.Configuration()\n// 禁用滚动隐藏顶部和底部 bar\nconfig.barCollapsingEnabled = false\n// 如果网页支持的话，启用阅读模式\nconfig.entersReaderIfAvailable = true\n\nlet vc = SFSafariViewController(url: URL(string: \"https://apple.com\")!, configuration: config)\n// 设置顶部和底部 bar 的颜色为红色\nvc.preferredBarTintColor = .red\n// 设置按钮和和文本的渲染颜色为蓝色\nvc.preferredControlTintColor = .blue\n// 设置左上角 dismiss 按钮的文案为 cancel\nvc.dismissButtonStyle = .cancel\n\npresent(vc, animated: true)\n\n```\n\n最终效果：\n\n![](https://pic3.zhimg.com/v2-f4139be092ad1360d9f2e97e7a09a096_b.jpg)\n\n### 代理回调方法\n\nSFSafariViewController 还有个 SFSafariViewControllerDelegate 的代理，通过 `vc.delegate = self` 绑定之后就可以使用了：\n\n```\n/** 在用户点击底部分享按钮后调用，可以返回一组 [UIActivity] 来指定显示哪些 App\n */\noptional func safariViewController(_ controller: SFSafariViewController, activityItemsFor URL: URL, title: String?) -> [UIActivity]\n\n\n/** 返回要排除哪些 ActivityType 类型\n */\n@available(iOS 11.0, *)\noptional func safariViewController(_ controller: SFSafariViewController, excludedActivityTypesFor URL: URL, title: String?) -> [UIActivity.ActivityType]\n\n\n/** 当用户点击完成按钮时调用 */\noptional func safariViewControllerDidFinish(_ controller: SFSafariViewController)\n\n\n/** 在初始 URL 加载完成时调用。didLoadSuccessfully： 是否加载成功\n */\noptional func safariViewController(_ controller: SFSafariViewController, didCompleteInitialLoad didLoadSuccessfully: Bool)\n\n\n/** 当浏览器在加载初始页面时被重定向到另一个 URL 时调用。\n */\n@available(iOS 11.0, *)\noptional func safariViewController(_ controller: SFSafariViewController, initialLoadDidRedirectTo URL: URL)\n\n\n/** 当用户通过点击工具栏按钮在 Safari 浏览器中打开当前页面时调用。\n */\n@available(iOS 14.0, *)\noptional func safariViewControllerWillOpenInBrowser(_ controller: SFSafariViewController)\n\n\n```\n\n### iOS 15 新增功能\n\n在 iOS 15 中，SFSafariViewController 提供了一个类方法 `prewarmConnections`，参数是一个 URL 数组，支持预加载一批网页。**按照苹果的文档，返回的 token 对象必须强引用才行**。\n\n```\nlet urls = [URL(string: \"https://apple.com\")!]\nlet token = SFSafariViewController.prewarmConnections(to: urls)\n\n```\n\n**点击下方公众号卡片，关注我，每天分享一个关于 iOS 的新知识**\n\n> 本文同步自微信公众号 “[iOS新知](https://link.juejin.cn/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fmp.weixin.qq.com%2Fs%253F__biz%253DMzg3MDk3NzUzNw%253D%253D%2526mid%253D2247484282%2526idx%253D1%2526sn%253D693bdee8862280e1b3dada2fdbe5e18b%2526chksm%253Dce84da14f9f353026681ea6688cbf21c188cebd203ea2ffd3b06c59680d8ba759214f444e424%2526token%253D971462296%2526lang%253Dzh_CN%2523rd \"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg3MDk3NzUzNw%3D%3D%26mid%3D2247484282%26idx%3D1%26sn%3D693bdee8862280e1b3dada2fdbe5e18b%26chksm%3Dce84da14f9f353026681ea6688cbf21c188cebd203ea2ffd3b06c59680d8ba759214f444e424%26token%3D971462296%26lang%3Dzh_CN%23rd\")”，每天准时分享一个新知识，这里只是同步，想要及时学到就来关注我吧！', '', 5, 4, 0, 122, '2023-09-10 07:28:46', 1);
INSERT INTO `article` VALUES (15, 3, 'Node.js技术架构', '## JS如何调用C++\n\n## Node.js不是什么\n\n### 不是web框架\n\n-   Node.js并不是web后端框架\n-   所以不能把Node.js与Flask或Spring比较\n\n### 不是编程语言\n\n-   Node.js并不是后端的JS\n-   所以不能把Node.js与Python或PHP对比\n\n## Node.js是什么\n\n### 是一个平台\n\n-   它将多种技术组合起来\n-   让JavaScript也能调用系统接口、开发后端应用\n\n### Node.js组合了很多技术\n\n-   V8引擎\n-   libuv\n-   C/C++实现的`c-ares(域名解析)、http-parser(解析http)、OpenSSL(做https)、zlib(做加密)`等库\n\n## Node.js技术架构\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf31872700c4f568e80f60c7c2933fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n随着Node.js的版本已经从0.8升级到12.11.1，其架构也在一直变化中\n\n如果要看源代码，推荐看0.10版本,github中找到nodejs选择0.10版本即可\n\n[github.com/nodejs/node…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Ftree%2Fv0.10 \"https://github.com/nodejs/node/tree/v0.10\")\n\n因为这一版本使用了很久一段时间，而且源代码比新版少很多\n\n如果想要了解更多，可以查看 [github.com/yjhjstz/dee…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyjhjstz%2Fdeep-into-node \"https://github.com/yjhjstz/deep-into-node\")\n\n我们大部分时候，只需要学习Node.js标准库即可\n\n对于其他模块，有一个大概的了解就行\n\n等对Node.js内部实现感兴趣的时候，再去了解标准库之外的东西\n\n不过你可能要写好 C / C++\n\n### 什么是bindings\n\n#### 背景\n\n-   C/C++实现了一个http\\_parser库，很高效\n-   我们只会写JS，但是又想调用这个库\n-   直接调用肯定是不能成功的，我们需要一个中间的桥梁\n\n#### bindings\n\n-   Node.js用C++对http\\_parser进行封装，使它符合某些要求(如：它的数据类型和JS数据类型做了一一对应的封装)，封装的文件叫做http\\_parser\\_bindings.cpp(C++的代码)\n-   用Node.js提供的编译工具将其编译为.node文件\n-   JS代码可以直接require这个.node文件\n-   这样JS就能调用C++库，中间的桥梁就是binding(http\\_parser\\_bindings.cpp)\n-   由于Node.js提供了很多binding，所以加个s\n-   这就是bindings\n\n#### JS 与 C++ 交互\n\n查看： [nodejs.cn/api/addons.…](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.cn%2Fapi%2Faddons.html%23addons_function_arguments \"https://nodejs.cn/api/addons.html#addons_function_arguments\")\n\n> 插件通常会暴露可以从 Node.js 中运行的 JavaScript 访问的对象和函数。 当从 JavaScript 调用函数时，输入参数和返回值必须映射到 C/C++ 代码和从 C/C++ 代码映射。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/235a640c156d4bc994c54541315f87ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n在test.js就实现了通过JS引入addon这样的node.js文件，调用了addon.cc(C/C++)中的add方法\n\n#### C++ 调用JS回调\n\n查看： [nodejs.cn/api/addons.…](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.cn%2Fapi%2Faddons.html%23addons_callbacks \"https://nodejs.cn/api/addons.html#addons_callbacks\")\n\n> 插件中的常见做法是将 JavaScript 函数传给 C++ 函数并从那里执行它们\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0795b661d6b40f2a9bed05b03d63faa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nargs\\[0\\]就是JS中的那个函数，但是args\\[0\\]不能直接给C++,C++是看不懂JS函数的，Node.js提供了Cast的工具，它可以把JS的函数转化为C++能看懂的函数cb。JS中的函数addon就会被C++调用，调用的时候传了参数hello world(C++中构造了JS能看懂的string) ，于是就输出了hello world\n\n只要能让JS调用C++的代码，JS的能力就会被无限扩大\n\nNode.js提供的binding我们可以使用，如果现在有一个新的C++库，Node.js没有把它绑定进来怎么办？\n\nNode.js还提供另外一个功能： 允许你自己写C++,把C++库绑定到JS上，JS就可以调用C++库了，这就是Node.js的另外一个能力，C/C++插件(自定义其他能力)\n\n#### Node.js的依赖\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b621984b9a684fd5b28a0164b83dfb4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n在Node.js V0.10 版本中有7个依赖，我们主要需要掌握两个依赖`v8和uv(也就是libuv)`,其他的优先级往后放\n\n-   cares:DNS\n-   http\\_parser: http\n-   npm: 包管理器\n-   openssl: https\n-   zlib: 压缩\n\n## libuv & v8 的功能\n\n## libuv是什么\n\n### 背景\n\n-   FreeBSD 系统上有kqueue\n-   Linux系统上有epoll\n-   Windows 系统上有IOCP\n-   Ryan为了实现一个**跨平台**的异步I/O(所有的输入和输出，如：写文件，访问网络，连接打印机打印文件即系统和外界进行的所有交互)库，开始写libuv\n-   libuv会根据系统自动选择合适的方案(kqueue/epoll/IOCP)\n\n### 功能\n\n-   可以用于TCP(http是基于TCP/IP,只要能操作TCP就可以做http服务器)/UDP(QQ聊天)/DNS(baidu.com对应的IP)/文件(文件的读取)等的异步操作\n-   有了这些功能Node.js就可以摆脱IO瓶颈了，涉及到IO的操作交给C语言去做，JS只负责简单的调用\n\n## v8是什么\n\n### 功能\n\n-   将JS源代码变成本地代码(01)并执行\n-   维护调用栈，确保JS函数的执行顺序\n-   内存管理，为所有对象分配内存\n-   垃圾回收，重复利用无用的内存(垃圾回收的目的是为了再次重复利用，因为内存是有限的，比如：你用完了2k的内存，用完了就得还给我，还要给下一程序使用呢！)\n-   实现JS的标准库(如：数组的sort、数组的splice等函数)\n-   v8本身是多线程的\n\n### 注意\n\n-   V8不提供DOM API(如：在V8中不能操作`douemnt.createElement()...`，它是浏览器提供的)\n-   V8**执行**JS是单线程的(V8本身是多线程的)\n-   可以开启两个线程分别执行JS(并不是真正意义上的多线程，这两个线程之间毫无瓜葛)\n-   V8本身是包含多个线程的，如：垃圾回收为单独线程\n-   自带 eventloop 但 Node.js并没有使用自带的eventloop而是基于libuv自己做了一个eventloop\n\n## eventloop\n\n## Event Loop 是什么\n\n### 什么是Event\n\n-   计时器到了就会产生一个事件，这个事件产生就会执行回调(内部的)\n-   文件可以读取了、读取出错了的时候是操作系统要单独生成一个事件告诉JS。如：拷贝文件到U盘上，如果发现此时已经有另外一个文件也在拷贝，那么此时第二个拷贝文件就会很慢，因为硬盘的读写速度是有极限的(外部的，文件再在硬盘上，而硬盘和操作系统是分开的)\n-   socket有内容了、关闭了。如:用户请求了我们的服务器，socket有内容了操作系统得告诉JS要开始读用户的内容。socket关闭了，也得告诉JS(外部的，socket一般为另外一台机器传过来的)\n\n### 什么是Loop\n\n-   Loop 就是循环，比如： while(true) 循环\n-   由于事件是分优先级的，所以处理起来也是分先后的\n\n举例：\n\n三种不同的事件\n\n```\nsetTimeout(f1,100)        // 计时器到时了\nfs.readFile(\'/1.txt\',f2)  // 文件可以读了\nserver.on(\'close\',f3)     // 服务器关闭了\n```\n\n如果同时触发，Node会怎么办？执行f1?f2?f3\n\n```\n- 肯定会有某种顺序(优先级)\n- 这种顺序应该是人为规定的(如果有读文件就先读文件 => 如果有请求就先处理请求=>如果有计时器就执行计时器 ====> 进入循环Loop => 如果有读文件就先读文件 => 如果有请求就先处理请求 => .......)\n```\n\n-   所以Node.js需要按照顺序轮询每种事件\n-   这种轮询往往都是循环的，1->2->3->1->2->3\n\n### EventLoop\n\n-   操作系统可以触发事件，JS可以处理事件\n-   Event Loop 就是对事件处理顺序的管理\n\n## Event Loop\n\n### 顺序示意图\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb8f62b6a49d4a5582e86ecffbb4708d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   读官方文档是最好的方式\n-   或者[juejin.cn/post/684490…](https://juejin.cn/post/6844903582538399752 \"https://juejin.cn/post/6844903582538399752\")\n\n#### 重点阶段\n\n-   timers 检查计时器\n-   poll 轮询阶段，处理大部分请求(如：读文件，http请求)，检查系统事件\n-   check 检查阶段，处理 setImmediate 回调\n-   close callbacks 看下有没有sockert关闭的回调\n-   再回到timers 检查计时器。。。 如此循环下去\n-   如果Node.js发现没有什么事做就会停在poll(轮询)阶段，如果发现有事情做，如执行`setImmediate`就会进入下个阶段check(while循环，一直问操作系统有没有文件可以读、有没有网络请求可以处理、。。。。)。poll阶段是Node.js停留时间最长的、优先级最高的\n-   其他阶段用的较少\n\n> 大部分时候timers中的定时器是后执行的(虽然它在最前面)，因为定时器至于在大于或等于时间的时候才会被执行，如果时间没到就会执行timers下面的阶段，等其他阶段如poll阶段或者check阶段执行完了，计时器的时间到了或者超了再执行timers\n\n#### 一个面试题\n\n请问下面的代码哪个先执行？\n\n```\nsetTimeout(f1,0)\nsetImmediate(f2)\n```\n\n\\===》 不确定\n\n(1) 大部分情况下是setImmediate先执行，因为大部分时候，Node.js都是停留在poll 阶段，这个时候如果要执行JS就会先经过check阶段，这个阶段就是处理setImmediate\n\n(2) 有一个情况是例外的： Node.js第一次进来时会先看下有没有`timers`\n\n#### 注意\n\n-   大部分时间，Node.js都停留在poll轮询阶段(如果这个阶段比较耗时，那么timers就会自动往后推)\n-   大部分事件都在poll阶段被处理，如文件、网络请求\n\n## 总结\n\n-   用libuv进行异步I/O操作(如：让libuv读文件，文件读完后Node.js接替后面的事情（Node.js可以处理文件了！！！)\n-   用event loop 管理不同事件处理顺序(先polls(操作系统) -> check -> close -> timers -> polls(操作系统) ... 如此循环) (Node.js可以管理事件的顺序了！！！)\n-   用C/C++ 库高效处理DNS/HTTP...(Node.js又可以处理网络了！！！)(因为Node.js是借助C++处理网络请求,因此处理网络请求速度很快)\n-   用bindings 让JS能和C/C++沟通(JS也可以调用C++的代码了！！！)(把C++代码编译成`.node`文件给JS去`require`,require的过程中JS传个函数给C++，C++调用JS)\n-   用V8运行用户写的JS(写好了JS代码在哪里运行JS代码呢？)\n-   用Node.js标准库进化JS代码(都让用户写JS，用户就不爽了，帮用户写好了一些东西，用户直接用)\n-   这就是Node.js\n\n## Node.js工作流程\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c20e18fd09784d1c98234bb6b8e298bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   `Application`就是我们写的JS\n-   我们写JS放到V8上运行\n-   运行的过程中发现JS中写了一个定时器\n-   Node.js调用Node.js的bindings / API ,把定时器放到 Event Loop 中，告诉Event Loop 100毫秒之后要执行一个函数\n-   Event Loop 中有很多不同的队列(如：timers、poll、check等)，Event Loop 会等待恰当的时机去执行队列中的代码\n-   如果此时在poll阶段需要读一个文件，这时Event Loop 就会利用libuv开一个线程去读这个文件(JS不参与)，读完文件之后，操作系统就会返回一个事件给Event Loop,Event Loop 发现文件读好了，就传回给V8,然后就传回到我们写代码的地方\n-   处理网络请求也一样libuv得到了用户传过来的网络请求，就会把它放到 Event Loop 中的poll阶段，poll阶段得到这个请求之后，就会调用JS代码把它在v8中执行，将结果返回到写diamagnetic的地方\n\n**整个过程我们发现：V8 和 libuv是最重要的，而Node.js中的bindings / API 就是V8 和 libuv 中间的桥梁，我们写的代码只是整个平台中很小的一部分，这就是Node.js的工作流程**\n\n我们写的代码 ==> V8上运行 ==> V8通过Node.js的bindings/API ==> 使用libuv提供的功能 / 其他的C++提供的功能完成用户所需要的功能\n\n因此说Node.js不是一门语言，也不是一个框架，它就是一个平台！！！\n\n## Node.js API与学习思路\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf31872700c4f568e80f60c7c2933fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n接下来我们只需要架构图中最上面的一块 Node.js API(官方提供的函数)\n\n## API文档\n\n### 官方地址\n\n-   英文文档 [nodejs.org/api/](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fapi%2F \"https://nodejs.org/api/\")\n-   中文文档 [nodejs.cn/api/](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.cn%2Fapi%2F \"https://nodejs.cn/api/\")\n\n这些文档更像是字典，实在是太多了，没有欲望通过阅读文档去学习\n\n### 民间版本(推荐)\n\n-   devdics.io: [devdocs.io/](https://link.juejin.cn/?target=https%3A%2F%2Fdevdocs.io%2F \"https://devdocs.io/\")\n-   进入之后开启Node.js 10 LTS\n-   搜索功能非常方便\n-   可开启主题\n-   可离线观看\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f34835b506f47dcbce2a1134392d151~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## API到底有哪些功能\n\n重点关注黄色标注的API\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f9a969ef09c4570bd3eafdc041e60da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   **Buffer：** 一小段缓存(大文件一点一点上传)\n-   **Child Processes：** 子进程(Node.js的分身)\n-   **Cluster:** 集群 (把多个Node.js集合到一起，每个Node.js做不同的事情，它们之间的关系就是主要和次要的关系)\n-   **Debugger:** 调试\n-   **Events:** 对应的就是EventHub,发布订阅模式(一个对象提供了on、off、emit)\n-   **File System:** 文件系统，操作文件/目录\n-   **Globals:** 全局变量，如：`__dirname:当前文件所在目录；__filename: 当前文件的文件名`\n-   **Http**\n-   **Path:** 路径\n-   **Query Strings:** 处理URL\n-   **Stream:** 流格式的数据的处理\n-   **Timers:** settimeout 、setInterval、setImmediate\n-   **URL**\n-   **Worker Threads\\***\n\n## 学习路线\n\n### 基础 - Web - 框架\n\n-   先学基础，以任务为导向学习\n-   逐个学习文件、HTTP、Stream等模块\n-   在学Web、数据库、AJAX相关知识\n-   最后学习框架，以项目为导向\n-   以Express为切入点，制作完整网站\n\n### 约定\n\n-   记笔记，写博客\n-   CRM学习法贯穿整个学习过程(copy => run => modify,学习任何技术最快的方式)\n-   学习调试工具和思路', 'public/uploads/1694314400932.png', 3, 2, 2, 263, '2023-09-10 02:53:22', 1);
INSERT INTO `article` VALUES (16, 2, '仿element-ui之封装Message消息提示组件', '### 仿element-ui之封装Message消息提示组件\n\n##### 前言:\n\n大家好~ 我是小瑜,今天给大家带来的是利用Vue3的h函数封装Message消息组件,首先看一下要完成的效果.\n\n![video-2023-06-03-192941.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05931b2b8e164efdb8d87b934c783c26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n在element官网中,消息提示组件是通过引入 import { ElMessage } from \'element-plus\' 实现的,那么一定是引入的某个方法, 但是一上来我们不需要考虑这么多,先把样式功能,利用组件的方法来实现目前的需求\n\n##### 注册组件\n\njs\n\n复制代码\n\n`// components/meesage/index.vue <script lang=\"ts\" setup name=\"Message\"> import { onMounted, ref } from \'vue\' export type Type = \'success\' | \'error\' | \'warning\' const { type = \'success\' } = defineProps<{   type?: Type,   text: string, }>() // 定义一个对象，三种情况的样式，对象key就是类型字符串 const style = {   warning: {     icon: \'icon-warning\',     color: \'#E6A23C\',     backgroundColor: \'rgb(253, 246, 236)\',     borderColor: \'rgb(250, 236, 216)\'   },   error: {     icon: \'icon-shanchu\',     color: \'#F56C6C\',     backgroundColor: \'rgb(254, 240, 240)\',     borderColor: \'rgb(253, 226, 226)\'   },   success: {     icon: \'icon-queren2\',     color: \'#67C23A\',     backgroundColor: \'rgb(240, 249, 235)\',     borderColor: \'rgb(225, 243, 216)\'   } } </script> <template>   <Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <span class=\"text\">{{ text }}</span>     </div>   </Transition> </template> <style scoped lang=\"scss\"> .message {   width: 300px;   height: 50px;   position: fixed;   z-index: 9999;   left: 50%;   margin-left: -150px;![277c93489ae345eef3e93bd5e8cf8](D:\\upupdate\\demo\\vue相关\\vue3-demo\\src\\components\\message\\images\\8277c93489ae345eef3e93bd5e8cf87.png)![277c93489ae345eef3e93bd5e8cf8](D:\\upupdate\\demo\\vue相关\\vue3-demo\\src\\components\\message\\images\\8277c93489ae345eef3e93bd5e8cf87.png)   top: 25px;   line-height: 50px;   padding: 0 25px;   border: 1px solid #e4e4e4;   background: #f5f5f5;   color: #999;   border-radius: 4px;   i {     margin-right: 4px;     vertical-align: middle;   }   .text {     vertical-align: middle;   } } </style>`\n\n样式和简单的功能已经书写好了,我们去导入使用下 ,看一下效果\n\n![8277c93489ae345eef3e93bd5e8cf87.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c92422dbf64fe3878030e08c5149a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n耶,页面上已经可以显示了,但是有两个问题需要我们进行优化\n\n1.  缺少动画效果\n    \n2.  弹层无法关闭\n    \n\n##### 添加动画效果\n\n这里可以使用css去写,可以使用vue提供的**Transition**进行动画的使用, 可能大家都不知道如何使用, 那怎么办? 老规矩 打开vue3文档~\n\n`<Transition>` 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上....\n\nvue3的文档写的非常详细,大家以后遇到不会的可以多去看一看,这里我就不展开,直接写代码\n\njs\n\n复制代码\n\n `<Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <!-- <span class=\"text\"><slot></slot></span> -->       <!-- 改造一下 -->       <span class=\"text\">{{ text }}</span>     </div>  </Transition>`\n\n组件上来是从上往下淡入,并且消失的时候是从下往上淡出,基于效果,开始书写Transition动画css\n\njs\n\n复制代码\n\n`// lang=\"scss\" 这里我用到了scss 所以对重复的属性进行了简写 .down {   &-enter {     &-from {       transform: translate3d(0, -75px, 0);       opacity: 0;     }     &-active {       transition: all 0.5s;     }     &-to {       transform: none;       opacity: 1;     }   }   &-leave {     &-from {       transform: none;       opacity: 1;     }     &-active {       transition: all 0.5s;     }     &-to {       transform: translate3d(0, 75px, 0);       opacity: 0;     }   } }`\n\n写完后发现,并没有出现动画, 这是什么原因? vue3有bug!\n\n原来使用的时候必须要使用\n\n-   由 `v-if` 所触发的切换\n-   由 `v-show` 所触发的切换\n\n基于这个特性,可以配合弹层关闭的效果\n\n##### 弹层自动关闭\n\njs\n\n复制代码\n\n`const { type = \'success\',duration=1500 } = defineProps<{   type?: Type,   text: string,   duration?:number // 传入展示弹层的时间(可选,默认显示1500) }>() const isShow = ref(false) // 当组件被挂载完成就显示 onMounted(()=> {   isShow.value = true   // 当duration时间过后，就隐藏   window.setTimeout(() => {     isShow.value = false   }, duration) }) <Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <!-- <span class=\"text\"><slot></slot></span> -->       <!-- 改造一下 -->       <span class=\"text\">{{ text }}</span>     </div> </Transition>`\n\n此时就完了利用组件完成功能\n\n上面说到,最终是需要通过引入方法的方式来实现,并且使用的方法是\n\njs\n\n复制代码\n\n`// Message({type:\'success\'}, \'登录成功\') // Message({type:\'error\'}, \'登录失败\') // Message.success(\'登录成功\') // Message.error(\'登录失败\')`\n\n这时候就需要使用\n\n首先按照文档学习一下vue3中h函数的使用方法\n\n##### 初识h函数\n\njs\n\n复制代码\n\n`import { h, render } from \"vue\"; // 1. 创建vnode // 第一个参数是标签名称或者是组件名称 // 第二个参数是属性 // 第三个参数是显示内容 const vnode = h(\'h1\', { class: \'title\' }, \'hello world\') // 2. render渲染  // 第一个参数是需要渲染的内容 // 第二个参数是挂载到哪个地方 render(vnode,document.getElementById(\'app\'))`\n\n此时页面中就可以出现h1标签内容为hello world\n\n![9389d344d21e9def282cc7b1cc84f5b.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f66388190b7240b2bc4629807dc64c02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n好, 有了h函数以及render的知识铺垫,我们接着写message组件\n\n##### 利用h函数改造message组件\n\n首先我们在对应的components下的messaga文件夹下创建index.ts文件\n\njs\n\n复制代码\n\n`import { h, render } from \"vue\" import MyMessage from \"@/components/message/message.vue\" // 往body中系只能一个盒子,目的是同时只能出现一次消息弹层 const divContainer = document.createElement(\'div\') as HTMLDivElement divContainer.classList.add(\'message-container\') document.body.appendChild(divContainer) // 按照基本写法的方式书写h函数 // 1. 创建vnode const vnode = h(MyMessage,{type,text}) render(vnode,divContainer)`\n\n此时就完成了基本的功能,但是我们最终要导入方法并 Message({type:\'success\'}, \'登录成功\')来使用,也就是调用函数的方法使用\n\njs\n\n复制代码\n\n`// 使用函数 type Params = {  type: \'success\' | \'error\' | \'warning\',  text: string,  duration?: number } function Message({ type, text, duration = 2000 }: Params) {  // 如果要像elui一样点击就创建 并且多次点击创建多个可以帮创建放在里面  // 往body中新增一个盒子 =>为了代码中  const divContainer = document.createElement(\'div\') as HTMLDivElement  divContainer.classList.add(\'message-container\')  document.body.appendChild(divContainer)  // 1. 创建虚拟dom  // const vNode = h(MyMessage, { type, text })  const vNode = h(MyMessage, { type, text })  // 2. 动态render  render(vNode, divContainer)  clearTimeout(timer)  // 3. 开启一个延时器,到时间就隐藏  timer = setTimeout(() => {   render(null, divContainer)   }, duration) }`\n\n##### 优化message组件的使用\n\n实际开发中,我们更希望利用\n\nMessage.success(\'成功\') Message.error(\'失败\') Message.warning(\'警告\') 来简化代码\n\n这就相当于帮我们再次封装了一层函数的调用\n\njs\n\n复制代码\n\n`// components/message/index.ts Message.success = (text: string, duration?: number) => {  Message({   text,   type: \'success\',   duration  }) } Message.error = (text: string, duration?: number) => {  Message({   text,   type: \'error\',   duration  }) } Message.warning = (text: string, duration?: number) => {  Message({   text,   type: \'warning\',   duration  }) }`\n\n在项目中的使用\n\njs\n\n复制代码\n\n`// 点击按钮 出现message弹层 const showSuccess = () => {   Message.success(\'成功\') } const showError = () => {   Message.error(\'失败\') } const showWarning = () => {   Message.warning(\'警告\') } </script> <template>   <button @click=\"showSuccess\">success</button>   <button @click=\"showError\">error</button>   <button @click=\"showWarning\">warning</button> </template>`\n\n##### 完结:\n\n此时我们就完成了message组件的封装, 在没做之前感觉很难,但是实际动手后,其实也是非常简单的, 重在实践, 除此之外,利用h函数也可以封装dialog弹层,原理也是一样的,大家可以动手写一下~\n\n好啦, 以上就是全部内容, 各位大佬, 可以给小瑜点个赞哦~ 手动撒花_★,°_:.☆(￣▽￣)/$:_.°★_ 。', '', 1, 2, 1, 622, '2023-10-17 15:29:04', 0);
INSERT INTO `article` VALUES (17, 6, '面试官：你可以用 for of 遍历 Object 吗？', '_**本文正在参加[「金石计划」](https://juejin.cn/post/7207698564641996856/ \"https://juejin.cn/post/7207698564641996856/\")**_\r\n\r\n## 前言\r\n\r\n本文属于我的 [前端需要掌握的设计模式](https://juejin.cn/column/7195725894869254202 \"https://juejin.cn/column/7195725894869254202\") 专栏。上一篇：[\\# 说说 观察者模式 和 发布——订阅模式 的区别](https://juejin.cn/post/7216994437246255161 \"https://juejin.cn/post/7216994437246255161\")。\r\n\r\n本文以 **用 `for of`遍历 `Object`** 为引 来聊聊 **迭代器模式**。\r\n\r\n## 什么是迭代器模式\r\n\r\n> 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》\r\n\r\n可以说**迭代器模式**就是为了遍历存在的。提到遍历，大家都对那些手段耳熟能详了，下面我们先简单列一下各种数据类型的遍历：\r\n\r\n### 遍历数组\r\n\r\n1.  `for` 循环\r\n2.  `forEach`\r\n3.  `map`\r\n4.  `reduce`\r\n5.  `keys`\r\n6.  `values`\r\n7.  `for of`\r\n8.  ......\r\n\r\n其中`keys` `values` `for of` 需要`Iterator`支持，后面会介绍`Iterator`\r\n\r\n### 遍历 `Map/Set`\r\n\r\n1.  `keys`\r\n2.  `entries`\r\n3.  `forEach`\r\n4.  ......\r\n\r\n### 遍历 `Object`\r\n\r\n1.  `for in`\r\n2.  先`Object.keys(obj)`得到对象每个属性的数组, 然后使用数组的遍历方法遍历每个 `key`，就能获取 每个 `key` 对应的 `value`\r\n\r\n### `Iterator` 和 `for of`\r\n\r\n`Iterator`是ES6提出的一个接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 `Iterator` 接口，就可以完成遍历操作。\r\n\r\n#### `Iterator` 的作用\r\n\r\n1.  为各种数据结构，提供一个统一的、简便的访问接口。\r\n2.  ES6提出了新的遍历命令`for...of`循环，`Iterator` 接口主要供`for...of`消费。\r\n\r\n#### `Iterator` 的遍历过程\r\n\r\n既然数组是支持`for...of`循环的，那数组肯定部署了 `Iterator` 接口，我们通过它来看看`Iterator` 的遍历过程。\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f73968885ad74dfaa4745e3cdf70ca82~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n从图中我们能看出：\r\n\r\n1.  `Iterator` 接口返回了一个有`next`方法的对象。\r\n2.  每调用一次 next，依次返回了数组中的项，直到它指向数据结构的结束位置。\r\n3.  返回的结果是一个对象，对象中包含了当前值`value` 和 当前是否结束`done`\r\n\r\n## 用 for of 遍历 Object\r\n\r\n回到标题中的问题，我们现在如何去让一个对象也可以用 `for of` 来遍历它呢？ ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d19577c549ca42ffbd080e4242d1d63f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n根据上面讲到的内容，需要给对象也部署 `Iterator` 接口（其实就是在`Object.prototype`上实现一个以`Symbol.iterator`为名的`function`，这个`function`返回一个有`next`方法的对象，每调用一次 `next`, 能够依次返回数组中的项，直到它指向数据结构的结束位置 ）\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`function objectIterator() {   const keys = Object.keys(this)   let index = 0   return {     next: () => {       const done = index >= keys.length       const value = done ? undefined : this[keys[index]]       index++       return {         done,         value       }     }   } } Object.prototype[Symbol.iterator] = objectIterator const obj = {   key: \'1\',   value: \'2\' } for (const iterator of obj) {   console.log(iterator) }`\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f9c632c8cb42649000c90a519f548f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)', '', 1, 5, 0, 450, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (18, 4, '69.9K Star，最强开源内网穿透工具', '作为一名开发者，有很多场景需要用到内网穿透，比如：我们在接入一些大平台做第三方应用时，在本地开发微信公众号工具的时候需要让微信平台能否访问到本地提供的接口。除此之外，还有很多其他场景，也会用到，比如：把放在家里的NAS或服务器暴露到公网上，这样在外面的时候也可以随时随地的访问。\r\n\r\n说到内网传统，TJ君第一个想到的是国内最早的一款知名软件：花生壳。但是今天不是要推荐它，而是要推荐一个更牛的开源项目：frp！该项目目前已经收获了69.9 K Star，在GitHub上获得了极大的认可！\r\n\r\n![](http://blog.didispace.com/images2/202308/tj-opensource-frp/1691035139220.png)\r\n\r\n## 下载安装\r\n\r\nfrp目前已经提供了大部分操作系统的支持版本，通过这个链接：[github.com/fatedier/fr…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffatedier%2Ffrp%2Freleases%25EF%25BC%258C \"https://github.com/fatedier/frp/releases%EF%BC%8C\") 就可以下载到适合你使用的安装。\r\n\r\n![](http://blog.didispace.com/images2/202308/tj-opensource-frp/1691035859920.png)\r\n\r\n以Windows的包为例，解压后可以获得这些内容：\r\n\r\n![](http://blog.didispace.com/images2/202308/tj-opensource-frp/1691036111475.png)\r\n\r\nfrps是服务端程序，frpc是客户端程序。ini文件就是对应的配置文件。\r\n\r\n首发 [blog.didispace.com/tj-opensour…](https://link.juejin.cn/?target=https%3A%2F%2Fblog.didispace.com%2Ftj-opensource-frp%2F \"https://blog.didispace.com/tj-opensource-frp/\")，转载请注明出处\r\n\r\n## 暴露内网服务\r\n\r\n内网穿透的玩法有很多，这里列举一个比较常见的例子。\r\n\r\n比如：我要暴露一个只有自己能访问到服务器。那么可以这样配置：\r\n\r\n配置 frps.ini，并启动服务端 frps\r\n\r\n```\r\n[common]\r\nbind_port = 7000\r\n```\r\n\r\n在需要暴露到外网的机器上部署 frpc，配置如下：\r\n\r\n```\r\n[common]\r\nserver_addr = x.x.x.x \r\nserver_port = 7000\r\n\r\n[secret_ssh]\r\ntype = stcp\r\n# 只有 sk 一致的用户才能访问到此服务\r\nsk = abcdefg\r\nlocal_ip = 127.0.0.1\r\nlocal_port = 22\r\n```\r\n\r\n在想要访问内网服务的机器上也部署 frpc，配置如下：\r\n\r\n```\r\n[common]\r\nserver_addr = x.x.x.x\r\nserver_port = 7000\r\n\r\n[secret_ssh_visitor]\r\ntype = stcp\r\n# stcp 的访问者\r\nrole = visitor\r\n# 要访问的 stcp 代理的名字\r\nserver_name = secret_ssh\r\nsk = abcdefg\r\n# 绑定本地端口用于访问 SSH 服务\r\nbind_addr = 127.0.0.1\r\nbind_port = 6000\r\n```\r\n\r\n把frpc也都启动起来之后，通过 SSH 就可以访问内网机器了\r\n\r\n```\r\nssh -oPort=6000 test@127.0.0.1\r\n```\r\n\r\n## 其他支持\r\n\r\n除了上面的玩法之外，frp还有很多玩法，比如：\r\n\r\n-   自定义域名访问内网的 Web 服务\r\n-   转发 DNS 查询请求\r\n-   转发 Unix 域套接字\r\n-   对外提供简单的文件访问服务\r\n-   为本地 HTTP 服务启用 HTTPS\r\n-   点对点内网穿透\r\n\r\n篇幅有限，具体如何配置这里就不多说了，有需要的读者可以直接查看官方文档，均有详细的服务端客户端配置案例。\r\n\r\n最后，奉上相关链接：\r\n\r\n开源地址：[github.com/fatedier/fr…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffatedier%2Ffrp%2F \"https://github.com/fatedier/frp/\") 文档地址：[gofrp.org/docs/](https://link.juejin.cn/?target=https%3A%2F%2Fgofrp.org%2Fdocs%2F \"https://gofrp.org/docs/\")\r\n\r\n> 欢迎关注我的公众号：程序猿DD。第一时间了解前沿行业消息、分享深度技术干货、获取优质学习资源', '', 2, 2, 1, 100, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (19, 8, 'iOS平台广告归因优化——使用SKAdNetwork归因', '## 什么是SKAdNetwork？\n\nSKAdNetwork是苹果公司推出的一种广告追踪解决方案。它是一种基于隐私保护的广告转化追踪方式，旨在保护用户的隐私，同时仍然允许广告主获得有关其广告活动的有用数据。\n\n使用SKAdNetwork，广告主可以通过苹果服务器获取有关其广告活动的数据，而无需直接访问用户的设备或隐私数据。此外，SKAdNetwork还可以帮助广告主遵守不同国家和地区的隐私保护法规，例如欧盟的GDPR和加拿大的PIPEDA。\n\nSKAdNetwork归因可以帮助应用开发者更好地了解他们的广告系列效果，尤其是在iOS 14及以上版本中，因为苹果公司已经限制了第三方追踪和数据收集。通过使用SKAdNetwork归因，应用开发者可以获取应用的安装和转化数据，而无需使用设备标识符或其他敏感信息。这可以帮助他们更好地优化广告系列，并提高广告投资的回报率。\n\n**SKAdNetwork适用于iOS 14.0以上系统版本，低于iOS 14.0的版本可以考虑使用其他广告归因解决方案，例如IDFA或设备ID。**\n\n## 归因的流程\n\nSKAdNetwork归因的整个流程的简单流程图如下： ![归因流程](https://docs-assets.developer.apple.com/published/bbcf00e8ed/renderedDark2x-1666381218.png) 该流程的主要步骤如下：\n\n1.  Advertiser App中嵌入Ad Network SDK，向用户展示广告，当用户点击广告时，SDK将获取有关广告的信息并提交给Ad Network API。\n2.  Ad Network API将广告数据发送到Apple Search Ads，若广告被识别为带有SKAdNetwork ID的广告，则Apple Search Ads将返回一个带有SKAdNetwork ID的响应。\n3.  Ad Network SDK将SKAdNetwork ID和其他广告数据存储在设备上，并将这些信息发送回Ad Server。\n4.  Ad Server将使用SKAdNetwork ID和其他广告数据来验证应用安装并报告转化事件。\n\n**请注意，该流程提供了有限的归因数据，例如应用安装数量、广告系列ID和转化事件。该流程仅适用于使用SKAdNetwork归因的广告，而不适用于传统的广告追踪方法。由于SKAdNetwork归因不收集个人身份信息，因此无法进行准确的用户追踪和定向。**\n\n**虽然它提供了有限的归因数据，但它可以帮助应用开发者更好地了解他们的广告系列效果，并一定程度上提高广告投资的回报率。**\n\n## SKAdNetwork的使用\n\n要使用SKAdNetwork，需要在以下几个方面进行设置和配置：\n\n1.  在Xcode中添加SKAdNetwork框架。\n2.  在应用程序中实现SKAdNetwork接口，以便在应用程序发生广告转化时报告数据。\n3.  在苹果开发者账户中注册SKAdNetwork ID，并在info.plist文件中添加SKAdNetworkItems数组来包含注册的ID。\n4.  后端需要存储广告主的SKAdNetwork ID和相关数据，处理应用程序报告的广告转化数据，向苹果服务器请求广告数据，以及管理应用程序的SKAdNetwork配置。\n5.  为了获得广告数据和SKAdNetwork数据，可以使用Apple Search Ads API，需要在苹果开发者账户中注册，并在注册后获得API密钥和访问令牌。\n\n以下是使用SKAdNetwork的示例代码：\n\n### 在应用程序中实现SKAdNetwork接口\n\n需要在应用程序中实现SKAdNetwork接口，以便在应用程序发生广告转化时报告数据。以下是一个示例：\n\n```\nimport StoreKit\nclass MyViewController: UIViewController, SKAdNetworkDelegate {\n\noverride func viewDidLoad() {\nsuper.viewDidLoad()\n\n// Set the SKAdNetwork delegate\nSKAdNetwork.registerAppForAdNetworkAttribution()\nSKAdNetwork.registerAppForAdNetworkAttribution(self)\n}\n\nfunc updateConversionValue() {\n// Get the current conversion value\nvar conversionValue = SKAdNetwork.conversionValue\n\n// Update the conversion value\nconversionValue += 1\n\n// Set the new conversion value\nSKAdNetwork.updateConversionValue(conversionValue)\n}\n\n// SKAdNetworkDelegate methods\n\nfunc networkDidBecomeActive() {\n// This method is called when the SKAdNetwork framework becomes active.\n}\n\nfunc didUpdateConversionValue(_ conversionValue: Int, for adNetwork: SKAdNetwork) {\n// This method is called when the conversion value is updated.\n}\n\nfunc didFailWithError(_ error: Error, for adNetwork: SKAdNetwork) {\n// This method is called when an error occurs.\n}\n}\n```\n\n在此示例中，我们创建了一个名为`MyViewController`的视图控制器，并将其设置为SKAdNetwork的委托。此外，我们还实现了`updateConversionValue()`方法，该方法用于更新广告转化值。\n\n在`viewDidLoad()`方法中，我们调用了`registerAppForAdNetworkAttribution()`方法，以便将应用程序注册到SKAdNetwork。我们还将`self`作为SKAdNetwork的委托对象，以便在广告转化事件发生时接收通知。\n\n在`updateConversionValue()`方法中，我们获取当前的广告转化值，并将其增加1。然后，我们使用`updateConversionValue()`方法将新的广告转化值设置回SKAdNetwork。\n\n### 使用Server-to-Server的API获取广告数据\n\n以下是使用Apple Search Ads API获取广告数据和SKAdNetwork数据的PHP示例代码：\n\n```\n<?php\n// 设置授权信息\n$access_token = \"Your access token\";\n$header = array(\n\"Authorization: Bearer \" . $access_token,\n\"Content-Type: application/json\"\n);\n// 设置请求参数\n$data = array(\n\"startTime\" => \"2023-07-20T00:00:00Z\",\n\"endTime\" => \"2023-07-26T00:00:00Z\",\n\"selector\" => array(\n\"orderBy\" => array(\narray(\n\"field\" => \"date\",\n\"sortOrder\" => \"ASCENDING\"\n)\n),\n\"groupBy\" => array(\n\"field\" => \"campaignId\"\n),\n\"conditions\" => array(\narray(\n\"field\" => \"countryCode\",\n\"operator\" => \"EQUALS\",\n\"values\" => array(\"US\")\n)\n)\n),\n\"reportType\" => \"SA_APP_INSTALLS\"\n);\n// 发送API请求\n$url = \"https://api.searchads.apple.com/api/v6/reports\";\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $url);\ncurl_setopt($ch, CURLOPT_POST, true);\ncurl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\ncurl_setopt($ch, CURLOPT_HTTPHEADER, $header);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n$response = curl_exec($ch);\ncurl_close($ch);\n// 解析API响应\n$result = json_decode($response, true);\nif (!empty($result[\'data\'])) {\nforeach ($result[\'data\'] as $row) {\n// 处理每一行数据\n$date = $row[\'metadata\'][\'date\'];\n$campaign_id = $row[\'metadata\'][\'campaignId\'];\n$installs = $row[\'metrics\'][\'installs\'];\n$skadnetwork_data = $row[\'skadNetworkData\'];\n// 处理SKAdNetwork数据\nif (!empty($skadnetwork_data)) {\nforeach ($skadnetwork_data as $network) {\n$skadnetwork_id = $network[\'skadNetworkIdentifier\'];\n$skad_version = $network[\'version\'];\n$conversions = $network[\'conversions\'];\n// 处理每个SKAdNetwork的数据\n}\n}\n}\n}\n```\n\n以上代码演示如何使用PHP发送API请求以获取指定日期范围内的广告数据和SKAdNetwork数据。将`Your access token`替换为自己的访问令牌，并根据需求修改请求参数。\n\n该接口返回的元数据包含有关请求和响应的信息，例如请求的时间范围、请求的字段和筛选条件等。实际的广告数据包含所请求的广告系列、广告组和广告的详细数据，例如展示量、点击量、转化事件、花费、收入等指标。\n\n以下是一个JSON格式的示例API响应：\n\n```\n{\n\"version\": \"4.0\",\n\"ad-network-id\": \"com.example\", \n\"source-identifier\": \"xx\",\n\"app-id\": \"xxxxxxxx\",\n\"transaction-id\": \"xxxxxxxxxxxxxxxx\",\n\"redownload\": false,\n\"source-domain\": \"example.com\",\n\"fidelity-type\": 1,\n\"did-win\": true,\n\"conversion-value\":66,\n\"coarse-conversion-value\": \"high\",\n\"postback-sequence-index\": 0,\n\"attribution-signature\": \"xxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n返回参数说明：\n\n| 参数 | 说明 |\n| --- | --- |\n| version | SKAdNetwork版本号 |\n| ad-network-id | 广告平台ID |\n| source-identifier | 取代 campaign-id 的分层来源标识符。此字符串表示原始值的两位数、三位数或四位数。 |\n| app-id | 投放广告的 App Store App ID |\n| transaction-id | 用于转化验证，去重安装验证回传。 |\n| redownload | 是否重复下载 |\n| source-domain | 仅适用于 Web 广告。SKAdNetwork for Web Ads 投放广告的来源域名，字段值与 source-app-id 是对立，两者只会返回其一。 |\n| fidelity-type | 值为 0 表示页面展示类型的广告；值为 1 表示 StoreKit 渲染的广告或 SKAdNetwork 归因的 Web 广告。 |\n| did-win | 如果广告网络赢得归因，则为 true，如果回传代表没有赢得归因的合格广告效果，则为 false。（注意：只有为 ture 时，才会包含字段 source-app-id 和值。） |\n| conversion-value | 转化值。只有当已安装的 app 提供转换值，并且提供参数满足苹果的隐私阈值时，conversion-value 才会出现在回传中。 |\n| coarse-conversion-value | 粗粒度的转换值，可能的值为字符串 \"low\"、\"medium\" 和 \"high\"。系统在较低的回传数据层以及第二次和第三次回传中发送该值，且不会返回转化值(conversion-value)。 |\n| postback-sequence-index | 可能的整数值 0、1 和 2。分别表示由三个转换窗口产生的回传顺序 |\n| attribution-signature | 需要验证的 Apple 的归因签名。 |\n\n在实践中，开发者需要思考调用的时机，并且对`conversion-value`数值做良好的定义，就能达到衡量广告用户质量的目的。\n\n### 后端需要做些什么\n\n在使用SKAdNetwork时，后端需要做以下工作：\n\n1.  在服务器上存储广告主的SKAdNetwork ID和相关数据。当应用程序报告广告转化时，后端需要检查报告中的SKAdNetwork ID是否与服务器上存储的ID匹配，以确保报告来自有效的广告主。\n2.  处理应用程序报告的广告转化数据。当应用程序报告广告转化时，后端需要处理报告中的转化数据，并将其存储在服务器上。然后，后端可以使用这些数据来分析广告转化和用户行为。\n3.  向苹果服务器请求广告数据。广告主可以向苹果服务器请求广告数据，以了解其广告在应用程序中的效果。后端需要负责向苹果服务器发送请求，并将响应数据返回给广告主。\n4.  管理应用程序的SKAdNetwork配置。后端需要确保应用程序的SKAdNetwork配置与服务器上存储的配置匹配。如果配置不匹配，后端需要通知广告主，以便其更新其应用程序的配置。', 'public/uploads/1694331016751.png', 5, 6, 1, 710, '2023-09-10 07:30:18', 1);
INSERT INTO `article` VALUES (20, 3, '🔥我说MySQL每张表最好不超过2000万数据，面试官让我回去等通知？', '_本文已获得 第十九期技术专题（数据库技术）TOP1 [开奖公示](https://juejin.cn/post/7175026553842040893/ \"https://juejin.cn/post/7175026553842040893/\")_\n\n## 事情是这样的\n\n下面是我朋友的面试记录：\n\n> 面试官：讲一下你实习做了什么。\n> \n> 朋友：我在实习期间做了一个存储用户操作记录的功能，主要是从MQ获取上游服务发送过来的用户操作信息，然后把这些信息存到MySQL里面，提供给数仓的同事使用。\n> \n> 朋友：**由于数据量比较大，每天大概有四五千多万条，所以我还给它做了分表的操作。每天定时生成3张表，然后将数据取模分别存到这三张表里，防止表内数据过多导致查询速度降低**。\n\n这表述，好像没什么问题是吧，别急，接着看：\n\n> 面试官：那你为什么要分三张表呢，两张表不行吗？四张表不行吗？\n> \n> 朋友：因为MySQL每张表最好不超过2000万条数据，否则会导致查询速度降低，影响性能。我们每天的数据大概是在五千万条左右，所以分成三张表比较稳妥。\n> \n> 面试官：还有吗？\n> \n> 朋友： 没有了…… ~你干嘛，哎呦~\n> \n> 面试官：那你先回去等通知吧。\n\n🤣🤣🤣讲完了，看出什么了吗，你们觉得我这位朋友回答的有什么问题吗？\n\n## 前言\n\n很多人说，MySQL每张表最好不要超过2000万条数据，否则就会导致性能下降。阿里的Java开发手册上也提出：单表行数超过 500 万行或者单表容量超过 2GB，**才推荐**进行分库分表。\n\n但实际上，这个2000万或者500万都只是一个大概的数字，并不适用于所有场景，如果盲目的以为表数据只要不超过2000万条就没问题了，很可能会导致系统的性能大幅下降。\n\n实际情况下，每张表由于自身的字段不同、字段所占用的空间不同等原因，它们在最佳性能下可以存放的数据量也就不同。\n\n那么，该如何计算出每张表适合的数据量呢？别急，慢慢往下看。\n\n## 本文适合的读者\n\n阅读本文你需要有一定的MySQL基础，最好对InnoDB和B+树都有一定的了解，可能需要有一年以上的MySQL学习经验（大概一年？），知道 “InnoDB中B+树的高度一般保持在三层以内会比较好” 这条理论知识。\n\n本文主要是针对 “InnoDB中高度为3的B+树最多可以存多少数据” 这一话题进行讲解的。且本文对数据的计算比较严格（至少比网上95%以上的相关博文都要严格），如果你比较在意这些细节并且目前不太清楚的话，请继续往下阅读。\n\n阅读本文你大概需要花费10-20分钟的时间，如果你在阅读的过程中对数据进行验算的话，可能要花费30分钟左右。\n\n___\n\n## 本文思维导图\n\n![InnoDB三层B+数的存储计算-思维导图.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b97b2bc2c124eb28072047638c6ff67~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n___\n\n## 基础知识快速回顾\n\n众所周知，MySQL中InnoDB的存储结构是B+树，B+树大家都熟悉吧？特性大概有以下几点，一起快速回顾一下吧！\n\n_注：下面这这些内容都是精华，看不懂或者不理解的同学建议先收藏本文，之后有知识基础了再回来看_ 。🤣🤣\n\n1.  一张数据表一般对应一颗或多颗树的存储，树的数量与建索引的数量有关，每个索引都会有一颗单独的树。\n    \n2.  聚簇索引和非聚簇索引：\n    \n    主键索引也是聚簇索引，非主键索引都是非聚簇索引。**除格式信息外，两种索引的非叶子节点都是只存索引数据的**，比如索引为id，那非叶子节点就是存的id数据。\n    \n    叶子节点的区别如下：\n    \n    -   聚簇索引的叶子节点一般情况下存的是这条数据的**所有字段信息**。所以我们 `select * from table where id = 1` 的时候，都是要去叶子节点拿数据的。\n    -   非聚簇索引的叶子节点存的是这条数据所对应的**主键和索引列**信息。比如这条非聚簇索引是username，然后表的主键是id，那该非聚簇索引的叶子节点存的就是 username 和 id，而不存其他字段。 相当于是先从非聚簇索引查到主键的值，再根据主键索引去查数据内容，一般情况下要查两次（除非索引覆盖），这也称之为 _**回表**_ ，就有点类似于存了个指针，指向了数据存放的真实地址。\n3.  B+树的查询是从上往下一层层查询的，一般情况下我们认为B+树的高度保持在3层以内是比较好的，也就是上两层是索引，最后一层存数据，这样查表的时候只需要进行3次磁盘IO就可以了(实际上会少一次，因为根节点会常驻内存)，且能够存放的数据量也比较可观。\n    \n    如果数据量过大，导致B+数变成4层了，则每次查询就需要进行4次磁盘IO了，从而使性能下降。**所以我们才会去计算InnoDB的3层B+树最多可以存多少条数据。**\n    \n4.  MySQL每个节点大小默认为16KB，也就是每个节点最多存16KB的数据，可以修改，最大64KB，最小4KB。\n    \n    扩展：那如果某一行的数据特别大，超过了节点的大小怎么办？\n    \n    > MySQL5.7文档的解释是：\n    > \n    > -   对于 4KB、8KB、16KB 和 32KB设置 ，最大行长度略小于数据库页面的一半 。例如：对于默认的 16KB页大小，最大行长度略小于 8KB ，默认32KB的页大小，则最大行长度略小于16KB。\n    >     \n    > -   而对于 64KB 页面，最大行则长度略小于 16KB。\n    >     \n    > -   **如果行超过最大行长度， 则将可变长度列用外部页存储，直到该行符合最大行长度限制。** 就是说把varchar、text这种长度可变的存到外部页中，来减小这一行的数据长度。\n    >     \n    > \n    > ![image-20221108112456250](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa5c3506ed94bb9bddee722c471b9bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    > \n    > 文档地址：[MySQL :: MySQL 5.7 Reference Manual :: 14.12.2 File Space Management](https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-file-space.html \"https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html\")\n    \n5.  MySQL查询速度主要取决于磁盘的读写速度，因为MySQL查询的时候每次只读取一个节点到内存中，通过这个节点的数据找到下一个要读取的节点位置，再读取下一个节点的数据，直到查询到需要的数据或者发现数据不存在。\n    \n    肯定有人要问了，每个节点内的数据难道不用查询吗？这里的耗时怎么不计算？\n    \n    这是因为读取完整个节点的数据后，会存到内存当中，在内存中查询节点数据的耗时其实是很短的，再配合MySQL的查询方式，时间复杂度差不多为 O(log2N)O(log\\_2N) ，相比磁盘IO来说，可以忽略不计。\n    \n\n___\n\n## MySQL InnoDB 节点的储存内容\n\n在Innodb的B+树中，我们常说的节点被称之为 **页(page)**，每个页当中存储了用户数据，所有的页合在一起组成了一颗B+树（当然实际会复杂很多，但我们只是要计算可以存多少条数据，所以姑且可以这么理解😅）。\n\n**页** 是InnoDB存储引擎管理数据库的最小磁盘单位，我们常说每个节点16KB，其实就是指每页的大小为16KB。\n\n这16KB的空间，里面需要存储 **页格式** 信息和 **行格式** 信息，其中行格式信息当中又包含一些元数据和用户数据。所以我们在计算的时候，要把这些数据的都计算在内。\n\n## 页格式\n\n每一页的基本格式，也就是每一页都会包含的一些信息，总结表格如下：\n\n| 名称 | 空间 | 含义和作用等 |\n| --- | --- | --- |\n| `File Header` | 38字节 | 文件头，用来记录页的一些头信息。  \n包括校验和、页号、前后节点的两个指针、  \n页的类型、表空间等。 |\n| `Page Header` | 56字节 | 页头，用来记录页的状态信息。  \n包括页目录的槽数、空闲空间的地址、本页的记录数、  \n已删除的记录所占用的字节数等。 |\n| `Infimum & supremum` | 26字节 | 用来限定当前页记录的边界值，包含一个最小值和一个最大值。 |\n| `User Records` | 不固定 | 用户记录，我们插入的数据就存储在这里。 |\n| `Free Space` | 不固定 | 空闲空间，用户记录增加的时候从这里取空间。 |\n| `Page Directort` | 不固定 | 页目录，用来存储页当中用户数据的位置信息。  \n每个槽会放4-8条用户数据的位置，一个槽占用1-2个字节，  \n当一个槽位超过8条数据的时候会自动分成两个槽。 |\n| `File Trailer` | 8字节 | 文件结尾信息，主要是用来校验页面完整性的。 |\n\n示意图：\n\n![image-20221114001945501](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe4d15193bbd44d49b26456e44931e47~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 页格式这块的内容，我在官网翻了好久，硬是没找到🤧。。。。不知道是没写还是我眼瞎，有找到的朋友希望可以在评论区帮我挂出来😋。\n> \n> 所以上面页格式的表格内容主要是基于一些博客中学习总结的。\n\n另外，当新记录插入到 InnoDB 聚集索引中时，InnoDB 会尝试留出 1/16 的页面空闲以供将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的页大约可用 15/16 的空间。如果以随机顺序插入记录，则页大约可用 1/2 到 15/16 的空间。参考文档：[MySQL :: MySQL 5.7 Reference Manual :: 14.6.2.2 The Physical Structure of an InnoDB Index](https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-physical-structure.html \"https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html\")\n\n除了 `User Records`和`Free Space` 以外所占用的内存是 38+56+26+8\\=12838 + 56 + 26 + 8 = 128 字节，每一页留给用户数据的空间就还剩 16×1516×1024−128\\=1523216 \\\\times \\\\frac{15}{16} \\\\times 1024 - 128 = 15232 字节（保留了1/16）。\n\n当然，这是最小值，因为我们没有考虑页目录。页目录留在后面根据再去考虑，这个得根据表字段来计算。\n\n## 行格式\n\n首先，我觉得有必要提一嘴，MySQL5.6的默认行格式为COMPACT(紧凑)，5.7及以后的默认行格式为DYNAMIC(动态)，不同的行格式存储的方式也是有区别的，还有其他的两种行格式，本文后续的内容主要是基于DYNAMIC(动态)进行讲解的。\n\n> 官方文档链接：[MySQL :: MySQL 5.7 参考手册 :: 14.11 InnoDB 行格式](https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-row-format.html%23innodb-compact-row-format-characteristics \"https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html#innodb-compact-row-format-characteristics\")（包括下面的行格式内容大都可以在里面找到）\n> \n> ![image-20221109115728845](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e093edd09e0f41548c5d36ea43d9f26f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n每行记录都包含以下这些信息，其中大都是可以从官方文档当中找到的。我这里写的不是特别详细，仅写了一些能够我们计算空间的知识，更详细内容可以去网上搜索 “MySQL 行格式”。\n\n| 名称 | 空间 | 含义和作用等 |\n| --- | --- | --- |\n| 行记录头信息 | 5字节 | 行记录的标头信息  \n包含了一些标志位、数据类型等信息  \n如：删除标志、最小记录标志、排序记录、数据类型、  \n页中下一条记录的位置等 |\n| 可变长度字段列表 | 不固定 | 来保存那些可变长度的字段占用的字节数，比如varchar、text、blob等。  \n若变长字段的长度小于 255字节，就用`1字节`表示；  \n若大于 255字节，用`2字节`表示。  \n表字段中有几个可变长字段该列表中就有几个值，如果没有就不存。 |\n| null值列表 | 不固定 | 用来存储可以为null的字段是否为null。  \n每个可为null的字段在这里占用一个bit，就是bitmap的思想。  \n该列表占用的空间是以字节为单位增长的，例如，如果有 9 到 16 个  \n可以为null的列，则使用两个字节，没有占用1.5字节这种情况。 |\n| 事务ID和指针字段 | 6+7字节 | 了解MVCC的朋友应该都知道，数据行中包含了一个6字节的事务ID和  \n一个7字节的回滚指针。  \n如果没有定义主键，则还会多一个6字节的行ID字段  \n当然我们都有主键，所以这个行ID我们不计算。 |\n| 实际数据 | 不固定 | 这部分就是我们真实的数据了。 |\n\n示意图：\n\n![image-20221114002337062](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b77ea4d2c3ca4bd8bc14a2091f81425e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n另外还有几点需要注意：\n\n### 溢出页（外部页）的存储\n\n**注意：这一点是DYNAMIC的特性。**\n\n当使用 DYNAMIC 创建表时，InnoDB 会将较长的可变长度列（比如 VARCHAR、VARBINARY、BLOB 和 TEXT 类型）的值剥离出来，存储到一个**溢出页**上，只在该列上保留一个 20 字节的指针指向溢出页。\n\n> 而 COMPACT 行格式（MySQL5.6默认格式）则是将前 768 个字节和 20 字节的指针存储在 B+ 树节点的记录中，其余部分存储在溢出页上。\n\n列是否存储在页外取决于页大小和行的总大小。当一行太长时，选择最长的列进行页外存储，直到聚集索引记录适合 B+ 树页（文档里没说具体是多少😅）。小于或等于 40 字节的 TEXT 和 BLOB 直接存储在行内，不会分页。\n\n#### 优点\n\nDYNAMIC 行格式避免了用大量数据填充 B+ 树节点从而导致长列的问题。\n\nDYNAMIC 行格式的想法是，如果长数据值的一部分存储在页外，则通常将整个值存储在页外是最有效的。\n\n使用 DYNAMIC 格式，较短的列会尽可能保留在 B+ 树节点中，从而最大限度地减少给定行所需的溢出页数。\n\n### 字符编码不同情况下的存储\n\nchar 、varchar、text 等需要设置字符编码的类型，在计算所占用空间时，需要考虑不同编码所占用的空间。\n\nvarchar、text等类型会有长度字段列表来记录他们所占用的长度，但char是固定长度的类型，情况比较特殊，假设字段 name 的类型为 char(10) ，则有以下情况：\n\n-   对于长度固定的字符编码（比如ASCII码），字段 name 将以固定长度格式存储，ASCII码每个字符占一个字节，那 name 就是占用 10 个字节。\n    \n-   对于长度不固定的字符编码（比如utf8mb4），至少将为 name 保留 10 个字节。如果可以，InnoDB会通过修剪尾部空格空间的方式来将其存到 10 个字节中。\n    \n    如果空格剪完了还存不下，则将尾随空格修剪为 _列值字节长度的最小值_（一般是 1 字节）。\n    \n    列的最大长度为： 字符编码的最大字符长度×N字符编码的最大字符长度 \\\\times N，比如 name 字段的编码为 utf8mb4，那就是 4×104 \\\\times 10。\n    \n-   大于或等于 768 字节的 char 列会被看成是可变长度字段（就像varchar一样），可以跨页存储。例如，utf8mb4 字符集的最大字节长度为 4，则 char(255) 列将可能会超过 768 个字节，进行跨页存储。\n    \n\n> 说实话对char的这个设计我是不太理解的，尽管看了很久，包括官方文档和一些博客🤧，希望懂的同学可以在评论区解惑：\n> \n> 对于长度不固定的字符编码这块，char是不是有点像是一个长度可变的类型了？我们常用的 utf8mb4，占用为 1 ~ 4 字节，那么 char(10) 所占用的空间就是 10 ~ 40 字节，这个变化还是挺大的啊，但是它并没有留足够的空间给它，也没有使用可变长度字段列表去记录char字段的空间占用情况，就很特殊？\n\n___\n\n## 开始计算\n\n好了，我们已经知道每一页当中具体存储的东西了，现在我们已经具备计算能力了。\n\n由于页的剩余空间我已经在上面页格式的地方计算过了，每页会剩余 15232 字节可用，下面我们直接计算行。\n\n## 非叶子节点计算\n\n### 单个节点计算\n\n索引页就是存索引的节点，也就是非叶子节点。\n\n每一条索引记录当中都包含了**当前索引的值** 、 **一个 6字节 的指针信息** 、**一个 5 字节的行标头**，用来指向下一层数据页的指针。\n\n> 索引记录当中的指针占用空间我没在官方文档里找到😭，这个 6 字节是我参考其他博文的，他们说源码里写的是6字节，但具体在哪一段源码我也不知道😭。\n> \n> 希望知道的同学可以在评论区解惑。\n\n假设我们的主键id为 bigint 型，也就是8个字节，那索引页中每行数据占用的空间就等于 8+6+5\\=198 + 6 + 5 = 19 字节。每页可以存 15232÷19≈80115232 \\\\div 19 \\\\approx 801 条索引数据。\n\n那算上页目录的话，按每个槽平均6条数据计算的话，至少有 801÷6≈134801 \\\\div 6 \\\\approx 134 个槽，需要占用 268 字节的空间。\n\n把存数据的空间分一点给槽的话，我算出来大约可以存 787 条索引数据。\n\n如果是主键是 int 型的话，那可以存更多，大约有 993 条索引数据。\n\n### 前两层非叶子节点计算\n\n在 B+ 树当中，当一个节点索引记录为 NN 条时，它就会有 NN 个子节点。由于我们 3 层B+树的前两层都是索引记录，第一层根节点有 NN 条索引记录，那第二层就会有 NN 个节点，每个节点数据类型与根节点一致，仍然可以再存 NN 条记录，第三层的节点个数就会等于 N2N^2。\n\n则有：\n\n-   主键为 bigint 的表可以存放 7872\\=619369787 ^ 2 = 619369 个叶子节点\n-   主键为 int 的表可以存放 9932\\=986049993 ^ 2 = 986049 个叶子节点\n\nOK计算完毕。\n\n## 数据条数计算\n\n### 最少存放记录数\n\n前面我们提到，_最大行长度略小于数据库页面的一半_，之所以是略小于一半，是由于每个页面还留了点空间给_页格式_ 的其他内容，所以我们可以认为每个页面最少能放两条数据，每条数据略小于8KB。如果某行的数据长度超过这个值，那InnoDB肯定会分一些数据到 _溢出页_ 当中去了，所以我们不考虑。\n\n那每条数据8KB的话，每个叶子节点就只能存放 2 条数据，这样的一张表，在主键为 bigint 的情况下，只能存放 2×619369\\=12387382 \\\\times 619369 = 1238738 条数据，也就是**一百二十多万条**，这个数据量，没想到吧🤣🤣。\n\n### 较多的存放记录数\n\n假设我们的表是这样的：\n\n```\n-- 这是一张非常普通的课程安排表，除id外，仅包含了课程id和老师id两个字段\n-- 且这几个字段均为 int 型（当然实际生产中不会这么设计表，这里只是举例）。\n\nCREATE TABLE `course_schedule` (\n  `id` int NOT NULL,\n  `teacher_id` int NOT NULL,\n  `course_id` int NOT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n先来分析一下这张表的行数据：无null值列表，无可变长字段列表，需要算上事务ID和指针字段，需要算上行记录头，那么每行数据所占用的空间就是 4+4+4+6+7+5\\=304 + 4 + 4 + 6 + 7 + 5 = 30 字节，每个叶子节点可以存放 15232÷30≈50715232 \\\\div 30 \\\\approx 507 条数据。\n\n算上页目录的槽位所占空间，每个叶子节点可以存放 502 条数据，那么三层B+树可以存放的最大数据量就是 502×986049\\=494,996,598502 \\\\times 986049 = 494,996,598，**将近5亿条数据**！没想到吧🤡😏。\n\n### 常规表的存放记录数\n\n大部分情况下我们的表字段都不是上面那样的，所以我选择了一场比较常规的表来进行分析，看看能存放多少数据。表情况如下：\n\n```\nCREATE TABLE `blog` (\n  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT \'博客id\',\n  `author_id` bigint unsigned NOT NULL COMMENT \'作者id\',\n  `title` varchar(50) CHARACTER SET utf8mb4 NOT NULL COMMENT \'标题\',\n  `description` varchar(250) CHARACTER SET utf8mb4 NOT NULL COMMENT \'描述\',\n  `school_code` bigint unsigned DEFAULT NULL COMMENT \'院校代码\',\n  `cover_image` char(32) DEFAULT NULL COMMENT \'封面图\',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `release_time` datetime DEFAULT NULL COMMENT \'首次发表时间\',\n  `modified_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  `status` tinyint unsigned NOT NULL COMMENT \'发表状态\',\n  `is_delete` tinyint unsigned NOT NULL DEFAULT 0,\n  PRIMARY KEY (`id`),\n  KEY `author_id` (`author_id`),\n  KEY `school_code` (`school_code`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COLLATE=utf8_general_mysql500_ci ROW_FORMAT=DYNAMIC;\n```\n\n这是我的开源项目“校园博客”（GitHub地址：[github.com/stick-i/scb…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstick-i%2Fscblogs \"https://github.com/stick-i/scblogs\")） 中的博客表，用于存放博客的基本数据。\n\n分析一下这张表的行记录：\n\n1.  行记录头信息：肯定得有，占用5字节。\n2.  可变长度字段列表：表中 `title`占用1字节，`description`占用2字节，共3字节。\n3.  null值列表：表中仅`school_code`、`cover_image`、`release_time`3个字段可为null，故仅占用1字节。\n4.  事务ID和指针字段：两个都得有，占用13字节。\n5.  字段内容信息：\n    1.  `id、author_id、school_code` 均为bigint型，各占用8字节，共24字节。\n    2.  `create_time、release_time、modified_time` 均为datetime类型，各占8字节，共24字节。\n    3.  `status、is_delete` 为tinyint类型，各占用1字节，共2字节。\n    4.  `cover_image` 为char(32)，字符编码为表默认值utf8，由于该字段实际存的内容仅为英文字母（存url的），结合前面讲的_字符编码不同情况下的存储_ ，故仅占用32字节。\n    5.  `title、description` 分别为varchar(50)、varchar(250)，这两个应该都不会产生溢出页（不太确定），字符编码均为utf8mb4，实际生产中70%以上都是存的中文(3字节)，25%为英文(1字节)，还有5%为4字节的表情😁，则存满的情况下将占用 (50+250)×(0.7×3+0.25×1+0.05×4)\\=765(50 + 250) \\\\times (0.7 \\\\times 3 + 0.25 \\\\times 1 + 0.05 \\\\times 4 ) = 765 字节。\n\n统计上面的所有分析，共占用 869 字节，则每个叶子节点可以存放 15232÷869≈1715232 \\\\div 869 \\\\approx 17 条，算上页目录，仍然能放 17 条。\n\n则三层B+树可以存放的最大数据量就是 17×619369\\=10,529,27317 \\\\times 619369 = 10,529,273，**约一千万条数据**，再次没想到吧👴。\n\n## 数据计算总结\n\n根据上面三种不同情况下的计算，可以看出，InnoDB三层B+树情况下的数据存储量范围为 **一百二十多万条** 到 **将近5亿条**，这个跨度还是非常大的，同时我们也计算了一张博客信息表，可以存储 **约一千万条** 数据。\n\n**所以啊，我们在做项目考虑分表的时候还是得多关注一下表的实际情况，而不是盲目的认为两千万数据就是那个临界点。**\n\n如果面试时谈到这块的问题，我想面试官也并不是想知道这个数字到底是多少，而是想看你如何分析这个问题，看你得出这个数字的过程。\n\n如果本文中有任何写的不对的地方，欢迎各位朋友在评论区指正🥰。\n\n## 写在后面的一些话\n\n这篇文章写了整整两周😭😭（虽然第一周在划水），真的超级干货了，前前后后查了好多资料，也看了好多博文，官方文档有些地方写的确实含糊，我看了好久都没看懂😂😂。\n\n**学到知识的小伙伴请一定要给我点个赞啊🤧🤧。**\n\n最后分享一下我在项目中提到的那个开源项目“校园博客”，GitHub地址：[github.com/stick-i/scb…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstick-i%2Fscblogs \"https://github.com/stick-i/scblogs\")\n\n> 项目的技术栈主要是：  \n> 后端 Java + SpringBoot + SpringCloud + Nacos + Getaway + Fegin + MybatisPlus + MySQL + Redis + ES + RabbitMQ + Minio + 七牛云OSS + Jenkins + Docker  \n> 前端 Vue2 + ElementUI + Axios\n\n**目前项目还有很大改进和完善的空间，欢迎各位有意愿的同学参与项目贡献**（目前特缺前端），一起学习一起进步😋。', 'public/uploads/1694314791130.png', 3, 3, 0, 447, '2023-09-10 03:02:48', 1);
INSERT INTO `article` VALUES (21, 7, 'SpringBoot 实现数据加密脱敏（注解 + 反射 + AOP）', '## SpringBoot 实现数据加密脱敏（注解 + 反射 + AOP）\n\n场景：响应政府要求，商业软件应保证用户基本信息不被`泄露`，不能`直接展示`用户手机号，身份证，地址等敏感信息。\n\n根据上面场景描述，我们可以分析出两个点。\n\n-   不被`泄露`说明用户信息应被加密储存；\n-   不能`直接展示`说明用户信息应脱敏展示；\n\n### 解决方案\n\n-   `傻瓜式编程：将项目中关于用户信息实体类的字段，比如姓名，手机号，身份证，地址等，在新增进数据库之前，对数据进行加密处理；在列表中展示用户信息时，对数据库中的数据进行解密脱敏，然后返回给前端；`\n    \n-   `切入式编程：将项目中关于用户信息实体类的字段用注解给标记，新增用户信息实体类（这里我们用UserBO来表示，给UserBO里面的name，phone字段添加@EncryptField），返回用户信息实体类（这里我们用UserDO来表示，给UserDO里面的name，phone字段添加@DecryptField）；然后利用@EncryptField，@DecryptField做为切入点，以切面的形式实现加密，解密脱敏；`\n    \n\n傻瓜式编程不是说傻，而是相当于切入式编程，傻瓜式编程需要对`用户信息相关的所有接口`进行加密，解密脱敏的逻辑处理，这里改动的地方就比较多，风险高，重复操作相同的逻辑，工作量大，后期不好维护；切入式编程只需要对用户信息字段添加注解，对有注解的字段统一进行加密，解密脱敏逻辑处理，操作方便，高聚合，易维护；\n\n### 方案实现\n\n傻瓜式编程没什么难度，这里我给大家有切入式编程来实现；在实现之前，跟大家预热一下注解，反射，AOP的知识；\n\n### 注解实战\n\n###### 创建注解\n\n`创建一个只能标记在方法上的注解：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)         //METHOD 说明该注解只能用在方法上\n@Retention(RetentionPolicy.RUNTIME) //RUNTIME 说明该注解在运行时生效\npublic @interface Encryption {\n\n}\n```\n\n`创建一个只能标记在字段上的注解：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)           //FIELD 说明该注解只能用在字段上\n@Retention(RetentionPolicy.RUNTIME)  //RUNTIME 说明该注解在运行时生效\npublic @interface EncryptField {\n\n}\n```\n\n`创建一个标记在字段上，且有值的注解：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DecryptField {\n// 注解是可以有值的,这里可以为数组,String,枚举等类型\n// DesensitizationEnum desensitizationEnum = field.getAnnotation(DecryptField.class).value(); 这里的field是指当前标记的字段\n    DesensitizationEnum value(); \n}\n```\n\n###### 注解使用\n\n`创建枚举`\n\n```\npackage com.weige.javaskillpoint.enums;\n\npublic enum DesensitizationEnum {\n    name,     // 用户信息姓名脱敏\n    address,  // 用户信息地址脱敏\n    phone;    // 用户信息手机号脱敏\n}\n\n```\n\n`创建UserDO类`\n\n```\npackage com.weige.javaskillpoint.entity;\n\nimport com.weige.javaskillpoint.annotation.DecryptField;\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\nimport com.weige.javaskillpoint.utils.AesUtil;\n\nimport java.lang.reflect.Field;\n\n// 用户信息返回实体类\npublic class UserDO {\n\n    @DecryptField(DesensitizationEnum.name)\n    private String name;\n\n    @DecryptField(DesensitizationEnum.address)\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public UserDO(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public static void main(String[] args) throws IllegalAccessException {\n        // 生成并初始化对象\n        UserDO userDO = new UserDO(\"梦想是什么\",\"湖北省武汉市\");\n        // 反射获取当前对象的所有字段\n        Field[] fields = userDO.getClass().getDeclaredFields();\n        // 遍历字段\n        for (Field field : fields) {\n            // 判断字段上是否存在@DecryptField注解\n            boolean hasSecureField = field.isAnnotationPresent(DecryptField.class);\n            // 存在\n            if (hasSecureField) {\n                // 暴力破解 不然操作不了权限为private的字段\n                field.setAccessible(true);\n                // 如果当前字段在userDo中不为空 即name,address字段有值\n                if (field.get(userDO) != null) {\n                    // 获取字段上注解的value值\n                    DesensitizationEnum desensitizationEnum = field.getAnnotation(DecryptField.class).value();\n                    // 控制台输出\n                    System.out.println(desensitizationEnum);\n                    // 根据不同的value值 我们可以对字段进行不同逻辑的脱敏 比如姓名脱敏-魏*,手机号脱敏-187****2275 \n                }\n            }\n        }\n    }\n}\n```\n\n### 反射实战\n\n`创建UserBO类`\n\n```\npackage com.weige.javaskillpoint.entity;\n\nimport com.weige.javaskillpoint.annotation.EncryptField;\n\nimport java.lang.reflect.Field;\n\n// 用户信息新增实体类\npublic class UserBO {\n    @EncryptField\n    private String name;\n\n    @EncryptField\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public UserBO(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"UserBO{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \", address=\'\" + address + \'\\\'\' +\n                \'}\';\n    }\n\n    public static void main(String[] args) throws IllegalAccessException {\n        UserBO userBO = new UserBO(\"周传雄\",\"湖北省武汉市\");\n        Field[] fields = userBO.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            boolean annotationPresent = field.isAnnotationPresent(EncryptField.class);\n            if(annotationPresent){\n                // 当前字段内容不为空\n                if(field.get(userBO) != null){\n                    // 这里对字段内容进行加密\n                    Object obj = encrypt(field.get(userBO));\n                    // 字段内容加密过后 通过反射重新赋给该字段\n                    field.set(userBO, obj);\n                }\n            }\n        }\n        System.out.println(userBO);\n    }\n\n    public static Object encrypt(Object obj){\n        return \"加密: \" + obj;\n    }\n}\n```\n\n### AOP实战\n\n`切入点：`\n\n```\npackage com.weige.javaskillpoint.controller;\n\nimport com.weige.javaskillpoint.annotation.Encryption;\nimport com.weige.javaskillpoint.entity.UserBO;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/encrypt\")\n@Slf4j\npublic class EncryptController {\n\n    @PostMapping(\"/v1\")\n    @Encryption  // 切入点\n    public UserBO insert(@RequestBody UserBO user) {\n        log.info(\"加密后对象：{}\", user);\n        return user;\n    }\n}\n\n```\n\n`切面：`\n\n```\npackage com.weige.javaskillpoint.aop;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Slf4j\n@Aspect\n@Component\npublic class EncryptAspect {\n\n    //拦截需加密注解 切入点\n    @Pointcut(\"@annotation(com.weige.javaskillpoint.annotation.Encryption)\")\n    public void point() {\n\n    }\n\n    @Around(\"point()\") //环绕通知\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        //加密逻辑处理\n        encrypt(joinPoint);\n        return joinPoint.proceed();\n    }\n\n}\n```\n\n为什么这里要使用AOP：无论是注解，反射，都需要一个启动方法，我上面演示的是通过main函数来启动。使用AOP，项目启动后，只要调用切入点对应的方法，就会根据切入点来形成一个切面，进行统一的逻辑增强；如果大家熟悉SpringMVC，SpringMVC提供了 ResponseBodyAdvice 和 RequestBodyAdvice两个接口，这两个接口可以对请求和响应进行预处理，就可以不需要使用AOP；\n\n### 加密解密脱敏实战\n\n`项目目录：`\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1394ad627d469a965220d417cf3db7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n`pom.xml文件：`\n\n```\n<dependencies>\n        <!--Springboot项目自带 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <!--Springboot Web项目 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!--lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.22</version>\n        </dependency>\n\n        <!-- hutool  -->\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.7.20</version>\n        </dependency>\n\n<!-- 切面 aop  -->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.7</version>\n        </dependency>\n    </dependencies>\n```\n\n###### 实体类\n\n`用户信息新增实体类 ：UserBO`\n\n```\npackage com.weige.javaskillpoint.entity;\n\nimport com.weige.javaskillpoint.annotation.EncryptField;\n\n// 实体类\npublic class UserBO {\n    @EncryptField\n    private String name;\n\n    @EncryptField\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public UserBO(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"UserBO{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \", address=\'\" + address + \'\\\'\' +\n                \'}\';\n    }\n}\n```\n\n`用户信息返回实体类 ：UserDO`\n\n```\npackage com.weige.javaskillpoint.entity;\n\nimport com.weige.javaskillpoint.annotation.DecryptField;\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\n\n// 实体类\npublic class UserDO {\n\n    @DecryptField(DesensitizationEnum.name)\n    private String name;\n\n    @DecryptField(DesensitizationEnum.address)\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public UserDO(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n}\n```\n\n###### 脱敏枚举\n\n```\npackage com.weige.javaskillpoint.enums;\n\npublic enum DesensitizationEnum {\n    name,\n    address,\n    phone;\n}\n\n```\n\n###### 注解\n\n`解密字段注解（字段）：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DecryptField {\n    DesensitizationEnum value();\n}\n```\n\n`解密方法注解（方法 作切入点）：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Decryption {\n\n}\n\n```\n\n`加密字段注解（字段）：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface EncryptField {\n\n}\n```\n\n`加密方法注解（方法 作切入点）：`\n\n```\npackage com.weige.javaskillpoint.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Encryption {\n\n}\n```\n\n###### 控制层\n\n`解密 Controller：`\n\n```\npackage com.weige.javaskillpoint.controller;\n\nimport com.weige.javaskillpoint.annotation.Decryption;\nimport com.weige.javaskillpoint.entity.UserDO;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/decrypt\")\npublic class DecryptController {\n\n    @GetMapping(\"/v1\")\n    @Decryption\n    public UserDO decrypt() {\n        return new UserDO(\"7c29e296e92893476db5f9477480ba7f\", \"b5c7ff86ac36c01dda45d9ffb0bf73194b083937349c3901f571d42acdaa7bae\");\n    }\n\n}\n\n```\n\n`加密 Controller：`\n\n```\npackage com.weige.javaskillpoint.controller;\n\nimport com.weige.javaskillpoint.annotation.Encryption;\nimport com.weige.javaskillpoint.entity.UserBO;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/encrypt\")\n@Slf4j\npublic class EncryptController {\n\n    @PostMapping(\"/v1\")\n    @Encryption\n    public UserBO insert(@RequestBody UserBO user) {\n        log.info(\"加密后对象：{}\", user);\n        return user;\n    }\n}\n```\n\n###### 切面\n\n`解密脱敏切面：`\n\n```\npackage com.weige.javaskillpoint.aop;\n\nimport com.weige.javaskillpoint.annotation.DecryptField;\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\nimport com.weige.javaskillpoint.utils.AesUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\n@Slf4j\n@Aspect\n@Component\npublic class DecryptAspect {\n    //拦截需解密注解\n    @Pointcut(\"@annotation(com.weige.javaskillpoint.annotation.Decryption)\")\n    public void point() {\n\n    }\n\n    @Around(\"point()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        //解密\n        return decrypt(joinPoint);\n    }\n\n    public Object decrypt(ProceedingJoinPoint joinPoint) {\n        Object result = null;\n        try {\n            Object obj = joinPoint.proceed();\n            if (obj != null) {\n                //抛砖引玉 ，可自行扩展其他类型字段的判断\n                if (obj instanceof String) {\n                    decryptValue();\n                } else {\n                    result = decryptData(obj);\n                }\n            }\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    private Object decryptData(Object obj) throws IllegalAccessException {\n\n        if (Objects.isNull(obj)) {\n            return null;\n        }\n        if (obj instanceof ArrayList) {\n            decryptList(obj);\n        } else {\n            decryptObj(obj);\n        }\n        return obj;\n    }\n\n    private void decryptObj(Object obj) throws IllegalAccessException {\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            boolean hasSecureField = field.isAnnotationPresent(DecryptField.class);\n            if (hasSecureField) {\n                field.setAccessible(true);\n                if (field.get(obj) != null) {\n                    String realValue = (String) field.get(obj);\n                    DesensitizationEnum desensitizationEnum = field.getAnnotation(DecryptField.class).value();\n                    String value = (String) AesUtil.decrypt(realValue,desensitizationEnum);\n                    field.set(obj, value);\n                }\n            }\n        }\n    }\n\n    private void decryptList(Object obj) throws IllegalAccessException {\n        List<Object> result = new ArrayList<>();\n        if (obj instanceof ArrayList) {\n            result.addAll((Collection<?>) obj);\n        }\n        for (Object object : result) {\n            decryptObj(object);\n        }\n    }\n\n    private void decryptValue() {\n        log.info(\"根据对象进行解密脱敏，单个字段不做处理！\");\n    }\n\n\n\n}\n\n```\n\n`加密切面：`\n\n```\npackage com.weige.javaskillpoint.aop;\n\nimport com.weige.javaskillpoint.annotation.EncryptField;\nimport com.weige.javaskillpoint.entity.UserBO;\nimport com.weige.javaskillpoint.utils.AesUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Field;\n\n@Slf4j\n@Aspect\n@Component\npublic class EncryptAspect {\n\n    //拦截需加密注解\n    @Pointcut(\"@annotation(com.weige.javaskillpoint.annotation.Encryption)\")\n    public void point() {\n\n    }\n\n    @Around(\"point()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        //加密\n        encrypt(joinPoint);\n        return joinPoint.proceed();\n    }\n\n    public void encrypt(ProceedingJoinPoint joinPoint) {\n        Object[] objects;\n        try {\n            objects = joinPoint.getArgs();\n            if (objects.length != 0) {\n                for (Object object : objects) {\n                    if (object instanceof UserBO) {\n                        Field[] fields = object.getClass().getDeclaredFields();\n                        for (Field field : fields) {\n                            if (field.isAnnotationPresent(EncryptField.class)) {\n                                field.setAccessible(true);\n                                if (field.get(object) != null) {\n                                    // 进行加密\n                                    Object o = field.get(object);\n                                    Object encrypt = AesUtil.encrypt(field.get(object));\n                                    field.set(object, encrypt);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage());\n        }\n    }\n}\n```\n\n###### 工具类\n\n`加密工具类：AesUtil`\n\n```\npackage com.weige.javaskillpoint.utils;\n\nimport cn.hutool.core.util.CharsetUtil;\nimport cn.hutool.crypto.SecureUtil;\nimport cn.hutool.crypto.symmetric.AES;\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\n\npublic class AesUtil {\n\n    // 默认16位 或 128 256位\n    public static String AES_KEY = \"Wk#qerdfdshbd910\";\n\n    public static AES aes = SecureUtil.aes(AES_KEY.getBytes());\n\n    public static Object encrypt(Object obj) {\n        return aes.encryptHex((String) obj);\n    }\n\n    public static Object decrypt(Object obj, DesensitizationEnum desensitizationEnum) {\n        // 解密\n        Object decrypt = decrypt(obj);\n        // 脱敏\n        return DesensitizationUtil.desensitization(decrypt, desensitizationEnum);\n    }\n\n    public static Object decrypt(Object obj) {\n        return aes.decryptStr((String) obj, CharsetUtil.CHARSET_UTF_8);\n    }\n\n}\n\n```\n\n`脱敏工具类：DesensitizationUtil`\n\n```\npackage com.weige.javaskillpoint.utils;\n\nimport cn.hutool.core.util.StrUtil;\nimport com.weige.javaskillpoint.enums.DesensitizationEnum;\n\npublic class DesensitizationUtil {\n\n\n    public static Object desensitization(Object obj, DesensitizationEnum desensitizationEnum) {\n        Object result;\n        switch (desensitizationEnum) {\n            case name:\n                result = strUtilHide(obj, 1);\n                break;\n            case address:\n                result = strUtilHide(obj, 3);\n                break;\n            default:\n                result = \"\";\n        }\n        return result;\n    }\n\n    /**\n     * start从0开始\n     */\n    public static Object strUtilHide(String obj, int start, int end) {\n        return StrUtil.hide(obj, start, end);\n    }\n\n    public static Object strUtilHide(Object obj, int start) {\n        return strUtilHide(((String) obj), start, ((String) obj).length());\n    }\n\n}\n\n```\n\n### 完结\n\n`以上代码不难，大伙复制到本地跑一遍，基本就能理解；愿每一位程序员少走弯路！`', 'public/uploads/1694354524702.png', 3, 2, 1, 851, '2023-09-10 14:02:07', 1);
INSERT INTO `article` VALUES (22, 3, 'Spring框架5.3.27官方文档（中文翻译）—— 核心技术-IoC容器', '# 1\\. IoC容器\n\n> 文章列表\n> \n> -   [Spring框架5.3.27官方文档（中文翻译）—— 概述](https://juejin.cn/post/7237670648989663289 \"https://juejin.cn/post/7237670648989663289\")\n> -   [Spring框架5.3.27官方文档（中文翻译）—— 核心技术-IoC容器（一）](https://juejin.cn/editor/drafts/7238115960350769211 \"https://juejin.cn/editor/drafts/7238115960350769211\")\n> -   [Spring框架5.3.27官方文档（中文翻译）—— 核心技术-IoC容器（二）](https://juejin.cn/editor/drafts/7240380161554939964 \"https://juejin.cn/editor/drafts/7240380161554939964\")\n\n> 原文：[docs.spring.io/spring-fram…](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans \"https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F5.3.27%2Freference%2Fhtml%2Fcore.html%23beans\")\n\n> TODO 文章较长，目前翻译到1.8\n\n## 1.6. 自定义Bean的性质（Customizing the Nature of a Bean）\n\nSpring框架提供了许多接口，您可以使用这些接口来定制bean的性质。本节将它们分类如下：\n\n-   [生命周期回调（Lifecycle Callbacks）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle\")\n-   [`ApplicationContextAware` 和 `BeanNameAware`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware\")\n-   [其它Aware接口（Other `Aware` Interfaces）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#aware-list \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#aware-list\")\n\n### 1.6.1. 生命周期回调（Lifecycle Callbacks）\n\n要与容器对bean生命周期的管理进行交互，您可以实现Spring `InitializingBean`和`DisposableBean`接口。容器对前者调用`afterPropertiesSet()`，对后者调用`destroy()`，让bean在初始化和销毁bean时执行某些操作。\n\n> JSR-250 `@PostConstruct`和`@PreDestroy`注解通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注解意味着您的bean**没有耦合到特定于spring的接口**。详情请参见使用`@PostConstruct`和`@PreDestroy`。如果不希望使用JSR-250注解，但仍希望消除耦合，请考虑初始化方法和销毁方法bean定义元数据。\n\n> 补充\n> \n> 实现`bean`的生命周期管理有三种方式：\n> \n> -   实现`InitializingBean`和`DisposableBean`，存在和Spring接口耦合，不推荐使用\n> -   使用JSR-250的`@PostConstruct`和`@PreDestroy`，将`bean`和特定接口解耦\n> -   使用XML的`init-method`和`destroy-method`\n\n在内部，Spring框架使用`BeanPostProcessor`实现来处理它能找到的任何回调接口并调用适当的方法。如果您需要自定义特性或Spring默认不提供的其他生命周期行为，您可以自己实现`BeanPostProcessor`。有关更多信息，请参见[容器扩展点（Container Extension Points）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension\")。\n\n除了初始化和销毁回调之外，Spring管理的对象还可以实现`Lifecycle`接口，以便这些对象可以参与由容器自己的生命周期的启动和关闭过程。\n\n本节将描述生命周期回调接口。\n\n#### 初始化回调（Initialization Callbacks）\n\n`org.springframework.beans.factory.InitializingBean`接口允许bean在容器在bean上设置了所有必要的属性后执行**初始化工作**。`InitializingBean`接口指定了一个方法:\n\njava\n\n复制代码\n\n`public interface InitializingBean { 	void afterPropertiesSet() throws Exception; }`\n\n我们建议**不要使用**`InitializingBean`接口，因为它**不必要地将代码耦合到Spring**。另外，我们建议使用`@PostConstruct`注解或指定POJO初始化方法。对于基于XML的配置元数据，可以使用`init-method`属性指定具有无效无参数签名的方法的名称。在Java配置中，您可以使用@Bean的`initMethod`属性。参见[接收生命周期回调（Receiving Lifecycle Callbacks）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-java-lifecycle-callbacks \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-java-lifecycle-callbacks\")。考虑下面的例子：\n\nxml\n\n复制代码\n\n`<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>`\n\njava\n\n复制代码\n\n`public class ExampleBean {     public void init() {         // do some initialization work     } }`\n\n上面的示例几乎与下面的示例(包含两个清单)具有完全相同的效果：\n\nxml\n\n复制代码\n\n`<bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>`\n\njava\n\n复制代码\n\n`public class AnotherExampleBean implements InitializingBean {     @Override     public void afterPropertiesSet() {         // do some initialization work     } }`\n\n但是，前面两个示例中的**第一个示例没有将代码与Spring耦合**。\n\n#### 销毁回调（Destruction Callbacks）\n\n实现`org.springframework.beans.factory.DisposableBean`接口可以让bean在包含它的容器被销毁时获得回调。`DisposableBean`接口指定了一个方法：\n\njava\n\n复制代码\n\n`void destroy() throws Exception;`\n\n我们建议您不要使用`DisposableBean`回调接口，因为它**不必要地将代码耦合到Spring**。另外，我们建议使用[`@PreDestroy`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-postconstruct-and-predestroy-annotations \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-postconstruct-and-predestroy-annotations\")注解或指定bean定义支持的泛型方法。对于基于XML的配置元数据，您可以在`<bean/>`上使用`destroy-method`属性。在Java配置中，您可以使用@Bean的`destroyMethod`属性。参见[接收生命周期回调（Receiving Lifecycle Callbacks）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-java-lifecycle-callbacks \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-java-lifecycle-callbacks\")。考虑以下定义:\n\nxml\n\n复制代码\n\n`<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>`\n\njava\n\n复制代码\n\n`public class ExampleBean {     public void cleanup() {         // do some destruction work (like releasing pooled connections)     } }`\n\n上述定义几乎与以下定义具有完全相同的效果：\n\nxml\n\n复制代码\n\n`<bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>`\n\njava\n\n复制代码\n\n`public class AnotherExampleBean implements DisposableBean {     @Override     public void destroy() {         // do some destruction work (like releasing pooled connections)     } }`\n\n但是，前面两个定义中的**第一个没有将代码与Spring耦合**。\n\n> 你可以为一个`<bea>`元素的属性`destroy-method`设置一个具有一个特殊的(推断的)值，该值指示Spring自动检测特定bean类上的公共`close`或`shutdown`方法。(因此，任何实现`java.lang.AutoCloseable`或`java.io.Closeable`的类都将匹配。)您还可以在`<beans>`的`default-destroy-method`属性上设置这个特殊(推断的)值，用于将此行为应用于整个bean集和(请参阅[默认初始化和销毁方法（Default Initialization and Destroy Methods）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods\"))。注意，这是Java配置的默认行为。\n\n#### 默认的初始化和销毁方法（Default Initialization and Destroy Methods）\n\n当您编写不使用Spring特定的`InitializingBean`和`DisposableBean`回调接口的初始化和销毁方法回调时，您通常使用`init()`、`initialize()`、`dispose()`等名称来编写方法。理想情况下，这种生命周期回调方法的名称**在整个项目中是标准化的**，以便所有开发人员使用相同的方法名称并确保一致性。\n\n您可以将Spring容器配置为“查找”每个bean上的命名初始化和销毁回调方法名。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为`init()`的初始化回调，而不必为每个bean定义配置`init-method=\"init\"`属性。在创建bean时，Spring IoC容器调用该方法(并按照前面描述的标准生命周期回调约定)。这个特性还**强制了**初始化和销毁方法回调的**一致命名约定**。\n\n假设初始化回调方法命名为`init()`，而销毁回调方法命名为`destroy()`。然后，您的类类似于以下示例中的类：\n\njava\n\n复制代码\n\n`public class DefaultBlogService implements BlogService {     private BlogDao blogDao;     public void setBlogDao(BlogDao blogDao) {         this.blogDao = blogDao;     }     // this is (unsurprisingly) the initialization callback method     public void init() {         if (this.blogDao == null) {             throw new IllegalStateException(\"The [blogDao] property must be set.\");         }     } }`\n\n然后你可以在bean中使用这个类，如下所示：\n\nxml\n\n复制代码\n\n`<beans default-init-method=\"init\">     <bean id=\"blogService\" class=\"com.something.DefaultBlogService\">         <property name=\"blogDao\" ref=\"blogDao\" />     </bean> </beans>`\n\n在`<beans>`元素配置了`default-init-method`属性后，Spring IoC容器会识别bean类上名称为`init`的方法为初始化回调方法。在创建和组装bean时，如果bean类有这样的方法，将在适当的时候调用它。\n\n通过在顶层`<beans>`元素上使用`default-destroy-method`属性，可以类似地配置销毁方法回调(即在XML中)。\n\n如果现有的bean类已经具有与约定不一致的回调方法，则可以通过使用`<bean>`的`init-method`和`destroy-method`属性指定(在XML中)方法名来覆盖默认值。\n\nSpring容器保证在为bean**提供所有依赖项后立即调用已配置的初始化回调**。因此，**初始化回调**是**在原始bean引用上调用**的，这意味着**AOP拦截器等等还没有应用到bean**上。首先**完全创建目标bean**，然后应用带有其拦截器链的AOP代理(例如)。如果目标bean和代理是分开定义的，那么您的代码甚至可以与原始目标bean交互，而绕过代理。因此，将拦截器应用于`init`方法是不一致的，因为这样做会将**目标bean的生命周期**与**它的代理或拦截器耦合**，并在代码直接与原始目标bean交互时留下奇怪的语义。\n\n#### 组合生命周期机制（Combining Lifecycle Mechanisms）\n\n从Spring 2.5开始，你有三个选项来控制bean的生命周期行为:\n\n-   [`InitializingBean`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-initializingbean \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-initializingbean\")和[`DisposableBean`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-disposablebean \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-lifecycle-disposablebean\")回调接口\n-   自定义`init()`和`destroy()`方法\n-   [@PostConstruct和@PreDestroy注解](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-postconstruct-and-predestroy-annotations \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-postconstruct-and-predestroy-annotations\")。\n\n您可以组合这些机制，用于控制给定的Bean。\n\n> 提示\n> \n> 如果为一个bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名，那么每个配置的方法都按照本文后面列出的顺序运行。但是，如果为这些生命周期机制中的一个以上配置了相同的方法名(例如，为初始化方法配置init())，则该方法将运行一次，如前一节所述。\n\n为同一个bean配置了多个生命周期机制，使用不同的初始化方法，如下所示：\n\n1.  由`@PostConstruct`注解的方法\n2.  由`InitializingBean`回调接口定义的`afterPropertiesSet()`\n3.  一个自定义配置的`init()`方法\n\n销毁方法有着相同的被调用的顺序：\n\n1.  由`@PreDestroy`注解的方法\n2.  由`DisposableBean`回调接口定义的`destroy()`\n3.  一个自定义配置的`destroy()`方法\n\n#### 启动和关闭的回调（Startup and Shutdown Callbacks）\n\n`Lifecycle`接口为任何有自己生命周期需求的对象定义了基本的方法(比如启动和停止一些后台进程):\n\njava\n\n复制代码\n\n`public interface Lifecycle {     void start();     void stop();     boolean isRunning(); }`\n\n任何Spring管理的对象都可以实现`Lifecycle`接口。然后，当`ApplicationContext`本身接收到启动和停止信号时(例如，对于运行时的停止/重启场景)，它将这些调用级联到该上下文中定义的`LifeCycle`实现。它通过委托给一个`LifecycleProcessor`来完成这个任务，如下面的清单所示:\n\njava\n\n复制代码\n\n`public interface LifecycleProcessor extends Lifecycle {     void onRefresh();     void onClose(); }`\n\n注意，`LifecycleProcessor`本身是`Lifecycle`接口的扩展。它还添加了另外两个方法，用于对**正在刷新**和**关闭的上下文**作出反应。\n\n> 请注意，常规的`org.springframework.context.Lifecycle`接口是用于**显式启动**和**停止**通知的普通约定，并不意味着在上下文刷新时自动启动。要对特定bean的自动启动(包括启动阶段)进行**细粒度控制**，可以考虑实现`org.springframework.context.SmartLifecycle`。\n> \n> 另外，请注意，停止通知不能保证在销毁之前出现。在常规关闭时，所有`Lifecycle` bean在传播常规销毁回调之前首先收到一个停止通知。但是，在上下文生命周期中的热刷新或停止刷新尝试时，只调用销毁方法。\n\n**启动和关闭调用的顺序**可能很重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，并在其依赖之前停止。然而，有时直接依赖关系是未知的。您可能只知道某种类型的对象应该先于另一类型的对象开始。在这些情况下，`SmartLifecycle`接口定义了另一个选项，即在其父接口`Phased`上定义的`getPhase()`方法。下面的清单显示了`Phased`接口的定义：\n\njava\n\n复制代码\n\n`public interface Phased {     int getPhase(); }`\n\n`SmartLifecycle`接口的定义如下所示：\n\njava\n\n复制代码\n\n`public interface SmartLifecycle extends Lifecycle, Phased {     boolean isAutoStartup();     void stop(Runnable callback); }`\n\n启动时，**阶段值最低的对象首先启动**。当**停止时**，**遵循相反的顺序**。因此，一个实现`SmartLifecycle`的对象，其`getPhase()`方法返回`Integer.MIN_VALUE`将是**第一个启动**和**最后一个停止**的。相反，阶段值为`IntegerMAX_VALUE`表示对象应该**最后启动**，首先停止(可能是因为它依赖于正在运行的其他进程)。在考虑阶段值时，同样重要的是要知道，任何没有实现`SmartLifecycle`的“正常”生命周期对象的**默认阶段**都是`0`。因此，任何**负阶段值**都表示一个对象应该在这些标准组件之前启动(并在它们之后停止)。相反，对于任何**正阶段值**都是正确的。\n\n`SmartLifecycle`定义的停止方法接受回调。任何实现都必须在该实现的关闭过程完成后调用该回调的`run()`方法。这样可以在必要时进行**异步关闭**，因为`LifecycleProcessor`接口的**默认实现**`DefaultLifecycleProcessor`会一直等待到每个阶段中的一组对象调用该回调的超时时间值。**默认的每阶段超时为30秒**。您可以通过在上下文中定义一个名为`lifecycleProcessor`的bean来覆盖默认的生命周期处理器实例。如果你只想修改超时时间，定义以下内容就足够了：\n\nxml\n\n复制代码\n\n`<bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\">     <!-- timeout value in milliseconds -->     <property name=\"timeoutPerShutdownPhase\" value=\"10000\"/> </bean>`\n\n如前所述，`LifecycleProcessor`接口还定义了用于刷新和关闭上下文的回调方法。后者驱动关闭过程，就像已经显式调用`stop()`一样，但它发生在上下文关闭时。另一方面，“刷新”回调启用了`SmartLifecycle` bean的另一个特性。当上下文被刷新时(在所有对象被实例化和初始化之后)，将调用该回调。此时，默认的生命周期处理器会检查每个`SmartLifecycle`对象的`isAutoStartup()`方法返回的布尔值。如果为`true`，则在这时启动该对象，而不是等待上下文或其自身的`start()`方法的显式调用(与上下文刷新不同，对于标准上下文实现，上下文启动不会自动发生)。阶段（`phase`）值和任何“依赖”关系决定了前面描述的启动顺序。\n\n#### 在非web应用程序中优雅地关闭Spring IoC容器\n\n> 提示\n> \n> 本节仅适用于非web应用。Spring基于web的`ApplicationContext`实现已经有了适当的代码，可以在相关的web应用程序关闭时优雅地关闭Spring IoC容器。\n\n如果您在**非web应用程序**环境中使用Spring的IoC容器(例如，在富客户端桌面环境中)，请向JVM注册一个**关闭钩子**。这样做可以确保优雅的关闭，并在单例bean上调用相关的销毁方法，以便释放所有资源。您仍然必须正确地配置和实现这些销毁回调。\n\n要注册一个关闭钩子，调用`ConfigurableApplicationContext`接口上声明的`registerShutdownHook()`方法，如下例所示：\n\njava\n\n复制代码\n\n`import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public final class Boot {     public static void main(final String[] args) throws Exception {         ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");         // 为上下文添加一个钩子         ctx.registerShutdownHook();         // 运行程序         // main方法关闭，钩子在程序关闭前被调用     } }`\n\n### 1.6.2. `AplicationContextAware`和`BeanNameAware`\n\n当一个`ApplicationContext`创建了一个对象实例来实现`org.springframework.context.ApplicationContextAware`接口时，该实例将被提供一个对该`ApplicationContext`的引用。下面的清单显示了`ApplicationContextAware`接口的定义：\n\njava\n\n复制代码\n\n`public interface ApplicationContextAware {     void setApplicationContext(ApplicationContext applicationContext) throws BeansException; }`\n\n因此，bean可以通过`ApplicationContext`接口或将引用强制转换为该接口的**已知子类**(例如`ConfigurableApplicationContext`，它公开了额外的功能)，以编程方式操作创建它们的`ApplicationContext`。一种用途是对其他bean进行**编程检索**。有时这个功能很有用。但是，一般情况下，您应该**避免使用它**，因为它**将代码耦合到Spring**，并且**不遵循控制反转**样式，在这种样式中，协作器作为属性提供给bean。`ApplicationContext`的其他方法提供对**文件资源**、**发布应用程序事件**和访问`MessageSource`的访问。这些附加功能在[（`ApplicationContext`的附加功能）Additional Capabilities of the `ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction\").中有描述。\n\n**自动装配**是获取对`ApplicationContext`引用的另一种替代方法。传统的构造函数和`byType`自动装配模式(如[自动装配协作器（Autowiring Collaborators）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-autowire \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-autowire\")中所述)可以分别为**构造函数参数**或**setter方法参数**提供`ApplicationContext`类型的依赖。要获得更大的灵活性，包括自动装配字段和多参数方法的能力，请使用**基于注解的自动装配特性**。如果你这样做了，`ApplicationContext`被自动装配到一个字段、构造函数参数或方法参数中，如果有问题的字段、构造函数或方法带有`@Autowired`注解，则该字段、构造函数参数或方法参数需要`ApplicationContext`类型。有关更多信息，请参见[使用@Autowired（Using `@Autowired`）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-autowired-annotation \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-autowired-annotation\")。\n\n当`ApplicationContext`创建一个实现`org.springframework.beans.factory.BeanNameAware`接口的类时，将为该类提供对其关联对象定义中**定义的名称**的引用。下面的清单显示了BeanNameAware接口的定义:\n\njava\n\n复制代码\n\n`public interface BeanNameAware {     void setBeanName(String name) throws BeansException; }`\n\n回调在填充普通bean属性之后调用，但在初始化回调(如InitializingBean.afterPropertiesSet())或自定义初始化方法之前调用。\n\n### 1.6.3. 其它`Aware`接口\n\n除了`ApplicationContextAware`和`BeanNameAware`(前面讨论过)之外，Spring还提供了广泛的`Aware`回调接口，让bean向容器表明它们需要特定的基础设施依赖。作为一般规则，名称指示依赖类型。下表总结了最重要的`Aware`接口：\n\n| 名称 | 注入的依赖 | 解释 |\n| --- | --- | --- |\n| `ApplicationContextAware` | 声明的 `ApplicationContext`. | [`ApplicationContextAware` 和 `BeanNameAware`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware\") |\n| `ApplicationEventPublisherAware` | `ApplicationContext`内部的事件发布者 | [`ApplicationContext`附加的能力](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction\") |\n| `BeanClassLoaderAware` | 用于加载Bean的类的类加载器 | [实例化Bean](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-class \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-class\") |\n| `BeanFactoryAware` | 声明的`BeanFactory`. | [`BeanFactory` API](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-beanfactory \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-beanfactory\") |\n| `BeanNameAware` | 声明的Bean的名称 | [`ApplicationContextAware` 和 `BeanNameAware`](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-aware\") |\n| `LoadTimeWeaverAware` | 为在加载时处理类定义而定义的编织器。 | [在Spring框架中使用AspectJ进行加载时编织](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#aop-aj-ltw \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#aop-aj-ltw\") |\n| `MessageSourceAware` | 解析消息的已配置策略(支持参数化和国际化)。 | [`ApplicationContext`附加的能力](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#context-introduction\") |\n| `NotificationPublisherAware` | Spring JMX通知发布者。 | [通知](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/integration.html#jmx-notifications \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/integration.html#jmx-notifications\") |\n| `ResourceLoaderAware` | 配置用于低级访问资源的加载器。 | [资源（Resources）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#resources \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#resources\") |\n| `ServletConfigAware` | 容器运行的当前`ServletConfig`。只在支持web的Spring `ApplicationContext`中有效。 | [Spring MVC](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/web.html#mvc \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/web.html#mvc\") |\n| `ServletContextAware` | 容器运行的当前ServletContext。只在支持web的Spring ApplicationContext中有效。 | [Spring MVC](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/web.html#mvc \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/web.html#mvc\") |\n\n再次注意，使用这些接口将代码绑定到Spring API，而不遵循控制反转样式。因此，我们建议将它们用于需要**对容器进行编程访问**的基础设施bean。\n\n## 1.7. `bean`定义的继承\n\nbean定义可以包含大量配置信息，包括构造函数参数、属性值和特定于容器的信息，例如初始化方法、静态工厂方法名称等。**子bean定义从父定义继承配置数据**。子定义可以根据需要**覆盖某些值**或**添加其他值**。使用父bean和子bean定义可以节省大量的键入工作。实际上，这是一种**模板形式**。\n\n如果您以编程方式使用`ApplicationContext`接口，则子bean定义由`ChildBeanDefinition`类表示。大多数用户不会在这个级别上使用它们。相反，它们在类(如`ClassPathXmlApplicationContext`)中**声明式地配置bean定义**。当您使用基于xml的配置元数据时，您可以通过使用`parent`属性来指示子bean定义，并将父bean指定为该属性的值。下面的例子展示了如何这样做：\n\nxml\n\n复制代码\n\n`<!-- 在指定了class的情况下，可以不指定abstract --> <bean id=\"inheritedBean\" abstract=\"true\" class=\"TestBean\"> 	<property name=\"name\" value=\"parent\"/>     <property name=\"age\" value=\"1\"/> </bean> <!-- parent指定需要继承配置的bean的名称 --> <bean id=\"inhertedChild\" class=\"ChildBean\" parent=\"inheritedBean\" init-method=\"init\"> <!-- 1 --> 	<!-- 重写属性配置 -->     <property name=\"name\" value=\"override\"/>     <!-- age继承父配置 --> </bean>`\n\n-   `1`处：注意`parent`属性\n\n如果没有指定，则子bean定义使用来自父定义的bean类，但也可以覆盖它。在后一种情况下，**子bean类必须与父bean类兼容**(也就是说，它必须接受父bean类的属性值)。\n\n子bean定义**继承**父bean定义的范围、构造函数参数值、属性值和方法覆盖，并具有添加新值的选项。指定的任何作用域、初始化方法、销毁方法或静态工厂方法设置都将**覆盖相应的父设置**。\n\n其余的设置**总是取自子定义**：依赖、自动装配模式、依赖检查、单例和惰性初始化。\n\n前面的示例通过使用抽象属性显式地将父bean定义标记为`abstract`。如果**父bean定义没有指定类**，则需要显式地将父bean定义标记为`abstract`，如下面的示例所示：\n\nxml\n\n复制代码\n\n`<!-- 在未指定class的情况下，必须指定abstract --> <bean id=\"inheritedBean\" abstract=\"true\" > 	<property name=\"name\" value=\"parent\"/>     <property name=\"age\" value=\"1\"/> </bean> <!-- parent指定需要继承配置的bean的名称 --> <bean id=\"inhertedChild\" class=\"ChildBean\" parent=\"inheritedBean\" init-method=\"init\"> 	<!-- 重写属性配置 -->     <property name=\"name\" value=\"override\"/>     <!-- age继承父配置 --> </bean>`\n\n父bean不能单独实例化，因为它是不完整的，并且它也被显式地标记为`abstract`。当定义是`abstract`的时，它只能作为**纯模板**bean定义使用，作为子定义的父定义。试图单独使用这样的抽象父bean，通过将其作为另一个bean的`ref`属性引用或使用父bean ID进行显式`getBean()`调用**将返回错**误。类似地，容器的内部`preinstantiatesingleton()`方法会**忽略定义为抽象的bean定义**。\n\n> 提示\n> \n> `ApplicationContext`**默认**预实例化所有的单例。因此，重要的是(至少对于单例bean)，如果您有一个(父)bean定义，您打算仅**将其用作模板**，并且该定义指定了一个类，则必须确保将`abstract`属性设置为`true`，否则应用程序上下文将实际(尝试)预实例化抽象bean。\n\n## 1.8. 容器扩展点（Container Extension Points）\n\n通常，应用程序开发人员不需要创建`ApplicationContext`实现类的子类。相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。接下来的几节将描述这些集成接口。\n\n### 1.8.1. 使用`BeanPostProcessor`定制Bean\n\n`BeanPostProcessor`接口定义了回调方法，您可以实现这些方法来提供您自己的(或**覆盖容器的默认值**)**实例化逻辑**、依赖项解析逻辑等等。如果您想在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，您可以插入一个或多个自定义`BeanPostProcessor`实现。\n\n您可以配置多个`BeanPostProcessor`实例，并且可以通过设置`order`属性来控制这些`BeanPostProcessor`实例运行的顺序。只有当`BeanPostProcessor`实现了`Ordered`接口时，你**才能设置这个属性**。如果编写自己的`BeanPostProcessor`，也应该考虑实现`Ordered`接口。要了解更多细节，请参阅[`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html \"https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html\")和 [`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/core/Ordered.html \"https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/core/Ordered.html\")接口的javadoc。参见[程序化注册`BeanPostProcessor`实例（programmatic registration of `BeanPostProcessor` instances）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-programmatically-registering-beanpostprocessors \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-programmatically-registering-beanpostprocessors\")说明。\n\n> 提示\n> \n> `BeanPostProcessor`实例对bean(或对象)实例进行操作。也就是说，Spring IoC容器实例化一个bean实例，然后`BeanPostProcessor`实例完成它们的工作。\n> \n> `BeanPostProcessor`实例的作用域为每个容器。这只有在使用容器层次结构时才有意义。如果在一个容器中定义了`BeanPostProcessor`，则它只对该容器中的bean进行后处理。换句话说，**在一个容器中定义的bean不会被在另一个容器中定义的`BeanPostProcessor`进行后处理**，即使两个容器都是同一层次结构的一部分。\n> \n> 要**更改实际的bean定义**(即定义bean的蓝图)，您需要使用`BeanFactoryPostProcessor`，如[使用`BeanFactoryPostProcessor`自定义配置元数据（Customizing Configuration Metadata with a `BeanFactoryPostProcessor`）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension-factory-postprocessors \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension-factory-postprocessors\")中所述。\n\n`BeanPostProcessor`接口由两个回调方法组成。当这样的类被注册为容器的后处理器（post-processor）时，对于容器创建的每个bean实例，后处理器\n\n-   在**容器初始化方法**(如`InitializingBean.afterPropertiesSet()`或任何声明的`init`方法)**被调用之前**\n-   以及在任何bean**初始化回调之后**都会从容器获得回调。\n\n后处理器可以对bean实例**采取任何操作**，包括完全忽略回调。bean后处理器通常检查回调接口，或者它可能**用代理包装bean**。为了提供代理包装逻辑，一些Spring AOP基础设施类被实现为bean后处理器。\n\n`ApplicationContext`自动检测在实现`BeanPostProcessor`接口的配置元数据中定义的任何bean。`ApplicationContext`将这些bean注册为后处理器，以便稍后在创建bean时调用它们。Bean后处理器**可以以与任何其他Bean相同的方式部署在容器中**。\n\n注意，当通过在配置类上使用`@Bean`工厂方法声明`BeanPostProcessor`时，工厂方法的返回类型应该是实现类本身，或者至少是`org.springframework.beans.factory.config.BeanPostProcessor`接口，清楚地指示该bean的后处理器性质。否则，`ApplicationContext`不能在完全创建它之前按类型自动检测它。由于需要尽早实例化`BeanPostProcessor`以便应用于上下文中其他bean的初始化，因此这种**早期类型检测至关重要**。\n\n> 提示\n> \n> **以编程方式注册BeanPostProcessor实例**\n> \n> 虽然`BeanPostProcessor`注册的推荐方法是通过`ApplicationContext`**自动检测**(如前所述)，但您可以通过使用`addBeanPostProcessor`方法以编程方式在`ConfigurableBeanFactory`上注册它们。当您需要在注册之前评估条件逻辑，或者甚至在层次结构中跨上下文复制bean后处理器时，这是非常有用的。但是请注意，**以编程方式添加的`BeanPostProcessor`实例不遵循`Ordered`接口**。在这里，是**注册的顺序决定了执行的顺序**。还要注意，无论显式排序如何，以编程方式注册的`BeanPostProcessor`实例总是在通过自动检测注册的实例之前被处理。\n\n> **`BeanPostProcessor`实例和AOP自动代理**\n> \n> 实现`BeanPostProcessor`接口的类是特殊的，并且被容器**以不同的方式对待**。所有\\*\\*`BeanPostProcessor`实例和它们直接引用的bean在启动时被实例化\\*\\*，作为`ApplicationContext`特殊启动阶段的一部分。接下来，以排序的方式注册所有`BeanPostProcessor`实例，并将其应用于容器中的所有其他bean。因为AOP自动代理是作为`BeanPostProcessor`本身实现的，**所以`BeanPostProcessor`实例和它们直接引用的bean都不适合自动代理**，因此，没有将切面编织到它们中。\n> \n> 对于任何这样的bean，您应该看到一条信息日志消息:bean someBean不适合被所有`BeanPostProcessor`接口处理(例如:不适合自动代理)。\n> \n> 如果通过使用**自动装配**或`@Resource`(可能会回到自动装配)将bean装配到`BeanPostProcessor`中，那么在搜索类型匹配依赖候选项时，**Spring可能会访问意外的bean**，从而**使它们不适合自动代理**或**其他类型的bean后处理**。例如，如果您有一个带有`@Resource`注解的依赖项，其中字段或setter名称不直接对应于bean声明的名称，并且没有使用name属性，Spring将访问其他bean以**按类型匹配**它们。\n\n下面的例子展示了如何在`ApplicationContext`中编写、注册和使用`BeanPostProcessor`实例。\n\n#### 示例：Hello World, `BeanPostProcessor`风格\n\n第一个示例说明了基本用法。该示例显示了一个自定义`BeanPostProcessor`实现，该实现在容器创建每个bean时调用`toString()`方法，并将结果字符串打印到系统控制台。\n\njava\n\n复制代码\n\n`package scripting; import org.springframework.beans.factory.config.BeanPostProcessor; public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {     // simply return the instantiated bean as-is     public Object postProcessBeforeInitialization(Object bean, String beanName) {         return bean; // we could potentially return any object reference here...     }     public Object postProcessAfterInitialization(Object bean, String beanName) {         System.out.println(\"Bean \'\" + beanName + \"\' created : \" + bean.toString());         return bean;     } }`\n\n下面的bean元素使用了`InstantiationTracingBeanPostProcessor`:\n\nxml\n\n复制代码\n\n`<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:lang=\"http://www.springframework.org/schema/lang\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         https://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/lang         https://www.springframework.org/schema/lang/spring-lang.xsd\">     <lang:groovy id=\"messenger\"             script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\">         <lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/>     </lang:groovy>     <!--     when the above bean (messenger) is instantiated, this custom     BeanPostProcessor implementation will output the fact to the system console     -->     <bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/> </beans>`\n\n注意`InstantiationTracingBeanPostProcessor`是如何定义的。它甚至没有名称，而且因为它是一个bean，所以**可以像其他bean一样对它进行依赖注入**。(前面的配置还定义了一个由Groovy脚本支持的bean。Spring的动态语言支持详见[动态语言支持（Dynamic Language Support）](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/languages.html#dynamic-language \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/languages.html#dynamic-language\")一章。\n\n下面的Java应用程序运行上述代码和配置：\n\njava\n\n复制代码\n\n`import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.scripting.Messenger; public final class Boot {     public static void main(final String[] args) throws Exception {         ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\");         Messenger messenger = ctx.getBean(\"messenger\", Messenger.class);         System.out.println(messenger);     } }`\n\n上述应用程序的输出类似于以下内容：\n\nkotlin\n\n复制代码\n\n`Bean \'messenger\' created : org.springframework.scripting.groovy.GroovyMessenger@272961 org.springframework.scripting.groovy.GroovyMessenger@272961`\n\n#### 示例：`AutowiredAnnotationBeanPostProcessor`\n\n将回调接口或注解与自定义`BeanPostProcessor`实现结合使用是扩展Spring IoC容器的常用方法。一个例子是Spring的`AutowiredAnnotationBeanPostProcessor`——一个随Spring发行版附带的`BeanPostProcessor`实现，它可以**自动装配带注解的字段**、**setter方法**和**任意配置方法**。\n\n### 1.8.2. 使用`BeanFactoryPostProcessor`自定义配置元数据\n\n我们要看的下一个扩展点是`org.springframework.beans.factory.config.BeanFactoryPostProcessor`。这个接口的语义与`BeanPostProcessor`类似，但有一个主要区别：`BeanFactoryPostProcessor`在**bean配置元数据**上操作。也就是说，Spring IoC容器允许`BeanFactoryPostProcessor`读取配置元数据，并可能在容器实例化除`BeanFactoryPostProcessor`实例之外的任何bean之前更改它。\n\n您可以配置多个`BeanFactoryPostProcessor`实例，并且可以通过设置`order`属性来控制这些`BeanFactoryPostProcessor`实例运行的顺序。但是，只有当`BeanFactoryPostProcessor`实现了`Ordered`接口时，您才能设置此属性。如果编写自己的`BeanFactoryPostProcessor`，也应该考虑实现`Ordered`接口。有关更多细节，请参阅[`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html \"https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html\")和[`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/core/Ordered.html \"https://docs.spring.io/spring-framework/docs/5.3.27/javadoc-api/org/springframework/core/Ordered.html\")接口的javadoc。\n\n> 提示\n> \n> 如果希望更改实际的bean实例(即从配置元数据创建的对象)，则需要使用`BeanPostProcessor`(前面在[使用`BeanPostProcessor`定制bean](https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension-bpp \"https://docs.spring.io/spring-framework/docs/5.3.27/reference/html/core.html#beans-factory-extension-bpp\")中描述过)。虽然在技术上可以在BeanFactoryPostProcessor中使用bean实例(例如，通过使用BeanFactory.getBean())，但这样做会导致过早的bean实例化，违反标准的容器生命周期。这可能会导致负面的副作用，比如绕过bean的后期处理。\n> \n> 此外，`BeanFactoryPostProcessor`实例的作用域为每个容器。这只有在使用容器层次结构时才有意义。如果在一个容器中定义了`BeanFactoryPostProcessor`，则它**只应用于该容器中的bean定义**。一个容器中的Bean定义不会被另一个容器中的`BeanFactoryPostProcessor`实例进行后处理，即使两个容器是同一层次结构的一部分。\n\n当在`ApplicationContext`中声明**bean工厂后处理器**时，它会自动运行，以便将更改应用于定义容器的配置元数据。Spring包括许多预定义的**bean工厂后处理器**，如`PropertyOverrideConfigurer`和`PropertySourcesPlaceholderConfigurer`。您还可以使用自定义`BeanFactoryPostProcessor`—例如，注册自定义属性编辑器。\n\n`ApplicationContext`**自动检测**部署到其中实现`BeanFactoryPostProcessor`接口的任何bean。它在适当的时候将这些bean用作bean工厂后处理器。您可以**像部署任何其他bean一样部署这些后处理器bean**。\n\n> 提示\n> \n> 与`BeanPostProcessor`一样，您通常**不希望将`BeanFactoryPostProcessors`配置为延迟初始化**。如果**没有其他bean引用`BeanFactoryPostProcessor`**，则该后处理器**根本不会被实例化**。因此，将其标记为延迟初始化将被忽略，并且即使您在声明`<beans/>`元素时将`default-lazy-init`属性设置为`true`, `BeanFactoryPostProcessor`也将被立即实例化。\n\n#### 示例:类名替换PropertySourcesPlaceholderConfigurer\n\n您可以使用`PropertySourcesPlaceholderConfigurer`通过使用标准Java `Properties`格式将bean定义中的属性值外部化到单独的文件中。这样做使部署应用程序的人员能够**自定义特定于环境的属性**，例如数据库url和密码，而无需修改容器的主XML定义文件的复杂性或风险。\n\nxml\n\n复制代码\n\n`<bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">     <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/> </bean> <bean id=\"dataSource\" destroy-method=\"close\"         class=\"org.apache.commons.dbcp.BasicDataSource\">     <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>     <property name=\"url\" value=\"${jdbc.url}\"/>     <property name=\"username\" value=\"${jdbc.username}\"/>     <property name=\"password\" value=\"${jdbc.password}\"/> </bean>`\n\n该示例显示了从外部`Properties`文件配置的属性。在运行时，将`PropertySourcesPlaceholderConfigurer`应用于**替换数据源的某些属性的元数据**。要替换的值被指定为`${property-name}`形式的占位符，它遵循Ant和log4j以及JSP EL样式。\n\nini\n\n复制代码\n\n`jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root`\n\n因此，`${jdbc.username}` 字符串在运行时被替换为值\'sa\'，对于与属性文件中的键匹配的其他占位符值也是如此。`PropertySourcesPlaceholderConfigurer`检查bean定义的大多数属性和属性中的占位符。此外，还可以自定义占位符前缀和后缀。\n\n使用Spring 2.5中引入的上下文命名空间，您可以使用**专用的配置元素配置属性占位符**。您可以在location属性中以逗号分隔的列表形式提供一个或多个位置，如下例所示:\n\nxml\n\n复制代码\n\n`<context:property-placeholder location=\"classpath:com/something/jdbc.properties\"/>`\n\n`PropertySourcesPlaceholderConfigurer`不仅在您指定的`Properties`文件中查找属性。**默认情况下**，如果在指定的属性文件中找不到属性，它将检查Spring `Environment`属性和常规**Java系统属性。**\n\n您可以使用`PropertySourcesPlaceholderConfigurer`来替换类名，当您必须在运行时**选择特定的实现类**时，这有时很有用。下面的例子展示了如何这样做：\n\nxml\n\n复制代码\n\n`<bean class=\"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer\">     <property name=\"locations\">         <value>classpath:com/something/strategy.properties</value>     </property>     <!-- 配置属性 -->     <property name=\"properties\">         <value>custom.strategy.class=com.something.DefaultStrategy</value>     </property> </bean> <!-- 引用属性，替换类名 --> <bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/>`\n\n> 补充\n> \n> -   properties中配置了key为`custom.strategy.class`，值为`com.something.DefaultStrategy`\n> -   Bean `serviceStrategy`的`class`属性取了`custom.strategy.class`对应的值\n\n如果不能在运行时将类解析为有效类，则在即将创建bean时解析失败，这是在非惰性初始化bean的`ApplicationContext`的`preinstantiatesingleton()`阶段。\n\n#### 示例：`PropertyOverrideConfigurer`\n\n另一个bean工厂后处理程序`PropertyOverrideConfigurer`与`PropertySourcesPlaceholderConfigurer`类似，但与后者不同的是，原始定义可以为bean属性**提供默认值**，也可以根本没有值。如果重写的`Properties`文件没有某个bean属性的条目，则使用默认上下文定义。\n\n注意，bean定义不知道被覆盖了，因此从XML定义文件中不能立即看出正在使用覆盖配置器。如果**多个`PropertyOverrideConfigurer`实例**为同一个bean属性定义了不同的值，由于覆盖机制，**最后一个实例获胜**。\n\n属性文件配置行采用以下格式：\n\nini\n\n复制代码\n\n`beanName.property=value`\n\n下面的清单显示了该格式的一个示例：\n\nini\n\n复制代码\n\n`dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql:mydb`\n\n该示例文件可以与容器定义一起使用，该容器定义包含一个名为`dataSource`的bean，该bean具有`driver`和`url`属性。\n\n也支持**复合属性名**，只要**路径的每个组件**(除了被覆盖的最后一个属性)都是**非空的**(可能是由构造函数初始化的)。在下面的例子中，`tom` bean的`fred`属性的`bob`属性的`sammy`属性被设置为标量值`123`：\n\nini\n\n复制代码\n\n`tom.fred.bob.sammy=123`\n\n> 提示\n> \n> 指定的覆盖值总是文字值。它们不会被翻译成bean引用。当XML bean定义中的原始值指定一个bean引用时，这种约定也适用。\n\n随着Spring 2.5中引入的上下文命名空间，可以**使用专用的配置元素来配置属性重写**，如下面的示例所示：\n\nxml\n\n复制代码\n\n`<context:property-override location=\"classpath:override.properties\"/>`\n\n### 1.8.3. 使用`FactoryBean`定制实例化逻辑（Customizing Instantiation Logic with a `FactoryBean`）\n\n您可以为本身就是工厂的对象实现`org.springframework.beans.factory.FactoryBean`接口。\n\n`FactoryBean`接口是可插入Spring IoC容器实例化逻辑的一个点。如果您有**复杂的初始化代码**，**用Java更好地表示**，而不是(可能)冗长的XML，那么您可以创建自己的`FactoryBean`，在该类中编写复杂的初始化，然后将定制的FactoryBean插入容器中。\n\n`FactoryBean<T>`接口提供三个方法：\n\n-   `T getObject()`：返回此工厂创建的**对象的实例**。实例可能是共享的，这取决于该工厂返回的是单例还是原型。\n-   `boolean isSingleton()`：如果此`FactoryBean`返回单例，则返回`true`，否则返回`false`。此方法的默认实现返回`true`。\n-   `Class<?> getObjectType()`：返回`getObject()`方法**返回的对象类型**，如果事先不知道该类型，则返回null。\n\n`FactoryBean`概念和接口在Spring框架中的**许多地方都有使用**。超过50个`FactoryBean`接口的实现随Spring本身一起发布。\n\n当您需要向容器请求实际的`FactoryBean`实例本身而不是它生成的bean时，请在调用`ApplicationContext`的`getBean()`方法时，在bean的id前面加上`&`符号。\n\n因此，对于id为`myBean`的给定`FactoryBean`，\n\n-   在容器上调用`getBean(“myBean”)`将返回`FactoryBean`的产品，\n-   而调用`getBean(“&myBean”)`将返回`FactoryBean`实例本身。', '', 2, 3, 0, 223, '2023-09-10 03:04:34', 1);
INSERT INTO `article` VALUES (23, 3, '前端中 JS 发起的请求可以暂停吗？', '之前在沸点看到一个哥们提出一个问题。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57c1a4b6b27a46a1ab2f44dee7535654~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个问题非常有意思，我一看到就想了很多可以回复的答案，但是评论区太窄，就直接开一篇文章来写了。\n\n## 审题\n\nJS 发起的请求可以暂停吗？这一句话当中有两个概念需要明确，一是什么样的状态才能称之为 `暂停`？二是 `JS 发起的请求` 是什么？\n\n## 怎么样才算暂停？\n\n`暂停` 全称暂时停止，在已开始未结束的过程中临时停止可以称之为暂停，意味着这个过程可以在某个时间点截断然后在另一个时间点重新续上。\n\n## 请求应该是什么？\n\n这里得先介绍一下 **TCP/IP 网络模型**， 网络模型自上而下分为 应用层、传输层、网络层和网络接口层。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cf299f04a7d467199261ea6211a84e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n上图表示的意思是，每次网络传输，应用数据在发送至目标前都需要通过网络模型一层一层的包装，就像寄快递一样，把要寄的物品先打包好登记一下大小，再装在盒子里登记一下目的地，然后再装到车上，最后送往目的地。\n\n`请求(Request)` 这个概念就可以理解为客户端通过若干次数据网络传输，将单份数据完整发给服务端的行为，而针对某次请求服务端往客户端发送的答复数据则可以称之为 `响应(Response)`。\n\n理论上应用层的协议可以通过类似于标记数据包序列号等等一系列手段来实现暂停机制。但是 TCP 协议**并不支持**，TCP 协议的数据传输是流式的，数据被视为一连串的字节流。客户端发送的数据会被拆分成多个 TCP 段（TCP segments），而这些段在网络中是独立传输的，无法直接控制每个 TCP 段的传输，因此也无法实现暂停请求或者暂停响应的功能。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f98373ecea84e949b5f6b1c50e72834~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 解答提问\n\n如果请求是指网络模型中的一次请求传输，那理所当然是不可能暂停的。\n\n来看看提问者的使用场景 —— `JS 发起的请求`，那么可以认为问题当中的请求，应该是指在 JS 运行时中发起的 `XMLHttpRequest` 或者是 `fetch` 请求，而请求既然已经发起，那问的自然就是 **响应是否能够被暂停** 。\n\n我们都知道像大文件分片上传、以及分片下载之类的功能本质上是将分片顺序定好之后按顺序请求，然后就可以通过中断顺序并记录中断点来实现暂停重传的机制，而单个请求并不具备这样的环境。\n\n### 用 JS 实现 ”假暂停” 机制\n\n虽然不能真正意义上实现暂停请求，但是我们其实可以模拟一个 **假暂停** 的功能，在前端的业务场景上，数据不是收到就可以直接打在客户脸上的（什么光速打击），前端开发者需要对这些数据进行处理之后渲染在界面上，如果我们能在请求发起之前增加一个控制器，在请求回来时，如果控制器为暂停状态则不处理数据，等待控制器恢复后再进行处理，是不是也能到达到目的？让我们试着实现一下。\n\n假如我们使用 `fetch` 来请求。我们可以设计一个控制器 `Promise` 和请求放在一起用 `Promise.all` 包裹，当 `fetch` 完成时判断这个控制器的暂停状态，如果没有被暂停，则控制器也直接 resolve，同时整个 `Promise.all` 也 resolve 抛出。\n\n```\nfunction _request () {\n  return new Promise<number>((res) => setTimeout(() => {\n    res(123)\n  }, 3000))\n}\n\n// 原本想使用 class extends Promise 来实现\n// 结果一直出现这个问题 https://github.com/nodejs/node/issues/13678\nfunction createPauseControllerPromise () {\n  const result = {\n    isPause: false,\n    resolveWhenResume: false,\n    resolve (value?: any) {},\n    pause () {\n      this.isPause = true\n    },\n    resume () {\n      if (!this.isPause) return\n      this.isPause = false\n      if (this.resolveWhenResume) {\n          this.resolve()\n      }\n    },\n    promise: Promise.resolve()\n  }\n  const promise = new Promise<void>((res) => {\n    result.resolve = res\n  })\n  result.promise = promise\n\n  return result\n}\n\nfunction requestWithPauseControl <T extends () => Promise<any>>(request: T) {\n  const controller = createPauseControllerPromise()\n  \n  const controlRequest = request().then((data) => {\n      if (!controller.isPause) controller.resolve()\n      return data\n  }).finally(() => {\n      controller.resolveWhenResume = true\n  })\n  \n  const result = Promise.all([controlRequest, controller.promise]).then(data => {\n      controller.resolve()\n      return data[0]\n  });\n  \n  (result as any).pause = controller.pause.bind(controller);\n  (result as any).resume = controller.resume.bind(controller);\n  \n  return result as ReturnType<T> & { pause: () => void, resume: () => void }\n}\n```\n\n### 用法\n\n我们可以通过调用 `requestWithPauseControl(_request)` 来替代调用 `_request` 使用，通过返回的 `pause` 和 `resume` 方法控制暂停和继续。\n\n```\nconst result = requestWithPauseControl(_request).then((data) => {\n    console.log(data)\n})\n\nif (Math.random() > 0.5) { result.pause() }\n\nsetTimeout(() => {\n    result.resume()\n}, 4000)\n```\n\n## 补充\n\n有些同学错误的认为网络请求和响应是绝对不可以暂停的，我特意在文章前面提到了有关数据传输的内容，并且挂了一句“理论上应用层的协议可以通过类似于标记数据包序列号等等一系列手段来实现暂停机制”，这句话的意思是，如果你魔改 HTTP 或者自己设计实现一个应用层协议（例如像 socket、vmess 这些协议），只要双端支持该协议，是可以实现请求暂停或者响应暂停的，而且这不会影响到 TCP 连接，但是实现暂停机制需要对各种场景和 TCP 策略兜底才能有较好的可靠性。\n\n例如，提供一类控制报文用于控制传输暂停，首先需要对所有数据包的序列号标记顺序，当需要暂停时，发送该序列号的暂停报文给接收端，接收端收到暂停报文就将已接收数据包的块标记返回给发送端等等（这和分片上传机制一样）。\n\n## 最后\n\n以上就是本篇文章分享的全部内容了。\n\n这里是 Xekin（/zi:kin/）。喜欢的掘友们可以点赞关注点个收藏~\n\n最近摸鱼时间比较多，写了一些奇奇怪怪有用但又不是特别有用的工具，不过还是非常有意思的，之后会一一写文章分享出来，感谢各位支持。', 'public/uploads/1694315144360.png', 2, 6, 2, 660, '2023-09-10 03:05:45', 1);
INSERT INTO `article` VALUES (24, 3, '玩转css逐帧动画，纯css让哥哥动起来💃', '## 🎉 一、前言\n\ncss3的`animation`想必大家都知道吧，那 `steps` 逐帧动画你知道吗？对于我来说，实际工作及练习中也很少用到这种跳跃式变化的动画，而它`start`和`end`的解释又比较“不说人话”，以前用到`steps`动画的时候，常常是靠调试，来回设置`start`和`end`，主打的就是瞎猫碰上死耗子。虽然之前也看过关于他们区别的文章，但都是半知半解，过两天就剩零知零解了。最近忙里偷闲，我终于打算一探究竟了，**我倒要看看`start`和`end`到底有什么区别！😠😠😠** 顺便写几个小demo造福一方～\n\n## 🔥 二、逐帧动画介绍\n\nanimation的工作原理是通过将元素的CSS样式从一个状态改变为另一个状态时（我们称为线性变化），浏览器会在每个关键帧之间插入补间动画，所以动画效果是连贯性的，这也就是我们常用的 **`补间动画`**。\n\n而`steps()`逐帧动画则是跳跃式变化，如果说`补间动画`是一个滑坡式的变化，那么`逐帧动画`就是阶梯式变化，它的变化没有中间过程。`补间动画`就像你看的普通动画片，而`逐帧动画`就像是那种定格动画。\n\n**语法:**\n\n```\n  animation-timing-function: steps(number, [end | start])\n```\n\n**参数说明：**\n\n-   `number`参数指定了时间函数中的间隔数量（必须是正整数）\n    \n-   第二个参数是可选的，可设值：`start`和`end`，表示在每个间隔的起点或是终点发生阶跃变化，如果忽略，默认是end。\n    \n\n## 🌈 三、图解图解 `step-start` 和 `step-end` 区别\n\n什么叫在间隔的起点或终点发生变化呢？光看文字十有八九看不懂，下面就用示例代码来说明。\n\n![数字.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f525b46ff70a452c8c4569859d822a02~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n上图是我ps的一张图，尺寸为200\\*750，共5个色块，每个色块高度150。 在示例代码中我将以这张图为背景，每一帧将背景上升一个色块的高度。关键代码如下：\n\n```\nanimation: ani 5s 2s steps(5,start) infinite backwards;\n\n@keyframes ani{\n  100%{\n    background-position:0px -750px;\n  }\n}\n```\n\n🍀 在设置动画前的初始状态：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d26932a1013a4d5d990ed168a8df37e3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n🍀 再直接来看看动画末态的情况： 一个色块150px，所以动画末态是背景图片向上移动750px。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e908afc5ef95456eadbd427d597aedfd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n`为了完整的看到动画效果，我设置了2秒的动画延迟`\n\n🍀 我们设置的steps的第一个参数`number`为 **`5`** ，也就是把整个动画过程切割成5个片段，如下图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7ec2a00da74bc088f59a377c8eca08~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n在实验之前先来分析一下，既然是片段，那必然有片段的起点和终点，可以把补间动画看作点，而逐帧动画则是面。那么这五个片段的起点终点是哪呢，如下图：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13cecb926eb24d41b5a2683a63bf6033~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n你会发现，动画是由6个点切成段五段，带着这个思路开始下面的实验。\n\n🍀 **先来看一下设置 `start` 的效果:**\n\n![tutieshi_640x395_9s (2).gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c438474f6cd6470bb0e915af39064cc4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n你会发现色块1怎么不显示了，甚至在动画没开始前，也就是延时阶段直接就显示了【2】，变化过程为： 2 - 3 - 4 - 5 - 空  \n分析一下就可以想到，`start`是在间隔的起点发生阶越变化，即开始直接就发生变化了，第一段直接阶越到了第一段结束的位置。\n\n🍀 **再来看下设置 `end` 的效果：**\n\n![tutieshi_640x395_10s.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6ff8ac3bbfd4abc9eba88b6b7b3cc2b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n你发现动画变正常了，动画过程是从【1】到【5】。 再分析一下，因为end是在间隔终点发生阶越变化，即每一段都会在其开始阶段进行停留，这一段结束后才会发生变化直接阶越到下一段的开始状态。\n\n🍀 **总结：**\n\n可以将补间动画和 `steps` 逐帧动画类比于`点和线`的区别，steps切割开的每个动画片段就是一条样式不变的线，而线都有首尾两个点。  \n设置 `start` 的 `steps` 的动画总是在开始发生变化，即逐帧显示每一段的终点；  \n而设置 `end` 的 `steps` 的动画总是在结束发生变化，即逐帧显示每一段的起点；\n\n其实很简单的道理，为什么总是记不住呢，因为他和人的惯性思维恰好相反。设置`start`总觉得是显示每一段的开头，可它恰好相反，`start`是开头发生变化，显示的都是每一段的结尾。\n\n🍀 **另一种理解思路：**\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13cecb926eb24d41b5a2683a63bf6033~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n> `steps(number, [end | start])` 是将动画分为`number`段，共有`number + 1`帧画面。`start`就是抛弃第一帧画面执行动画，`end`就是抛弃最后一帧画面执行动画。\n\n**注意：** 第二个参数还有两个内置值，`step-start`等同于`steps(1,start)`，动画分成1步，2个节点，抛弃第一个节点，即显示结尾节点的状态；同理`step-end`等同于`steps(1,end)`。\n\njump-start：在每个时间间隔开始的时候跳1步到下一状态位置； jump-end：在每个时间间隔结束的时候跳1步到下一状态位置； jump-both：在每个时间间隔开始和结束的时候跳1步到下一状态位置，跳步次数会比预设的多一次； jump-none：在每个状态位置停留够一个时间间隔才跳到下一位置，跳步次数会比与预设的少一次\n\n## 🔑 四、思考\n\n上面我只设置了动画100%时的状态，那如果我设置了多个关键帧的状态呢，那还是以整个动画过程切割成`number`段吗？\n\n我们再来做几个实验：\n\n### **实验1:**\n\n我们将动画时间由5秒改成10秒（为了方便观察，我们设置steps第二个参数为end，放弃第一帧画面），然后将原先的动画末态改到50%，并在动画100%时增加边框。·\n\n```\nanimation: ani 10s 2s steps(5,end) infinite backwards;\n\n@keyframes ani{\n  50%{\n    background-position:0px -750px;\n  }\n  100%{\n    border: 100px solid red;\n  }\n}\n```\n\n结果如下图：\n\n![tutieshi_640x395_13s.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e0c34bd342741e18133138dbd26550c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n观察后发现，在10秒的完整动画期间：`background-position`的变化过程是图像显示由1到5，再由5到1，共变化了 **【10】** 次，而我设置的steps的`number`参数是 **【5】**，这就打破了上面我说的以整个动画过程切割成`number`段的假说。  \n同时可以观察到，`border`的变化过程共进行了5次，因为我们只在100%的时候设置了`border`。\n\n> **得出结论：** `steps`的`number`参数并不是将整个动画过程切割成`number`段，而是对于某个css样式来说，每一段关键帧的变化切割成`number`段。\n\n### **实验2:**\n\n假想：上面我们只在动画100%的时候设置了`100px的boder`，如果我们在50%的时候也设置`border`，并且状态恰好是100%的一半，这样对于动画0%到100%是一个流畅的线性变化。请问这时候动画还会被切成5段吗？\n\n![tutieshi_640x395_12s.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/339dd8031f1f4cb18bf207a97fbfcd58~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n观察发现，动画被切成了10段。\n\n> **得出结论：** 即使将几个关键帧的css变化设置的具有规律性，但是`steps`仍然会将每段关键帧的变化切割成`number`段，即只要在这个关键帧里设置了某个css，那么对于这个css来说，这个关键帧就会被视为`steps`动画的端点。\n\n### **实验3:**\n\n那既然每段关键帧都会被`steps`切割成`number`段，那每段的`steps`动画执行的时间怎么划分呢？其实想想就能想到，应该是按照关键帧占整个动画过程的比例分割整个动画时间。  \n如下图设置`boder`：【0%-50%】宽度由0到100，【50%-75%】宽度由100到0，【75%-100%】宽度由0到100\n\n![tutieshi_640x395_10s.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbf79107ef5741e0bef43854922cb505~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n很明显可以观察到，border宽度变化的时间为 2:1:1，即验证了我上面的推论。\n\n## ⚔ 五、steps() 动画实践\n\n下面我举几个steps() 动画的使用场景。\n\n### 1\\. 一张图实现坤坤经典动作--铁山靠\n\n用一张人物动作关键帧的长图，和上面的案例一样，通过修改背景图片位置，实现动物或人物的动作变化。作为一名蒸爱粉，我给哥哥做了一个跳舞的动画：\n\n![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC)\n\n### 2\\. 打字机效果--“只因你太美”\n\n打字机的原理是用一个和文字总宽度一样的div覆盖文字，并用这个div的`边框`设置steps()动画实现光标效果，然后减小div宽度（每一帧减小一个文字的宽度），让下面文字漏出来就好了～\\\\\n\n**点击运行查看效果～**\n\n![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC)\n\n### 3\\. 纯css实现倒计时\n\n我这里提供了两种实现方案，准确来说是三种：\n\n**方案1: var() css变量 + `counter-reset`计数器 + `@property`规则 + steps()逐帧动画**  \n使用css变量和`counter-reset`计数器来实现倒计时的数字，只要设置动画，在5秒内将变量由5变为0即可实现倒计时，但是变量的变化是不会被浏览器添加`补间动画`的，即只会在5秒后直接变成0，而不会有中间，5-4-3-2-1-0的过程，这时我们再利用`@property`关键字为这个变量配置规则，实现数字变化的动态过程！  \n而最后出现的 \"Go\" 可以利用`step-end`逐帧动画，在5秒后将文字修改成 \"Go\"，或者利用`@counter-style`关键字自定义计数器规则，在变量变化到0的时候，定义一个`symbols`符号。\n\n> 如果你不了解`counter-reset`、`@property`和`@counter-style`，可以查看以下两篇文章：  \n> [CSS counter-reset 属性](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fcssref%2Fpr-gen-counter-reset.html \"https://www.runoob.com/cssref/pr-gen-counter-reset.html\")  \n> [mdn 关于@property API 说明](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2F%40property \"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@property\") [mdn 关于@counter-style 说明](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2F%40counter-style \"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style\")\n\n**点击运行查看效果～**\n\n![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC)\n\n**方案2: 只用steps()逐帧动画**  \n其实这个就很简单了，所有的数字和最后的 \"GO\" 都在html里写死并设置等高，然后就可以向上面移动图片位置一样移动这些数字进行显示了。\n\n**点击运行查看效果～**\n\n![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC)\n\n### 4\\. 其他应用场景\n\n平常工作中可以用到`steps()`逐帧动画的场景也有很多：\n\n-   例如在延迟n秒后修改元素某个样式，常规可能需要用js写个延时器动态修改它的css，这完全可以用`step-start`动画代替；\n-   再比如除了上面那种大屏的倒计时，普通的时分秒倒计时也可以用`steps`代替js实现，实现原理也简单，就是将 0-9 制作成一张精灵图，然后时分秒每个单位都各自用这个精灵图当作背景，例如对于秒的数字，可以设置动画时长为10s，动画函数为`steps(10,start)`，这样每次数字变化都是 1s，同理对于分的数字，设置动画时长为 600s,动画函数为`steps(10,start)`，这样每次数字变化都是 60s。\n\n## 💥 六、写在最后\n\n我是喜欢归纳总结前端相关知识的前端阿彬，尽力持续输出原创优质文章，欢迎点赞关注😘\n\n**往期文章**：  \n[\\# 🕸2023 前端 SEO 无死角解读](https://juejin.cn/spost/7241813423460581435 \"https://juejin.cn/spost/7241813423460581435\")  \n[\\# 我给自己搭建的前端导航网站，你们都别用🤪](https://juejin.cn/post/7239516348434677818 \"https://juejin.cn/post/7239516348434677818\")  \n[\\# 2023 最新最细 vite+vue3+ts 多页面项目架构，建议收藏备用！](https://juejin.cn/post/7223286759630127159 \"https://juejin.cn/post/7223286759630127159\")  \n[\\# 浅谈 强制缓存/协商缓存 怎么用？](https://juejin.cn/post/7215056364166479931 \"https://juejin.cn/post/7215056364166479931\")  \n[\\# 2023 前端性能优化清单](https://juejin.cn/post/7214026775142760505 \"https://juejin.cn/post/7214026775142760505\")', 'public/uploads/1694316146929.webp', 2, 3, 0, 157, '2023-09-10 03:22:29', 1);
INSERT INTO `article` VALUES (25, 3, '某不存在的视频网站性能拉跨，Chrome 团队出手相助…', '> 首发于公众号 [前端从进阶到入院](https://link.juejin.cn/?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F4%2F5%2F17149cbcaa96ff26~tplv-t2oaga2asx-image.image \"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17149cbcaa96ff26~tplv-t2oaga2asx-image.image\")，欢迎关注。\n\nHi，大家好我是 ssh，今天和大家分享一篇文章，讲述了 Chrome 团队和 Youtube 共同配合，优化了油管这个世界上并不存在的视频网站的性能。\n\n-   首屏速度更快了\n-   播放器组件大幅度优化\n-   通过 Core Web Vitals 指标的页面比例更高\n\n从这篇分享 [Building a Better Web - Part 1: A faster YouTube on web](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fbetter-youtube-web-part1%2F \"https://web.dev/better-youtube-web-part1/\")中，你能学习到世界上顶尖的团队是如何相互配合，优化世界各地用户的性能体验。\n\nChrome 团队经常谈到“建设更棒的 Web”，这啥意思呢？Web 体验应该[快速](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fwhy-speed-matters%2F \"https://web.dev/why-speed-matters/\")、[可访问](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Faccessibility%2F \"https://web.dev/accessibility/\")，并在用户最需要的时候具备[网络可靠性](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Freliable%2F \"https://web.dev/reliable/\")。\n\n[吃自己的狗食（Eating Your Own Dog Food）](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FEating_your_own_dog_food \"https://en.wikipedia.org/wiki/Eating_your_own_dog_food\")是谷歌文化的一部分，所以 Chrome 团队与 YouTube 合作，在“建设更棒的 Web”的新系列中分享了在这个过程中学到的经验教训。这个系列的第一部分将深入探讨 YouTube 如何建立更迅捷的 Web 体验。\n\n![PageSpeed Insights显示YouTube移动网页的Chrome用户体验报告数据通过了核心Web体验度量标准。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa1dbfe9f07c468f97c510d018a8c7c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nYouTube 移动观看页**顺利超过**[Core Web Vitals](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fvitals \"https://web.dev/vitals\")设立的阈值。\n\n**建设更快的 Web**\n\n对于 YouTube 来说，性能和网页上视频和其他内容(如推荐和评论)的加载速度有关。性能也由 YouTube 响应用户交互(如搜索、播放器控制、点赞和分享)的速度决定。\n\n巴西、印度和印度尼西亚等发展中市场对 YouTube 移动网页很重要。由于这些地区的许多用户设备和网速都比较拉跨，确保快速流畅的体验就很关键了。\n\n为了向所有用户提供良好的体验，YouTube 着手通过懒加载和代码现代化来改进[Core Web Vitals](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fvitals \"https://web.dev/vitals\")等性能指标。\n\n**改进 Core Web Vitals**\n\n为了判断需要改进哪些领域，YouTube 团队使用[Chrome 用户体验报告(CrUX)](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fcrux%2F \"https://developer.chrome.com/docs/crux/\")来查看移动端实际的用户在视频观看页面和搜索结果页面的体验，得知了他们的 Core Web Vitals 有很大的改进空间，在某些情况下，[最大内容渲染时间(LCP)](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Flcp%2F \"https://web.dev/lcp/\")指标达到 4-6 秒。这远高于他们 2.5 秒的目标。\n\n![显示YouTube观看页面通过率以及YouTube源FCP和LCP图表](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cef9bbcf2a84de2866b9317ef3850a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n为了确定改进的细节，他们用[Lighthouse](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Flighthouse%2Foverview%2F \"https://developer.chrome.com/docs/lighthouse/overview/\")来审查 YouTube 观看页面，果然得到了一个较低的 Lighthouse([实验室](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Flab-and-field-data-differences%2F%23lab-data \"https://web.dev/lab-and-field-data-differences/#lab-data\"))分数，首次内容渲染时间（FCP）为 3.5 秒，最大内容渲染时间（LCP） 为 8.5 秒。\n\n![YouTube移动网页的Lighthouse报告](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7226323e5a7245808768c4f018cd4a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nChrome 将 FCP 的目标设置为 1.8 秒，将 LCP 的目标设置为 2.5 秒作为黄金标准。FCP 和 LCP 分别为 3.5 秒和 8.5 秒，明显偏黄和偏红。\n\n为了优化 FCP 和 LCP，YouTube 团队进行了几项实验，得到两个重大的发现。\n\n1.  第一个发现是，把视频播放器的 HTML 代码移动到视频播放相关的 JS 脚本之上，可以提高性能。实验室测试（Labs test）表明，这可以将 FCP 和 LCP 从 4.4 秒改善到 1.1 秒。\n    \n2.  第二个发现是 LCP 只[考虑](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Flcp%2F%23what-elements-are-considered \"https://web.dev/lcp/#what-elements-are-considered\")`<video>`元素的海报图，而不考虑视频流本身的帧。YouTube 一直在优化视频开始播放的最快时间，为了改进 LCP，团队开始优化他们可以交付海报图的速度。他们尝试了几种海报图的变体，并选择了在用户测试中得分最高的一种。作为这项工作的结果，FCP 和 LCP 都取得了显著改进，实际场景中的 LCP 从 4.6 秒提高到 2.0 秒。\n    \n\n![控制组、实验A(缩略图)和实验B(黑色缩略图)的移动网页观看页面LCP实验](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcf9c13c9464662bbc5f6bd35c5e94b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n在实验测试中，我们观察到这个更改落地后，FCP 和 LCP 从 4.4 秒提升到 1.1 秒。\n\n-   实验 A：用实际的视频暂停截图作为海报图，用户表现不佳，导致用户活跃下降。\n    \n-   实验 B：使用实心黑色缩略图作为海报，结果很好，用户发现从实心黑色过渡到视频的第一帧，体验是很平稳的。\n    \n\n![2021年7月，黑色缩略图的方案部署成功，如上面的RUM分析所示，FCP和LCP有显著改进。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb3aba154ca46f888de10fc3a72528c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n2021 年 7 月，黑色缩略图的方案部署成功，如上面的 RUM 分析所示，FCP 和 LCP 有显著改进。\n\n在将这些优化引入所有平台的同时，YouTube 还利用了新的[`fetchpriority`属性](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Ffetch-priority%2F \"https://web.dev/fetch-priority/\")，我们将它与`<link rel=preload>`一起使用，以优先发现和加载海报图：\n\n```\n<link as=\"image\" rel=\"preload\" href=\"poster.jpg\" fetchpriority=\"high\" />\n```\n\n虽然这些优化确实改进了 LCP，但团队觉得 LCP 指标的当前定义并没有完全捕获用户视角中的“主要内容”何时加载——这是 LCP 的目标。\n\n为了解决这些问题，YouTube 团队的成员与 Chrome 团队的成员合作，探索改进 LCP 指标的方式，以解决他们的用例。在考虑了几个选项的可行性和影响后，两支团队得出的[建议](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fw3c%2Flargest-contentful-paint%2Fissues%2F85 \"https://github.com/w3c/largest-contentful-paint/issues/85\")是将视频元素的第一帧的绘制时间视为 LCP 候选项。\n\n一旦这个变化在 Chrome 中落地，YouTube 团队就能开心的继续优化 LCP 了。这个指标更加接近用户真实的体验。\n\n**模块化与懒加载**\n\nYouTube 页面包含许多直接加载的模块。为了优化 50 多个组件的渲染方式，团队建立了一个组件到 JS 模块的 map，这个 map 将告诉客户端加载哪些模块。通过将组件标记为懒加载，JS 模块会晚一些加载，从而减少页面的初始加载时间和未使用 Javascript 的数量。\n\n然而，在实现懒加载后，团队注意到懒加载的组件及其依赖项会在次优级时间批量加载。\n\n为了解决这个问题，团队确定了视图中所需的最小组件集，并将它们打包在一个 Web 请求中。结果是页面速度得到改善，JavaScript 解析时间减少，最终得到了更好的初始渲染时间。\n\n**跨组件状态管理**\n\nYouTube 由于其播放器控件而遇到性能问题，特别是在较旧的设备上。代码分析显示，播放器(允许用户控制播放速度、进度等功能)随着时间的推移变得**过度组件化**了。\n\n![YouTube播放器和控件可视化](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a16f51edd15490c91b54869df6769ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nYouTube 视频播放器允许用户控制播放速度、跟踪进度、跳过部分等。当用户点击特定控件时，状态变化必须传达给其他控件，例如，用户点击进度条必须与播放头部、字幕等控件共享。\n\n实验性能测试运行中，每次触摸移动进度条事件会额外触发两次样式重绘，花费 21.17 毫秒。随着时间推移添加新控件，去中心化控制的模式通常会导致循环依赖和内存泄漏，对观看页面性能产生负面影响。\n\n![性能时间轴上显示这个事件花了21.17毫秒](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98bfa6184f754fdd88f0dded16649547~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nChrome 开发者工具以 4 倍 CPU 减速运行性能。\n\n为了解决去中心化控制带来的问题，团队更新了播放器 UI 来同步所有更新，实际上是把播放器重构成一个顶层组件，它会向子组件传递数据。这确保任何状态更改只有一次 UI 更新(渲染)周期，消除了链式更新。新的播放器进度条触摸移动事件，在其 JavaScript 执行期间不会带来样式重绘，现在只需要花费旧播放器 1/4 的时间。\n\n![性能时间轴上显示减少的事件时间。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28cc1ca076f54224ae81d0d9a8498336~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n这种代码现代化还带来了其他性能改进，如老式设备上的观看加载时间改善、更少的弃播率、更少的 Bug 数量。\n\n**总结**\n\n通过 YouTube 对性能的投入，观看页面加载得更快了，现在 YouTube 移动网站中的 76% 的 URL 可以在实际场景中通过 Core Web Vitals 的阈值。在桌面端，观看页面的实验室 LCP 从约 4.6 秒减少到 1.6 秒。特别是 YouTube 视频播放器的交互和渲染性能，与以前相比 JavaScript 执行时间减少了高达 75%。\n\n> 成功:\n> \n> YouTube 移动网页的 76% URL 现在可以通过 Core Web Vitals，观看时间等业务指标也得到了改进。\n\n过去一年 YouTube 网页性能的改进也提高了业务指标，包括观看时间和日活跃用户。基于这些工作的成功，我们计划在未来继续探索更多优化方法。\n\n在该系列的第二部分“建设一个可访问的 Web”中，你将了解 YouTube 如何使网站对屏幕阅读器用户更具可访问性。\n\n特别感谢 Gilberto Cocchi、Lauren Usui、Benji Bear、Bo Aye、Bogdan Balas、Kenny Tran、Matthew Smith、Phil Harnish、Leena Sahoni、Jeremy Wagner、Philip Walton、Harleen Batra 以及 YouTube 和 Chrome 团队对这项工作的贡献。\n\n> 首发于公众号 [前端从进阶到入院](https://link.juejin.cn/?target=https%3A%2F%2Fp1-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2Fbf0f3ef7927d4a268eb386fcd3b62358~tplv-k3u1fbpfcp-watermark.image%3F \"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf0f3ef7927d4a268eb386fcd3b62358~tplv-k3u1fbpfcp-watermark.image?\")，作者 ssh，工作 6 年+，阿里云、字节跳动 Web infra 一线拼杀出来的资深前端工程师 + 面试官，非常熟悉大厂的面试套路，Vue、React 以及前端工程化领域深入浅出的文章帮助无数人进入了大厂，关注后回复「指南」，获取高级前端、算法学习路线，是我自己一路走来的实践。', 'public/uploads/1694316209305.png', 2, 3, 2, 104, '2019-09-10 03:23:30', 1);
INSERT INTO `article` VALUES (26, 6, '这个vite插件让console.log究极进化！', '![WX20230703-142659@2x.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d416a5c8d14d199c6d59f2c4ed7684~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 前言\n\n之前开源了 [babel-plugin-enhance-log](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbaozouai%2Fbabel-plugin-enhance-log \"https://github.com/baozouai/babel-plugin-enhance-log\")，也通过写了文章[偏爱 console.log 的你，肯定会觉得这个插件泰裤辣！](https://juejin.cn/post/7231577806189133884 \"https://juejin.cn/post/7231577806189133884\")来分享该插件如何使用，不过，看到评论里面有好几个都在问 vite+vue 如何使用：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383d10567f684b049d3d5c49305108dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc378ba8983e43fc8c12aaaa612e54d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n我稍微看了下，vite+vue 使用的是 esbuild，没有用到 babel，确实没法直接使用。但既然有小伙伴需要，我则尽量满足。所以抱着试试的心态看能否实现，幸好，皇天不负有心人，经过昨天几个小时的折腾，终于将其开源 👉🏻 [vite-plugin-enhance-log](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbaozouai%2Fvite-plugin-enhance-log \"https://github.com/baozouai/vite-plugin-enhance-log\")，有兴趣可以看看~\n\n## 咋使用捏，先安装呗 📦\n\n国际惯例，先安装插件\n\n```\npnpm add vite-plugin-enhance-log -D\n# or\nyarn add vite-plugin-enhance-log -D\n# or\nnpm i vite-plugin-enhance-log -D\n```\n\n## vue 中如何使用\n\n然后再 vite.config.ts 里面配置即可，比如 vue：\n\n```\nimport { defineConfig } from \'vite\'\nimport Vue from \'@vitejs/plugin-vue\'\nimport EnhanceLog from \'vite-plugin-enhance-log\'\n\nconst config = defineConfig({\n  plugins: [\n    Vue(),\n    EnhanceLog({\n      splitBy: \';\',\n      preTip: \'🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥\',\n    }),\n  ],\n})\n\nexport default config\n```\n\n> ⚠️ 请确保 EnhanceLog 在@vitejs/plugin-vue 后面\n\n跑项目后就有这效果啦：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf77469337a4a4f8c7aaad3bceb7254~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb8d4848109458e846e3af171083421~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## react 呢？\n\nreact 里面实际上有两种：\n\n1.第一种还是使用 babel-plugin-enhance-log，然后再 react 插件里面配置即可：\n\n```\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        plugins: [\'enhance-log\'],\n      },\n    }),\n    ]\n  })\n```\n\n2.跟 vue 一样，使用 vite-plugin-enhance-log\n\n```\nimport { defineConfig } from \'vite\'\nimport react from \'@vitejs/plugin-react\'\nimport EnhanceLog from \'vite-plugin-enhance-log\'\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    EnhanceLog({\n      splitBy: \'\\n\',\n    }),\n\n  ],\n})\n```\n\n## 通过 playgrounds 来了解其他参数吧\n\n实际上 vite-plugin-enhance-log 已经尽量做到开箱即用了，但如何你想要自定义，可以把项目拉下来，看下 playgrounds 里面是[vue](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbaozouai%2Fvite-plugin-enhance-log%2Fblob%2Fmaster%2Fplaygrounds%2Fvue%2Fvite.config.ts \"https://github.com/baozouai/vite-plugin-enhance-log/blob/master/playgrounds/vue/vite.config.ts\")或者[react](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbaozouai%2Fvite-plugin-enhance-log%2Fblob%2Fmaster%2Fplaygrounds%2Freact%2Fvite.config.ts \"https://github.com/baozouai/vite-plugin-enhance-log/blob/master/playgrounds/react/vite.config.ts\")是如何使用的。\n\n以下是目前提供的参数：\n\n```\ninterface Options {\n  /**\n   * 打印文件名\n   * 如果你文件名太长，希望不显示文件path的目录，比如src/pages/xxx/yyy/a.tsx, 那么可以配置enableDir为false，则只打印a.tsx\n   *\n   * @default true\n   */\n  enableFileName?: boolean | {\n    enableDir?: boolean\n  }\n  /**\n   * 打印的前缀提示，这样方便快速找到log 🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀\n   * @example\n   * console.log(\' 🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀\', ...)\n   */\n  preTip?: string\n  /** 每个参数分隔符，默认空字符串，你也可以使用换行符\\n，分号；逗号，甚至猪猪🐖都行~ */\n  splitBy?: boolean\n}\n```\n\n我们来一个个了解。\n\n## 👇 例子\n\n拉项目后通过运行启动 playgrounds：\n\n```\npnpm play # 对应vue\n# 或者\npnpm play:react # 对应react\n```\n\n来启动项目。\n\n比如说，你不喜欢小 🚀，你喜欢猪猪 🐖，那可以配置 preTip 为 🐖🐖🐖🐖🐖🐖🐖🐖🐖🐖：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0559cc31aea3498bac0f6bb49d1811e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n比如说，在参数较多的情况下，你希望 log 每个参数都换行，那可以配置 splitBy 为 \\\\n：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab4a921a5735486cac3d81155ee6aa87~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n或者分隔符是;:\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd2603c38cc46038fc64dea0d66be18~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n当然，你也可以随意指定，比如用个狗头 🐶 来分隔：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d1f547b3864b188e1ae4ba99899b20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n比如说，你希望知道 log 所在的文件名，那么可以配置 enableFileName 为 true（当然默认就是 true）：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5a238936c94a14bb3ae9f3b11b8f69~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n如果文件路径太长:\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49e74eb4bba54d33bcaf658bf4786276~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n你只希望打印文件名，不需要目录前缀，那么可以配置 `enableFileName: { enableDir: false }`:\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bd68804eb0242c889d441c8cb1f2180~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n当然，你不希望打印文件名的话，把 enableFileName 设为 false 就好啦。\n\n又比如说，有个 log 跨了多行，你希望 log 开始和结束的行数，中间是 log 实体，那可以将 endLine 设置为 true：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c47a55b8d3243848d3035c32efce8bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/460963a469964744b6da57b16ab75106~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 我们可以看到开始的行数是13，结束的行数是44，跟源码一致\n\n## ~目前存在的问题 ☹️~\n\n**vite-plugin-enhance-console@0.2.0已支持打印行数！！**\n\n~用过 babel-plugin-enhance-log 的肯定知道插件会自动打印 log 所在行，虽然说我在做 vite-plugin-enhance-log 的时候也可以拿到行数，但是由于输入代码已经被处理过一遍，导致跟真正的源码有所出入，可以通过 vite-plugin-inspect 看到效果：~\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e36e655f28f4022bff554073b30748f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/471017a70d0247aca81ac95ae328f627~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n~然后我也没法拿到之前的 sourcemap，所以导致拿到代码行数有所出入~\n\n> ~我日常工作都是使用webpack，vite不是特别熟，有知道怎么解决的大佬还请指教下，或者提个 pr，谢谢，谢谢！~\n\n## 最后\n\n本文介绍了 vite-plugin-enhance-log 插件的由来，尽量满足了 vite+vue 中实现同等的 babel-plugin-enhance-log 功能，同时也支持了打印文件名的功能，~但是由于没有拿到正确的代码行，所以目前版本把相关行功能的代码暂时注释了。~\n\n好了，文章是在顺风车上敲的，今天是周一，好困呀，我要去睡觉啦~', 'public/uploads/1694336270942.png', 2, 3, 0, 445, '2014-09-10 08:57:54', 1);
INSERT INTO `article` VALUES (27, 4, 'Java互斥锁 与 Golang互斥锁 简单对比', '### 仿element-ui之封装Message消息提示组件\r\n\r\n##### 前言:\r\n\r\n大家好~ 我是小瑜,今天给大家带来的是利用Vue3的h函数封装Message消息组件,首先看一下要完成的效果.\r\n\r\n![video-2023-06-03-192941.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05931b2b8e164efdb8d87b934c783c26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n在element官网中,消息提示组件是通过引入 import { ElMessage } from \'element-plus\' 实现的,那么一定是引入的某个方法, 但是一上来我们不需要考虑这么多,先把样式功能,利用组件的方法来实现目前的需求\r\n\r\n##### 注册组件\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// components/meesage/index.vue <script lang=\"ts\" setup name=\"Message\"> import { onMounted, ref } from \'vue\' export type Type = \'success\' | \'error\' | \'warning\' const { type = \'success\' } = defineProps<{   type?: Type,   text: string, }>() // 定义一个对象，三种情况的样式，对象key就是类型字符串 const style = {   warning: {     icon: \'icon-warning\',     color: \'#E6A23C\',     backgroundColor: \'rgb(253, 246, 236)\',     borderColor: \'rgb(250, 236, 216)\'   },   error: {     icon: \'icon-shanchu\',     color: \'#F56C6C\',     backgroundColor: \'rgb(254, 240, 240)\',     borderColor: \'rgb(253, 226, 226)\'   },   success: {     icon: \'icon-queren2\',     color: \'#67C23A\',     backgroundColor: \'rgb(240, 249, 235)\',     borderColor: \'rgb(225, 243, 216)\'   } } </script> <template>   <Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <span class=\"text\">{{ text }}</span>     </div>   </Transition> </template> <style scoped lang=\"scss\"> .message {   width: 300px;   height: 50px;   position: fixed;   z-index: 9999;   left: 50%;   margin-left: -150px;![277c93489ae345eef3e93bd5e8cf8](D:\\upupdate\\demo\\vue相关\\vue3-demo\\src\\components\\message\\images\\8277c93489ae345eef3e93bd5e8cf87.png)![277c93489ae345eef3e93bd5e8cf8](D:\\upupdate\\demo\\vue相关\\vue3-demo\\src\\components\\message\\images\\8277c93489ae345eef3e93bd5e8cf87.png)   top: 25px;   line-height: 50px;   padding: 0 25px;   border: 1px solid #e4e4e4;   background: #f5f5f5;   color: #999;   border-radius: 4px;   i {     margin-right: 4px;     vertical-align: middle;   }   .text {     vertical-align: middle;   } } </style>`\r\n\r\n样式和简单的功能已经书写好了,我们去导入使用下 ,看一下效果\r\n\r\n![8277c93489ae345eef3e93bd5e8cf87.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c92422dbf64fe3878030e08c5149a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n耶,页面上已经可以显示了,但是有两个问题需要我们进行优化\r\n\r\n1.  缺少动画效果\r\n    \r\n2.  弹层无法关闭\r\n    \r\n\r\n##### 添加动画效果\r\n\r\n这里可以使用css去写,可以使用vue提供的**Transition**进行动画的使用, 可能大家都不知道如何使用, 那怎么办? 老规矩 打开vue3文档~\r\n\r\n`<Transition>` 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上....\r\n\r\nvue3的文档写的非常详细,大家以后遇到不会的可以多去看一看,这里我就不展开,直接写代码\r\n\r\njs\r\n\r\n复制代码\r\n\r\n `<Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <!-- <span class=\"text\"><slot></slot></span> -->       <!-- 改造一下 -->       <span class=\"text\">{{ text }}</span>     </div>  </Transition>`\r\n\r\n组件上来是从上往下淡入,并且消失的时候是从下往上淡出,基于效果,开始书写Transition动画css\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// lang=\"scss\" 这里我用到了scss 所以对重复的属性进行了简写 .down {   &-enter {     &-from {       transform: translate3d(0, -75px, 0);       opacity: 0;     }     &-active {       transition: all 0.5s;     }     &-to {       transform: none;       opacity: 1;     }   }   &-leave {     &-from {       transform: none;       opacity: 1;     }     &-active {       transition: all 0.5s;     }     &-to {       transform: translate3d(0, 75px, 0);       opacity: 0;     }   } }`\r\n\r\n写完后发现,并没有出现动画, 这是什么原因? vue3有bug!\r\n\r\n原来使用的时候必须要使用\r\n\r\n-   由 `v-if` 所触发的切换\r\n-   由 `v-show` 所触发的切换\r\n\r\n基于这个特性,可以配合弹层关闭的效果\r\n\r\n##### 弹层自动关闭\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`const { type = \'success\',duration=1500 } = defineProps<{   type?: Type,   text: string,   duration?:number // 传入展示弹层的时间(可选,默认显示1500) }>() const isShow = ref(false) // 当组件被挂载完成就显示 onMounted(()=> {   isShow.value = true   // 当duration时间过后，就隐藏   window.setTimeout(() => {     isShow.value = false   }, duration) }) <Transition name=\"down\">     <div class=\"message\" :style=\"style[type]\" v-if=\"isShow\">       <i class=\"iconfont\" :class=\"style[type].icon\"></i>       <!-- <span class=\"text\"><slot></slot></span> -->       <!-- 改造一下 -->       <span class=\"text\">{{ text }}</span>     </div> </Transition>`\r\n\r\n此时就完了利用组件完成功能\r\n\r\n上面说到,最终是需要通过引入方法的方式来实现,并且使用的方法是\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// Message({type:\'success\'}, \'登录成功\') // Message({type:\'error\'}, \'登录失败\') // Message.success(\'登录成功\') // Message.error(\'登录失败\')`\r\n\r\n这时候就需要使用\r\n\r\n首先按照文档学习一下vue3中h函数的使用方法\r\n\r\n##### 初识h函数\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`import { h, render } from \"vue\"; // 1. 创建vnode // 第一个参数是标签名称或者是组件名称 // 第二个参数是属性 // 第三个参数是显示内容 const vnode = h(\'h1\', { class: \'title\' }, \'hello world\') // 2. render渲染  // 第一个参数是需要渲染的内容 // 第二个参数是挂载到哪个地方 render(vnode,document.getElementById(\'app\'))`\r\n\r\n此时页面中就可以出现h1标签内容为hello world\r\n\r\n![9389d344d21e9def282cc7b1cc84f5b.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f66388190b7240b2bc4629807dc64c02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n好, 有了h函数以及render的知识铺垫,我们接着写message组件\r\n\r\n##### 利用h函数改造message组件\r\n\r\n首先我们在对应的components下的messaga文件夹下创建index.ts文件\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`import { h, render } from \"vue\" import MyMessage from \"@/components/message/message.vue\" // 往body中系只能一个盒子,目的是同时只能出现一次消息弹层 const divContainer = document.createElement(\'div\') as HTMLDivElement divContainer.classList.add(\'message-container\') document.body.appendChild(divContainer) // 按照基本写法的方式书写h函数 // 1. 创建vnode const vnode = h(MyMessage,{type,text}) render(vnode,divContainer)`\r\n\r\n此时就完成了基本的功能,但是我们最终要导入方法并 Message({type:\'success\'}, \'登录成功\')来使用,也就是调用函数的方法使用\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// 使用函数 type Params = {  type: \'success\' | \'error\' | \'warning\',  text: string,  duration?: number } function Message({ type, text, duration = 2000 }: Params) {  // 如果要像elui一样点击就创建 并且多次点击创建多个可以帮创建放在里面  // 往body中新增一个盒子 =>为了代码中  const divContainer = document.createElement(\'div\') as HTMLDivElement  divContainer.classList.add(\'message-container\')  document.body.appendChild(divContainer)  // 1. 创建虚拟dom  // const vNode = h(MyMessage, { type, text })  const vNode = h(MyMessage, { type, text })  // 2. 动态render  render(vNode, divContainer)  clearTimeout(timer)  // 3. 开启一个延时器,到时间就隐藏  timer = setTimeout(() => {   render(null, divContainer)   }, duration) }`\r\n\r\n##### 优化message组件的使用\r\n\r\n实际开发中,我们更希望利用\r\n\r\nMessage.success(\'成功\') Message.error(\'失败\') Message.warning(\'警告\') 来简化代码\r\n\r\n这就相当于帮我们再次封装了一层函数的调用\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// components/message/index.ts Message.success = (text: string, duration?: number) => {  Message({   text,   type: \'success\',   duration  }) } Message.error = (text: string, duration?: number) => {  Message({   text,   type: \'error\',   duration  }) } Message.warning = (text: string, duration?: number) => {  Message({   text,   type: \'warning\',   duration  }) }`\r\n\r\n在项目中的使用\r\n\r\njs\r\n\r\n复制代码\r\n\r\n`// 点击按钮 出现message弹层 const showSuccess = () => {   Message.success(\'成功\') } const showError = () => {   Message.error(\'失败\') } const showWarning = () => {   Message.warning(\'警告\') } </script> <template>   <button @click=\"showSuccess\">success</button>   <button @click=\"showError\">error</button>   <button @click=\"showWarning\">warning</button> </template>`\r\n\r\n##### 完结:\r\n\r\n此时我们就完成了message组件的封装, 在没做之前感觉很难,但是实际动手后,其实也是非常简单的, 重在实践, 除此之外,利用h函数也可以封装dialog弹层,原理也是一样的,大家可以动手写一下~\r\n\r\n好啦, 以上就是全部内容, 各位大佬, 可以给小瑜点个赞哦~ 手动撒花_★,°_:.☆(￣▽￣)/$:_.°★_ 。', '', 2, 3, 0, 640, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (28, 6, '当pinia遇上web-localstorage-plus,打不过就申请加入💪', '大家好，我是苏先生，一名热爱钻研、乐于分享的前端工程师，跟大家分享一句我很喜欢的话：人活着，其实就是一种心态，你若觉得快乐，幸福便无处不在\n\n## [github与好文](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FsupanpanCn%2Fblob%2Ftree%2Fmain \"https://github.com/supanpanCn/blob/tree/main\")\n\n-   [TypeScript知识点和99个类型体操-专栏-每周更新](https://juejin.cn/column/7233765235953205304 \"https://juejin.cn/column/7233765235953205304\")\n    \n-   [vue3核心原理精讲-专栏-持续更新中...](https://juejin.cn/column/7235237072439967799 \"https://juejin.cn/column/7235237072439967799\")\n    \n\n-   [如何把localStorage玩出花儿](https://juejin.cn/post/7212539744676528186 \"https://juejin.cn/post/7212539744676528186\")\n\n## 你可以从本文学到什么\n\n1.如何开发一个`pinia`插件\n\n2.如何开发一个`vite`插件\n\n3.如何开发一个`webpack`插件\n\n## 前言\n\n[上一篇文章](https://juejin.cn/post/7249397451055497253 \"https://juejin.cn/post/7249397451055497253\")，我们详细对比了[web-localstorage-plus](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FsupanpanCn%2Fweb-localstorage-plus \"https://github.com/supanpanCn/web-localstorage-plus\")和[pinia-plugin-persistedstate](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprazdevs%2Fpinia-plugin-persistedstate%2Ftree%2F2cdbe7d5956c74db2720c4263085154b26205644 \"https://github.com/prazdevs/pinia-plugin-persistedstate/tree/2cdbe7d5956c74db2720c4263085154b26205644\")这两个npm包在持久化存储上的能力。pinia-plugin-persistedstate背靠Pinia，受到了广大开发者的喜爱，于是，笔者眼红了，笔者太太太眼红了啊\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cf3f9a8f5fc4a44865069889b44949a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n所以，咱们本文的目的就一个，那就是改造`web-localStorage-plus`，让它能够站在`Pinia`这个巨人的肩膀上\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/347f6beb1409453b882188e3a83eab78~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 思考\n\n俗话说，兵马未动，粮草先行......\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/623c8b92fee444f0ae550b6e96bd29be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我的意思是，我们要先考虑出来一个方向，然后再动手进行改造🤔\n\n有两个大的方向：\n\n-   对原有的`web-localStorage-plus`进行改造\n\n是让`Pinia`作为`web-localStorage-plus`的插件还是让`web-localStorage-plus`作为`Pinia`的插件，尽管它们本质的实现都一定是一个符合`Pinia`插件规范的函数，但是这对`web-localStorage-plus`的接口设计却影响很大。比如，如果让`web-localStorage-plus`作为Pinia的插件，则必须在`web-localStorage-plus`内部重新单独导出一个函数，但如果是反过来的话，则恰好可以利用`web-localStorage-plus`本身的`use`接口\n\n想要实现这一点，只需要对原有的`use`接口进行改造即可，如下\n\n```\n// src/core/api/use.ts\nfunction use(pinia:Pinia):FalsyValue;\nfunction use(...):FalsyValue;\nfunction use(type: PluginCb | Pinia, framework?: \"customer\" | \"buildIn\") {\n  if(typeof type === \'function\'){\n    ...\n    return \n  }\n  runAsPiniaPlugin(type,native)\n}\n```\n\n-   新开发一个`npm`包\n\n考虑到需要对热更新进行支持，如果采取方案一，则会让`web-localStorage-plus`包变的不纯粹，因为它不应该与`pinia`、`vite`、`webpack`强相关\n\n## 实现\n\n### 补充Pinia实例类型\n\n首先，我们找到`Pinia`中`defineStore`的类型定义\n\n```\nexport declare function defineStore<...>(id: Id, options: Omit<DefineStoreOptions<...>, \'id\'>): ...;\n```\n\n`options`即我们要扩展的部分\n\n```\noptions: Omit<DefineStoreOptions<Id, S, G, A>\n```\n\n进入`DefineStoreOptions`，它扩展自`DefineStoreOptionsBase`\n\n```\nexport declare interface DefineStoreOptions<Id extends string, S extends StateTree, G, A> extends DefineStoreOptionsBase<S, Store<Id, S, G, A>> {\n    ...\n}\n```\n\n找到`DefineStoreOptionsBase`，它是一个空的interface\n\n```\nexport declare interface DefineStoreOptionsBase<S extends StateTree, Store> {\n}\n```\n\n故我们借助`DefineStoreOptionsBase`为`Pinia`补充TypeScript类型\n\n```\n// src/helper/types.ts\nexport interface PersistedStateOptions {\n  namespace?: string ;\n  paths?: Array<string>;\n}\n\nexport interface DefineStoreOptionsBase<S extends StateTree, Store> {\n    persist?: boolean | PersistedStateOptions \n}\n```\n\n同理，借助`PiniaCustomProperties`为`hmr`设计TypeScript类型\n\n```\nexport interface PiniaCustomProperties {\n    $hydrate: (payload: {\n      state: StateTree;\n      persist: boolean | PersistedStateOptions;\n    }) => void;\n    $discard: (id: string) => void;\n}\n```\n\n### 初始化\n\n首先，使用`web-localStorage-plus`创建一个命名空间，后续pinia相关的状态都设置到该空间下\n\n```\nfunction initSpaceForPinia(ctx: This) {\n  const hasSpace = ctx.getItem(NAMESPACE);\n  if (hasSpace) return;\n  ctx.setItem(NAMESPACE, {});\n}\n```\n\n接着，将其注册为`pinia`插件\n\n```\npinia.use(internalPiniaPlugin(ctx));\n```\n\n### 状态激活\n\n当刷新页面后，我们从`web-localStorage-plus`存储中取出对应的状态并重新设置给pinia，这其实分为两种情况，当store已经存在时，此时用于从`web-localStorage-plus`向`pinia`激活，否则说明是进行初始化，需要将`pinia`中的状态保存到`web-localStorage-plus`中\n\n```\nfunction activateState(payload: Params) {\n  const { key, ctx, piniaCtx, paths, state } = payload;\n  if (spaceToStoreId.has(key)) {\n    const store = ctx.getItem(key, NAMESPACE);\n    if (store) {\n      const latest = updateStore(paths, store, ctx, key, state);\n      piniaCtx.$patch(latest);\n      return;\n    }\n    persistState(payload);\n  }\n}\n```\n\n### 保持响应\n\n当`Pinia`中的状态发生改变时，我们要对其进行同步更新，这只需要监听`store.$subscribe`方法，当其回调后调用`persistState`即可\n\n如下，我们实际上是将state中的值按paths排除后重新向本地更新了一份\n\n```\nfunction persistState(payload: Omit<Params, \"piniaCtx\">) {\n  const { key, ctx, paths, state } = payload;\n  if (spaceToStoreId.has(key)) {\n    for (let i = 0; i < paths.length; i++) {\n      const v = paths[i];\n      const rest = paths.slice(i + 1);\n      const index = rest.findIndex((r) => r.startsWith(v));\n      if (index > -1) {\n        paths.splice(i + index, 1);\n        i--;\n      }\n    }\n    ctx.setItem(key, pick(state, paths), NAMESPACE);\n  }\n}\n```\n\n### paths配置项的更新\n\n当`paths`配置项改变时，应当重新设置`web-localStorage-plus`下对应命名空间的值，由于将`paths`设置到`localStorage`是一个冗余的字段，故需要与localStorage中的存储值进行比较更新，这无外乎有以下几种情况：\n\n-   paths新增了key\n\n此时，需要将新增的`key`对应的`state`中的内容更新到`localStorage`\n\n-   paths删除了key\n\n此时，需要找到`localStorage`中的`key`进行删除\n\n-   使用persist配置项代替对象配置\n\n此时，按照`state`全量更新到`localStorage`\n\n虽然，情况是这么个情况，但是在实际开发中，并不需要严格按照此分类进行讨论，笔者这里采取对象合并的形式来进行统一，首先要根据paths初始化一个空对象\n\n```\nlet processingObj = helpers.createObjByPaths(paths, state);\n```\n\n接着分别与`web-localStorage-plus`和`pinia`的`state`进行对象合并\n\n```\nconst _mergeStoreCb = (objValue: any, srcValue: any) => {\n    if (isObject(objValue) && isObject(srcValue)) {\n      return helpers.mergeDeep(objValue, srcValue, _mergeStoreCb);\n    }\n    if (objValue === undefined) {\n      return deleteFlag;\n    }\n    if (!helpers.isSameType(objValue, srcValue)) {\n      return objValue;\n    }\n};\n```\n\n最后，重新设置到`web-localStorage-plus`即可\n\n```\nctx.setItem(key, processingObj, NAMESPACE);\n```\n\n### 处理热更新\n\n当热更新时，需要同步更新`web-localStorage-plus`的存储值。这以存储的唯一凭证`id`是否改变分为两类：\n\nid不变时，调用`hydrate`将`state`中的值持久化到本地\n\n```\nctx.$hydrate?.({\n  ...JSON.parse(msg.data),\n  id,\n});\n```\n\nid改变时，需要打印出提示，并且将原仓库从`web-localStorage-plus`中删除\n\n```\nif (id !== initialUseStore.$id && initialUseStore) {\n    console.warn(\n      `[@web-localstorage-plus/pinia]:检测到存储库的id从\"${initialUseStore.$id}\"变成\"${id}\"了`\n    );\n    initialUseStore(pinia, pinia._s.get(initialUseStore.$id)!).$discard?.(initialUseStore.$id);\n    useStore(pinia, pinia._s.get(id)!);\n}\n```\n\n### 开发plugin\n\n目前来说，对用户是相当繁琐的存在，因为其不得不手动的在每一个`pinia`模块内设置和调用\n\n```\nif (import.meta.hot)\n  import.meta.hot.accept(acceptHMRUpdateWithHydration(useStore, import.meta.hot))\n```\n\n因此，最好的方式是写一个`plugin`帮用户做这件事情，笔者这里暂时只提供对`vite`和`webpack`的支持。它们的思路很简单，即：对源码进行识别，识别到可用的`pinia`模块后，将热更新相关的代码帮助用户进行注入即可\n\n```\nexport default function transform(code: string, id: string) {\n  let { apiName, stopIndex } = extractApi(code);\n  if (apiName) {\n    const api = extractRegisterApi(code.slice(stopIndex), apiName);\n    if (api) {\n      const s = new MagicString(code);\n      s.prepend(\n        `import { acceptHMRUpdateWithHydration } from \'@web-localstorage-plus/pinia\';\\n`\n      );\n      s.append(`if (import.meta.hot)\\n`);\n      s.append(\n        `  import.meta.hot.accept(acceptHMRUpdateWithHydration(${api}, import.meta.hot));\\n`\n      );\n      return {\n        code: s.toString(),\n        map: s.generateMap({ source: id, includeContent: true }),\n      };\n    }\n  }\n}\n```\n\n至于`vite`和`webpack`的支持，笔者并没有选用第三方库来做，因为用到的`hook`太有限了\n\n-   vite\n\n`vite`只需要配置`transform`钩子即可\n\n```\nexport default function vitePlugin(folder: string): Plugin {\n  return {\n    name: \"vite:web-localstorage-plus-pinia-hmr\",\n    transform,\n  };\n}\n```\n\n-   webpack\n\n`webpack`则需要将其作为`loader`使用\n\n```\ncompiler.options.module.rules.unshift({\n  enforce: \"pre\",\n  use,\n});\n```\n\n需要注意的是，由于`vite`对`node`内建模块的不兼容，我们需要采取动态导入的形式来生成`loader`的指向地址\n\n```\nimport(\"node:path\").then(mod=>{\n    mod.resolve(...)\n})\n```\n\n还有一点，就是需要在`use`函数中生成`fileId`，因为在`transfrom`的实际函数体内拿不到`id`，这会导致在`vite`中正常运行的`transform`出错\n\n```\nlet fileId = data.resource + (data.resourceQuery || \"\");\n```\n\n最后，导出一个函数单独处理id的获取并在transform中调用即可\n\n```\nexport async function getFileId(id: string) {\n  if (webpackContext.folder) {\n      return webpackContext.fileId;\n  }\n  return id;\n}\n```\n\n## 使用\n\n-   安装依赖\n\n```\nyarn add web-localstorage-plus\nyarn add @web-localstorage-plus/pinia\n```\n\n-   在`main.ts`中设置持久化\n\n```\nimport createStorage from \'web-localstorage-plus\';\nimport setPiniaPersist from \'@web-localstorage-plus/pinia\';\n// 设置根存储库\ncreateStorage({\n    rootName: \'spp-storage\',\n});\n// 将pinia中的数据持久化到本地\nsetPiniaPersist(pinia);\n```\n\n-   在`vite.config.ts`中引入热更新插件\n\n```\nimport { getPlugin } from \'@web-localstorage-plus/pinia\';\nconst piniaHmrPlugin = getPlugin(\'vite\');\nexport default defineConfig({\n    ...,\n    plugins:[piniaHmrPlugin(resolve(__dirname, \'src/store\'))]\n})\n```\n\n___\n\n如果本文对您有用，希望能得到您的点赞和收藏\n\n**订阅专栏**，每周更新1-2篇类型体操，每月1-3篇vue3源码解析，等你哟😎', 'public/uploads/1694336325469.png', 2, 4, 1, 933, '2023-09-10 08:58:52', 1);
INSERT INTO `article` VALUES (29, 7, 'MySQL Binlog入门', '> 引言： 之后的一段时间准备开始写一些关于mysql的文章，从实际的使用入手，介绍它的方方面面吧，主要是实际工作当中接触比较多的点。因为暑假期间数据库要做备份，涉及到binlog文件的处理，那么今天就先从这个知识点说起。MySQL的binlog（二进制日志）是一种重要的组件，用于记录数据库的操作，并以二进制格式存储。它可以捕捉数据库的插入、更新、删除等变更操作。binlog在数据恢复、备份、主从复制和故障容错等方面发挥着重要作用。本文将详细探讨MySQL binlog的底层原理，包括格式、事件、位置以及在不同场景下的重要性。\n\n![77.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b869b93288464d8797b7c0793632e888~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> ## 一、binlog的结构及组成部分\n\n  **二进制日志文件**\n\n  binlog全称为:binary，翻译就是二进制文件，主要记录了MySQL在进行DML（数据操作语言）过程中的操作日志。在执行SQL语句的过程中，作为使用者，无需关注程序执行的过程，但是当数据库数据丢失，或者需要搭建数据库主从复制时，则此时的binlog日志文件的重要性就展现出来了。MySQL的binlog是以文件的形式存在的，每个binlog文件都以一个唯一的递增编号来命名。一个binlog文件通常包含多个日志事件（log event），这些事件以连续的方式写入binlog文件。\n\n  **日志事件**\n\n  日志事件是binlog的基本组成单位，它是对数据库修改操作的记录。每个日志事件都包含了必要的信息，用于恢复数据库的状态。一个日志事件通常包含事件头（event header）和事件体（event body）两个部分。\n\n  事件头包含了事件的元数据信息，如事件的类型、时间戳、服务器ID等。事件体则包含了具体的数据操作信息，如表名、操作类型、修改前后的数据等。\n\n  **事件组**\n\n  为了提高写入性能，binlog将多个日志事件组合成一个事件组（event group）进行批量写入。事件组的大小默认为1MB，可以通过配置参数进行调整。\n\n  **binlog的日志格式**\n\n  MySQL的binlog支持多种不同的日志格式，每种格式在存储和记录方式上有所不同。常用的binlog日志格式包括以下几种：\n\n  (1)、STATMENT模式：基于SQL语句的复制，每一条会修改数据的sql语句会记录到binlog中。\n\n  优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。\n\n  缺点：在某些情况下会导致master-slave（主从复制模式）中的数据不一致(如sleep(暂停指定时间执行)函数， last\\_insert\\_id（自增）等情况下会出现问题)\n\n  (2)、ROW模式：基于行的复制，不记录每一条SQL语句的上下文信息，仅记录哪条数据被修改了，修改后的结果是什么\n\n  优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。\n\n  缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。\n\n  (3)、MIXED模式，混合模式的复制方式：如上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的相关操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。\n\n> ## 二、 binlog日志打开与查看\n\n   （1）开启binlog日志\n\n  开启binlog日志,查看本机是否开启了binlog日志，登录到mysql服务后，输入如下命令:\n\n```\nshow variables like \'%log_bin%\';\n```\n\n  可以看到结果：\n\n![12.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc470be846864c4b8250585dfb351dc6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n  可以看到log\\_bin 的值为“OFF”，binlog日志是默认关闭的，那么如何开启呢？\n\n  开启binlog日志方式，打开mysql配置文件my.cnf，在\\[mysqlId\\]下面增加。\n\n```\nlog-bin=mysql-bin\n```\n\n  开启binlog日志后，重新查看下：\n\n![13.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d376fcf479a844eca9708f4d06e4b8bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n   （2）查看binlog日志\n\n```\nmysql> show binlog events ``in \'mysql-bin.000002\'``;#查看指定binlog文件的内容 \nmysql> show binary logs; #获取binlog文件列表 \nmysql> show master status； #查看当前正在写入的binlog文件\nmysql> show binary logs; #获取binlog文件列表 \n参数名                                           | 含义                    |\n| --------------------------------------------- | ---------------------- |\n| log bin = (on                                 | off base name)         |\n| sql log bin =( on                             | off )                  |\n| expire logs days                              | 指定自动删除二进制日志的时间，即日志过期时间 |\n| log bin index                                 | 指定mysql-bin.index文件的路径 |\n| binlog format = [ mixed | row | statement ] | 指定二进制日志基于什么模式记录      \n| max binlog size                               | 指定二进制日志文件最大值           \n| binlog cache size                             | 指定事务日志缓存区大小           \n| max binlog cache size                         | 指定二进制日志缓存最大大小         \n| sync binlog = { 0 | n }                      | 指定写缓冲多少次，刷一次盘\n```\n\n```\nSHOW BINLOG EVENTS[IN \'log_name\'][FROM pos][LIMIT [offset,] row_count]\n在二进制日志中显示事件。如果未指定，则显示第一个二进制日志。需要特权。\'log_name\'SHOW BINLOG EVENTSREPLICATION SLAVE该LIMIT子句与该语句具有相同的语法SELECT。请参见“ SELECT语句”。mysql> show binlog events limit 10;\n+------------------+-------+----------------+-----------+-------------+-----------------------------------------------------+\n| Log_name         | Pos   | Event_type     | Server_id | End_log_pos | Info                                                |\n+------------------+-------+----------------+-----------+-------------+-----------------------------------------------------+\n| mysql-bin.000001 |     4 | Format_desc    |         1 |         123 | Server ver: 5.7.27-log, Binlog ver: 4               |\n| mysql-bin.000001 |   123 | Previous_gtids |         1 |         154 |                                                     |\n| mysql-bin.000001 |   154 | Anonymous_Gtid |         1 |         219 | SET @@SESSION.GTID_NEXT= \'ANONYMOUS\'                |\n| mysql-bin.000001 |   219 | Query          |         1 |         300 | BEGIN                                               |\n| mysql-bin.000001 |   300 | Table_map      |         1 |         412 | table_id: 392 (cactus_000510.360exthost_examinemgr) |\n| mysql-bin.000001 |   412 | Delete_rows    |         1 |        8617 | table_id: 392                                       |\n| mysql-bin.000001 |  8617 | Delete_rows    |         1 |       12732 | table_id: 392 flags: STMT_END_F                     |\n| mysql-bin.000001 | 12732 | Xid            |         1 |       12763 | COMMIT /* xid=530 */                                |\n| mysql-bin.000001 | 12763 | Anonymous_Gtid |         1 |       12828 | SET @@SESSION.GTID_NEXT= \'ANONYMOUS\'                |\n| mysql-bin.000001 | 12828 | Query          |         1 |       12917 | BEGIN                                               |\n+------------------+-------+----------------+-----------+-------------+-------\n```\n\n   (2)刷新日志时，会生成新的binlog文件\n\n```\nmysql> flush logs;\nQuery OK, 0 rows affected (0.04 sec)\n\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000090 |      107 |              |                  |\n+------------------+----------+--------------+------------------+\n```\n\n   生成了新的binlog日志。\n\n   (3)命令查看了binlog的简单信息，如何查看执行时间、执行花费的时间等详细信息需要使用工具包中的mysqlbinlog命令。\n\n```\nmysqlbinlog  binlog文件完整路径  | more \n\n我执行了如下命令：\n\nmysqlbinlog.exe D:\\Program Files\\MariaDB 5.5\\data\\mysql-bin.000003 | more\n```\n\n![16.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18e2921a6c3143cb9b587cb225c2a0e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n   (4)binlog日志内容解析，截取数据中的部分如下:\n\n```\n# at 123 #210405 12:15:13 server id 1 end_log_pos 639 Query thread_id=13 exec_time=0 error_code=0 SET TIMESTAMP=1317628098/*!*/; update user set username=\'xxxx\' where uid = \'15\' /*!*/;\n\n**postion（描述）：** at后面的数字代表在binlog日志文件的第几个字节开始（at 523 ）\n\n**timestamp（事件发生的时间戳）:** 即第二行的（#210405 21:08:18）\n\n**server id（[服务器](https://activity.huaweicloud.com/discount_area_v5/index.html?utm_source=hwc-csdn&utm_medium=share-op&utm_campaign=&utm_content=&utm_term=&utm_adplace=AdPlace070851)标识）:** （1），代表执行的主机编号\n\n**end_log_pos（结束字节数）：** 结束的字节位置639\n\n**Query（类型）：** 事件类型。\n\n**thread_id：** 处理的线程编号(13)\n\n**exec_time：** 执行花费的时间\n\n**error_code:** 错误码\n\n**SET TIMESTAMP=1617628098**/*!*/;代表执行的时间戳\n\n**update user set username=\'zhangqian\' where uid = \'15\'** 代表执行的语句，遇到下一个#at 则为下一个binlog日志事件。\n```\n\n> ## 三、binlog的工作原理\n\n  3.1 写入过程 当数据库执行修改操作时，比如插入一条新记录、更新一条记录或删除一条记录，MySQL会将对应的日志事件写入当前的binlog文件中。MySQL会在内存中维护一个binlog缓冲区，将日志事件先写入缓冲区，并不立即写入磁盘文件。当缓冲区满时，或达到一定的时间间隔，MySQL会将缓冲区中的日志事件通过文件系统的write系统调用写入磁盘文件。\n\n  3.2 刷盘过程 为了确保数据的持久性，MySQL会将binlog文件进行刷盘（flush）操作，将内存中的日志事件刷写到磁盘上的binlog文件中。MySQL在不同情况下有不同的刷盘策略，比如在事务提交时会进行刷盘操作，以保证事务的持久性。\n\n  3.3 读取与解析 binlog的读取和解析通常由外部程序完成，开发者可以使用MySQL提供的工具或自定义程序进行解析。读取binlog可以按照顺序读取，或者通过指定位置或时间戳进行读取。读取binlog的过程主要包括以下几个步骤：打开binlog文件、解析事件头、解析事件体、处理事件数据。通过解析binlog可以获取到修改操作的详细信息，可以用于数据恢复、数据同步等应用场景。\n\n> ## 四、binlog的相关配置和用法\n\n  4.1 binlog的配置参数 在MySQL的配置文件中（通常是my.cnf或my.ini），可以通过以下配置参数来控制binlog的相关行为：\n\n  · log\\_bin：是否开启binlog功能，默认为OFF，可以通过设置为ON来开启。\n\n  · binlog\\_format：指定binlog的日志格式，可选值为STATEMENT、ROW、MIXED，默认为STATEMENT。\n\n  · binlog\\_cache\\_size：控制binlog缓冲区的大小，默认为32KB。\n\n  · max\\_binlog\\_size：指定每个binlog文件的最大大小，默认为1GB，可以通过设置为较小的值进行拆分。\n\n  4.2 binlog的用途 binlog在MySQL的数据恢复、数据备份、数据同步等场景中都扮演着重要的角色。具体的应用包括：\n\n  · 数据库备份与恢复：通过备份和恢复binlog文件，可以实现对数据库的增量备份和恢复。\n\n  · 数据同步与复制：通过读取和解析binlog，可以实现数据库之间的数据同步和复制，保持多个数据库的一致性。\n\n  · 数据库故障恢复：通过解析binlog，可以将数据库恢复到指定的时间点，以应对因故障导致的数据丢失问题。\n\n  · 数据审计与追踪：通过记录binlog，可以实现对数据库操作的审计和追踪，以便进行安全审计和合规性检查。\n\n> ## 五、总结\n\n  本文详细介绍了MySQL的binlog的底层原理，包括binlog的结构、日志格式、工作原理及相关配置和用法。binlog作为MySQL中重要的日志功能之一，不仅可以用于数据备份和恢复，还可以支持数据同步和复制等应用场景。深入理解binlog的底层原理可以更好地应用和优化数据库的相关功能。\n\n## refs\n\n[\\# 35岁愿你我皆向阳而生](https://juejin.cn/post/7246778558248632378 \"https://juejin.cn/post/7246778558248632378\")\n\n[\\# 深入解读Docker的Union File System技术](https://juejin.cn/post/7259384503097311269 \"https://juejin.cn/post/7259384503097311269\")\n\n[\\# 说一说注解@Autowired @Resource @Reference使用场景](https://juejin.cn/post/7259762775365468197 \"https://juejin.cn/post/7259762775365468197\")\n\n[\\# 面对“魔咒”改变才是唯一的前路](https://juejin.cn/post/7257894053902663737 \"https://juejin.cn/post/7257894053902663737\")\n\n[\\# 编写Dockerfile和构建自定义镜像的步骤与技巧](https://juejin.cn/post/7259762205985423417 \"https://juejin.cn/post/7259762205985423417\")\n\n[\\# 学习自定义Spring注解](https://juejin.cn/post/7262737716852293690 \"https://juejin.cn/post/7262737716852293690\")', 'public/uploads/1694354574424.png', 3, 2, 1, 161, '2023-09-10 14:02:56', 1);
INSERT INTO `article` VALUES (30, 5, 'iOS17兼容问题，[NSURL URLWithString:]逻辑BUG，影响WKWebView', '## \\[NSURL URLWithString:urlString\\]默认实现逻辑变动\n\n`[NSURL URLWithString:urlString]`以前的逻辑是urlString有中文字符就返回nil，现在是默认对非法字符（包含中文）进行%转义。\n\n`URLWithString:`方法并没有给出说明，但是iOS17新增了`URLWithString:encodingInvalidCharacters:`方法，具体可以参照此方法。\n\n```\n/// Initializes and returns a newly created `NSURL` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.\n/// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.\n/// If `encodingInvalidCharacters` is true, `NSURL` will try to encode the string to create a valid URL.\n/// If the URL string is still invalid after encoding, `nil` is returned.\n///\n/// - Parameter URLString: The URL string.\n/// - Parameter encodingInvalidCharacters: True if `NSURL` should try to encode an invalid URL string, false otherwise.\n/// - Returns: An `NSURL` instance for a valid URL, or `nil` if the URL is invalid.\n+ (nullable instancetype)URLWithString:(NSString *)URLString encodingInvalidCharacters:(BOOL)encodingInvalidCharacters API_AVAILABLE(macos(14.0), ios(17.0), watchos(10.0), tvos(17.0));\n```\n\n## 附带的BUG\n\n这一个改动本来没有什么大问题，但问题是有BUG。\n\n如果urlString中没有中文，那urlString里原有的%字符不会转义。\n\n```\n(lldb) po [NSURL URLWithString:@\"http://a.com?redirectUri=http%3A%2F%2Fb.com\"]\nhttp://a.com?redirectUri=http%3A%2F%2Fb.com\n```\n\n如果urlString中有中文字符，那么中文字符和%字符都会被转义，最终会影响运行效果。\n\n（我就是因为这个BUG，从而导致原本能正常进行302重定向的页面无法重定向。）\n\n```\n(lldb) po [NSURL URLWithString:@\"http://a.com?title=标题&redirectUri=http%3A%2F%2Fb.com\"]\nhttp://a.com?title=%E6%A0%87%E9%A2%98&redirectUri=http%253A%252F%252Fb.com\n```\n\n## 修改方案\n\n对原方法进行替换，保证`[NSURL URLWithString:urlString]`在iOS17系统上的运行逻辑和iOS17以下系统保持一致。这样对于现有代码逻辑的影响最小。\n\n```\n#import \"NSURL+iOS17.h\"\n\n@implementation NSURL (iOS17)\n\n+(void)load {\n    [self sv_swizzleClassMethod:@selector(URLWithString:) withClassMethod:@selector(wt_URLWithString:) error:NULL];\n}\n\n+ (instancetype)wt_URLWithString:(NSString *)URLString {\n    if (@available(iOS 17.0, *)) {\n        return [self URLWithString:URLString encodingInvalidCharacters:NO];\n    } else {\n        return [self wt_URLWithString:URLString];\n    }\n}\n\n@end\n\n```', 'public/uploads/1694331079305.png', 5, 2, 0, 196, '2023-09-10 07:31:21', 1);
INSERT INTO `article` VALUES (31, 3, '作为一名应届生，同时维护两个开源项目是一种什么样的体验🚀🚀🚀', '从今年二月份开始到现在，笔者一直在维护者两个项目，其中一个项目是从 2 月份开始新建文档，到了三月份的时候准备一些春招面试，搁置了一些，到了四月份之后又断断续续进行开发了，直到 6 月中旬才开发出了一个完整版的。\n\n第一个项目是一个前端脚手架，而第二个项目是基于第一个项目开发的，从七月底开始新建文件夹，也是因为一些面试的原因，断断续续的开发了一个多月，目前也是进入了一个能使用的状态，它是一个在线代码编辑器。\n\n在开始之前，先来贴上这两个项目的地址吧：\n\n-   [前端脚手架 create-neat](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fcreate-neat \"https://github.com/xun082/create-neat\")\n-   [在线协同代码编辑器](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fonline-cooperative-edit \"https://github.com/xun082/online-cooperative-edit\")\n\n那么接下来就分别介绍一下这两个项目的基本架构以及未来会做一些什么样的事情吧!\n\n## 前端脚手架 create-neat\n\n这个项目产生的背景就是在刚开始学习 React 的时候，使用的脚手架就是 create-react-app，虽然这个脚手架提供的零配置、开箱即用很适合新手，但是要想对其进行扩展就非常麻烦。要想对其进行扩展你必须 eject 或者 使用 carco 进行配置。\n\n还有另外一个问题就是尽管 Typescript 已经流行了很久，但是要从零设计一个 Typescript 库依旧麻烦，本人也曾有过从零搭建一个 React 组件库的想法，但是对一堆陌生的配置望而生畏。\n\nCreate-Neat 就是为了解决这些问题应运而生的，解决以上所有问题，开箱即用，零配置。\n\n具体一些更详细的信息直接看 Github 文档吧。\n\n## 技术选型\n\n### monorepo 策略\n\n首先项目采用的是 pnpm+monorepo 的策略开发的，至于 pnpm 有多好用就应该不用我说了，为什么采用 monorepo 的架构呢？\n\n下图是整个项目中用到的一些子包，如下图所示：\n\n![20230905083902](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/827d6e19beaa4405bc1c9791e214dd55~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=840&h=743&s=39592&e=png&b=191919)\n\nutils 包为一个公告模块包的，它是使用 ts 去编写的，然后使用 ts 编译出两套代码，一套是 cjs，一套是 esm。\n\n之所以要这样做，是因为 webpack-react、webpack-vue 这两个包是关于的 webpack 的一些配置，所以采用的是 cjs 的方式。\n\n而脚手架 core 和 rollup-script 的配置采用的是 esm 的方式，所以要分别导出两套不同的模式供不同的包使用。\n\n### webpack 核心\n\n整个脚手架的核心就是它是将一个 webpack 封装成了一个 npm 包，然后提供给前端项目使用，使用 bin 命令的方式去启动整个 webpack。\n\n以 webpack-react 为例子，它的目录结构分为以下内容：\n\n```\n├───📁 bin/\n│   └───📄 candy-script.js\n├───📁 config/\n│   ├───📄 env.js\n│   ├───📄 utils.js\n│   ├───📄 webpack.common.js\n│   ├───📄 webpack.dev.js\n│   └───📄 webpack.prod.js\n├───📁 node_modules/\n│   ├───📁 .bin/\n│   │   └───...\n│   ├───📁 @babel/\n│   │   └───...\n│   ├───📁 @laconic/\n│   │   └───...\n│   ├───📁 @obstinate/\n│   ├───📁 @pmmmwh/\n│   │   └───...\n│   └───📁 @typescript-eslint/\n│       └───...\n├───📁 script/\n│   ├───📄 analyzer.js\n│   ├───📄 build.js\n│   └───📄 start.js\n├───📄 package.json\n└───📄 README.md\n```\n\n在 config 目录下的是一些关于的 webpack 配置，那么有认真看的朋友可能会问了，文档里面说的是如何做到的用户可以自定义 webpack 配置呢？\n\n来，直接看代码：\n\n![20230905085047](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf5aa9c44fa48aa8f1e6b7b42639794~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1561&h=549&s=85283&e=png&b=1f1f1f)\n\n首先内部它有一些已经完全配置好了的 webpack 配置，这也是有些人会问项目里面没有一个 webpack 配置也能运行项目的原因了。\n\n它首先会判断你项目中是否有 webpack.config.js 这个人间，然后再去用 require 的方式去读取整个文件，通过整个方式去实现用户自定义 webpack 的方式。\n\n![20230905085743](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ba5f9ce39a4f3b8512f38799184141~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1551&h=748&s=176513&e=png&b=1f1f1f)\n\n那么它整个项目是如何启动的呢？ 首先你会在终端里执行如下命令:\n\n```\npnpm start\nnpm start\n```\n\n然后会执行一个 bin 命令 candy-script,通过 bin 命令会使用 node 开启子进程的方式去执行一个文件，它会根据你输入的参数去执行不同的文件，以 start 为例，它会启动 start.js 文件，在这个文件中，它会获取到 webpack 的所有配置，并且会在这个文件中去设置 devServer 相关信息。\n\n最后将所有的 webpack 配置信息传递给 webpack 提供的函数，执行调用，返回一个 compiler，最后将这个 compiler 传递给 webpack-dev-server 进行启动，如下图所示：\n\n![20230905090329](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6c1b11dab894c6488f95517b684f87e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=900&h=626&s=60637&e=png&b=202020)\n\n最后使用 compiler 去监听不同的声明钩子函数，例如编译完成之后会有什么样的输出，编译的过程中会有什么样的显示：\n\n![20230905090611](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517fa4ccd27f4c5285f256f17a03ef56~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=836&h=155&s=10765&e=png&b=1f1f1f)\n\n### 脚手架核心\n\n脚手架这边就没有什么好说的，它会根据用户的选择，去通过 axios 的方式去下载不同的 npm 的 tgz 文件，然后解压到对应的目录： ![20230905090857](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ac46339a5564de192233ffc932f0345~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=530&h=201&s=10632&e=png&b=181818)\n\n这里是一些相关的模板包，它会被发布到 npm 上面，然后会生成一个对应的 tgz 链接：\n\n![20230905091104](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b420e3e67244aa7ba9e35179ffdd205~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=972&h=633&s=44383&e=png&b=1f1f1f)\n\n这里就是一些相关下载文件的逻辑，详情可以看看源码，这里就不详细讲了：\n\n![20230905091226](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/445689779b9841f38c859ec2e19ed708~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1858&h=738&s=157724&e=png&b=1f1f1f)\n\n> 整个脚手架的架构就大概有这些功能，其中还有很多有趣的事情都没有细讲的。\n\n## 在线代码编辑器\n\n这个项目在不久前就写过一篇文章，这里就不讲了吧，可以直接看这篇文章：\n\n-   [我开源了一个能在浏览器上执行 npm 命令的在线代码编辑器 🚩🚩🚩](https://juejin.cn/post/7272869799960281151 \"https://juejin.cn/post/7272869799960281151\")\n\n这里就再展示一个新增的功能吧，这里全都是使用前端开发的，你应该会很感兴趣！！！\n\n首先打开项目，选择相对应的文件：\n\n![20230905091937](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4efbc3675d4f4fb16d218b1fd83702~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1200&h=624&s=93912&e=png&b=fbfbfb)\n\n这个时候你会跳转到相对应的页面，并且你能看到你所选择的文件，如下图所示：\n\n![20230905092036](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbb081246b0c4cc5a54a2623c8834d20~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=893&h=585&s=23809&e=png&b=222529)\n\n我们在这里去创建一些文件，如下图所示：\n\n![20230905092203](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d7041f75c34d37b0e502b72cf6ddbc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=717&h=535&s=20850&e=png&b=212428)\n\n我们创建了一些文件，并通过下载文件：\n\n![20230905092235](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873b36e657cb42a1a73be860414a0d55~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=597&h=266&s=11834&e=png&b=24272c)\n\n查找到下载的文件，你会发现文件被下载到本地了：\n\n![20230905092436](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/649be57b39204f85bdcfe461a83e90a5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1248&h=683&s=97167&e=png&b=fcfbfb)\n\n做这个功能的需求就是后面会做一些代码分享之类的，或者远程修复 bug，通过这种方式可以上传本地代码到这里，然后保存被修改后的代码到本地。\n\nemmm，大概就讲这些吧。\n\n## 几个月的开源经历，我的所思所想\n\n先来讲讲收获吧，靠着这两个项目，相对于应届生而言，这 star 数也还算可以了，并且项目比较新颖或者特别，并不是说像网上那种烂大街的项目，就简历而言，应该也是加了不少分的。\n\n代码方面，因为这是要面向很多人的，所以要想别人能看得懂，所以会考虑一些编码习惯以及一些代码美化，这样就会慢慢形成一种符合主流的一种编码规范。\n\n再开发的过程中，可能你要实现一个特别难的需求，你会学习到一些新的技术，并且能知道为什么要悬着它，通过这种方式，也是一种提高技术广度的方法。\n\n最主要或者说最开心的事情还是能通过自己的项目能去帮助到别人吧：\n\n![20230905101907](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e06710b5cbd4520bb9bf95c664ca78c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=554&h=505&s=61008&e=png&b=f3f2f2)', 'public/uploads/1694316285463.png', 2, 2, 1, 303, '2023-09-10 03:24:46', 1);
INSERT INTO `article` VALUES (32, 7, '一文带你读懂Spring Security 6.0的实现原理', '## 导言\n\nSpring Security是一个功能强大且高度且可定制的身份验证和访问控制框架，除了标准的身份认证和授权之外，它还支持点击劫持，CSRF，XSS，MITM（中间人）等常见攻击手段的保护，并提供密码编码，LDAP认证，Session管理，Remember Me认证，JWT，OAuth 2.0等功能特性。\n\n由于安全领域本身的复杂性和丰富的安全特性支持，以及Spring Security高度的可定制性，使得它成为一个庞大且复杂的框架。每次升级可能带来的破坏性更新，加上网络上的陈旧教程，更是加重了Spring Security非常难用的印象。很多新手可能跟作者一样，首次引入Spring Security框架之后，突然发现很多页面无法访问，感到无所适从。\n\n为此，本文将基于Spring Boot 3.1.x依赖的Spring Security 6.1.x版本，深入探讨Spring Security的架构和实现原理。本文将着重解释Spring Security的设计思想，而不会过多涉及具体的实现细节。文章的目标是让读者在阅读完本文之后，能够对整个Spring Security框架有个清晰的理解，并在面对问题时知道如何着手排查。另外，本文重点关注Spring Security的总体架构，以及身份认证(Authentication)和鉴权控制(Authorization)的实现。\n\n> 【版本兼容性】Spring Security 6引入了很多破坏性的更新，包括废弃代码的删除，方法重命名，全新的配置DSL等，但是架构和基本原理还是保持不变的。本文在讲解过程中会尽量指出当前版本跟老版本的差异，尤其是涉及到兼容性问题的时候。  \n> 【阅读提示】本文的篇幅较长，并且包含了部分源码分析，时间有限的情况下，可以重点阅读架构图部分。\n\n## Java Web应用的Security实现基本思路\n\n大家可以尝试思考下，安全相关的校验和处理，应该处于应用的哪个部分呢？答案是，应该放在所有请求的入口，因为它是跟具体的业务逻辑无关的，在Spring MVC世界里就是`@Controller`之前。\n\n在JakartaEE(JavaEE的新版)规范中，Filter和Servlet都符合这个前置要求。然而，Spring的Web应用基本上只包含一个`DispatcherServelt`，主要用于请求分发，缺乏安全相关的支持和合适的扩展机制。而Filter运行在Servlet之前，而规范本身就支持配置多个Filter。因此，在请求到达Servlet之前，先通过Filter进行安全验证就是一个非常合理的实现方式。这样可以在请求进入业务逻辑之前，对请求进行拦击，然后进行必要的安全性检查和处理。\n\n这也是Spring Security的实现方式。**本质上，Spring Security的实现原理很简单，就是提供了一个用于安全验证的Filter**。假如我们自己实现一个简化版的Filter，它的大概逻辑应该是这样的：\n\n```\npublic class SimpleSecurityFilter extends HttpFilter {\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        UsernamePasswordToken token = extractUsernameAndPasswordFrom(request);  // (1)\n        if (notAuthenticated(token)) {  // (2)\n            // 用户名密码错误\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); // HTTP 401.\n            return;\n        }\n        if (notAuthorized(token, request)) { // (3)\n            // 当前登录用户的权限不足\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN); // HTTP 403\n            return;\n        }\n        // 通过了身份验证和权限校验，继续执行其它Filter，最终到达Servlet\n        chain.doFilter(request, response); // (4)\n    }\n}\n```\n\n1.  从HTTP请求中获取用户名和密码，来源包括标准的`Basic Auth HTTP Header`，表单字段或者cookie等等。\n2.  身份认证，也就是校验用户名和密码。\n3.  认证通过后，需要检查当前登录的用户有没有访问当前HTTP请求的权限，也就是鉴权逻辑。\n4.  权限校验也通过后，就继续执行其它Filter，所有Filter都通过后，进入Servlet，最终到达具体的Controller。\n\n**FilterChain**\n\n在安全领域，由于攻防手段的多样性和认证鉴权方式的复杂性，将所有功能都放在一个Filter中会导致该Filter迅速演变为一个庞大而复杂的类。\n\n因此，在实际应用场景中，我们常常将这个庞大的Filter拆分成多个小Filter，并将它们链接在一起。每个Filter都只负责特定领域的功能，比如`CsrfFilter`，`AuthenticationFilter`，`AuthorizationFilter`等。\n\n这种概念被称为`FilterChain`，实际上JarkataEE规范也有相识的概念。通过使用`FilterChain`，你就可以以插拔的方式添加或移除特定功能的Filter，而无需改动现有的代码。\n\n## Spring Security框架的基本架构和原理\n\n上一节其实已经说明了Spring Security框架的基本思路，下面我们深入分析其实现原理和架构。\n\n### 实现原理\n\n一个应用引入了`Spring Security Starter`包后，再启动应用，你会发现控制台多了下面这条日志，说明已经开启了Security特性。\n\n```\n2023-07-12T10:05:23.168+08:00  INFO 680540 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Will secure any request with [org.springframework.security.web.session.DisableEncodeUrlFilter@46e3559f, org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@3b83459e, org.springframework.security.web.context.SecurityContextHolderFilter@26837057, org.springframework.security.web.header.HeaderWriterFilter@2d74c81b, org.springframework.security.web.csrf.CsrfFilter@3a17b2e3, org.springframework.security.web.authentication.logout.LogoutFilter@5f5827d0, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@4ed5a1b0, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@3b332962, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@32118208, org.springframework.security.web.authentication.www.BasicAuthenticationFilter@67b355c8, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@991cbde, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@dd4aec3, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@414f87a9, org.springframework.security.web.access.ExceptionTranslationFilter@59939293, org.springframework.security.web.access.intercept.AuthorizationFilter@f438904]\n```\n\n从这条日志可以观察到，Spring Security通过`DefaultSecurityFilterChain`类来完成安全相关的功能，而该类本身又由其它Filter组成。默认情况下，Spring Security Starter引入了15个Filter，下面我们简要介绍下其中几个重要的Filter：\n\n1.  **CsrfFilter**：这个Filter用于防止跨站点请求伪造攻击，这也是导致所有POST请求都失败的原因。基于Token验证的API服务可以选择关闭`CsrfFilter`，而一般Web页面需要开启。\n2.  **BasicAuthenticationFilter**：支持HTTP的标准`Basic Auth`的身份验证模块。\n3.  **UsernamePasswordAuthenticationFilter**：支持Form表单形式的身份验证模块。\n4.  **DefaultLoginPageGeneratingFilter和DefaultLogoutPageGeneratingFilter**：用于自动生成登录页面和注销页面。\n5.  **AuthorizationFilter：** 这个Filter负责授权模块。值得注意的是，在老版本中鉴权模块是`FilterSecurityInterceptor`.\n\n这些Filter构成了Spring Security的核心功能，通过它们，我们可以实现身份验证、授权、防护等安全特性。根据应用的需求，我们可以选择启用或禁用特定的Filter，以定制和优化安全策略。\n\n**SecurityFilterChain**\n\n`DefaultSecurityFilterChain`类实现了`SecurityFilterChain`接口，我们打开这个接口的源码，会发现它只有两个方法，`matches`用于匹配特定的Http请求（比如特定规则的URL），`getFilters` 用于获取可用的所有Security Filter。\n\n```\npublic interface SecurityFilterChain {\n    boolean matches(HttpServletRequest request); // 规则匹配\n    List<Filter> getFilters(); // 该FilterChain下的所有Security Filter\n}\n```\n\n从这段代码可以得出两个结论：\n\n1.  不同的Http请求可以对应不同的`SecurityFilterChain`（通过`matches`方法）。\n2.  `SecurityFilterChain`不是我们以为的JakartaEE的Servlet Filter实现，它仅仅是一个包含多个Filter的容器，本身不负责调度和执行。它只是一个配置项，用于指定一组Filter，以实现特定的安全需求。\n\n**DelegatingFilterProxy**\n\n实际上，JakartaEE层面上的Filter实现是`DelegatingFilterProxy`类，它在Spring Security中起到了一个重要的桥梁作用，连接了Servlet容器和Spring容器。Servlet容器不了解Spring定义的Beans，而Spring Security的大部分组件及其依赖都是注册到Spring容器中的Bean。\n\n`DelegatingFilterProxy`核心代码的主要工作就是从`WebApplicationContext`获取指定名称的Filter Bean，然后委托给这个Bean的`doFilter`方法。以下是简化后的伪代码：\n\n```\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n        throws ServletException, IOException {\n    Filter delegateToUse = this.delegate;\n    if (delegateToUse == null) {\n        synchronized (this.delegateMonitor) {\n            delegateToUse = this.delegate;\n            if (delegateToUse == null) {\n                WebApplicationContext wac = findWebApplicationContext();\n                // 获取Filter Bean并初始化\n                delegateToUse = initDelegate(wac);\n            }\n            this.delegate = delegateToUse;\n        }\n    }\n    // 委托给的delegate对象完成实际的doFilter\n    invokeDelegate(delegateToUse, request, response, filterChain);\n}\n\nprotected Filter initDelegate(WebApplicationContext wac) throws ServletException {\n    // Bean名称配置在SecurityFilterAutoConfiguration.DEFAULT_FILTER_NAME = \"springSecurityFilterChain\"\n    String targetBeanName = getTargetBeanName();\n    // 从容器中获取指定名称的Filter类型Bean\n    Filter delegate = wac.getBean(targetBeanName, Filter.class);\n    if (isTargetFilterLifecycle()) {\n        delegate.init(getFilterConfig());\n    }\n    return delegate;\n}\n```\n\n通过这种方式，`DelegatingFilterProxy`实现了将Servlet容器中的Filter请求委托给Spring容器中的具体Filter Bean处理，从而实现了Servlet容器和Spring容器之间的无缝连接。\n\n**FilterChainProxy**\n\n而这个被委托的Filter Bean的类型就是`FilterChainProxy`，是在`WebSecurityConfiguration`中配置的：\n\n```\n// name = \"springSecurityFilterChain\"\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\npublic Filter springSecurityFilterChain() throws Exception {\n    // 配置SecurityFilterChain\n    boolean hasFilterChain = !this.securityFilterChains.isEmpty();\n    if (!hasFilterChain) {\n        this.webSecurity.addSecurityFilterChainBuilder(() -> {\n            this.httpSecurity.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated());\n            this.httpSecurity.formLogin(Customizer.withDefaults());\n            this.httpSecurity.httpBasic(Customizer.withDefaults());\n            return this.httpSecurity.build();\n        });\n    }\n    for (SecurityFilterChain securityFilterChain : this.securityFilterChains) {\n        this.webSecurity.addSecurityFilterChainBuilder(() -> securityFilterChain);\n    }\n    // WebSecurity自定义配置\n    for (WebSecurityCustomizer customizer : this.webSecurityCustomizers) {\n        customizer.customize(this.webSecurity);\n    }\n    // FilterChainProxy最终是由WebSecurity构建出来的\n    return this.webSecurity.build();\n}\n```\n\n从上面代码可以发现，`FilterChainProxy`对象最终是由`WebSecurity`根据`SecurityFilterChain`和其它一些配置构建出来的。\n\n`FilterChainProxy`主要作用就是查找匹配当前Http请求规则的`SecurityFilterChain`，然后将工作委派给`SecurityFilterChain`的所有Filter。简化后的伪代码如下所示：\n\n```\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    // 获取匹配的所有Filter\n    List<Filter> filters = getFilters(request); \n    // 按顺序执行Filter\n    Filter nextFilter = this.filters.get(this.currentPosition - 1);\n    nextFilter.doFilter(request, response, this);\n}\n\nprivate List<Filter> getFilters(HttpServletRequest request) {\n    for (SecurityFilterChain chain : this.filterChains) {\n        // 返回匹配规则的SecurityFilterChain的Filter列表\n        if (chain.matches(request)) { \n            return chain.getFilters();\n        }\n    }\n    return null;\n}\n```\n\n> 【Tips】`FilterChainProxy`可以认为是整个Spring Security处理请求的一个起点，如果你遇到Security相关问题，又不清楚是具体哪个Filter导致的，就可以从这里开始Debug。\n\n### 基本架构\n\n从上一节的内容，我们可以得出下面这一副架构图（图中蓝色和橘红色的部分代表Security Security）。从图中可以看出，Spring Security框架通过`DelegatingFilterProxy`建立起了Servlet容器和Spring容器的链接，`FilterChainProxy`基于匹配规则（比如URL匹配），决定使用哪个`SecurityFilterChain`。而`SecurityFilterChain`又由零到多个Filter组成，这些Filter完成实际的功能。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ff073831ea45c08d8872070c8b1b9e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n**Security Filter和配置DSL**\n\nSpring Security是基于Jakarta EE的Filter实现的，而在此基础上，它提供了一套自身的Filter机制，相当于两层的Filter嵌套。为了不混淆这两种Filter，我们把Spring Security框架提供的Filter称为Security Filter。在下文中，我们所提及的配置，扩展和自定义的Filter都指的是Security Filter，如果没有特别说明，都默认指的是Security Filter。\n\n通过一系列Security Filter，Spring Security提供了丰富的开箱即用的安全功能，包括身份认证，鉴权，Csrf等等。每个功能都是通过一个或者多个Security Filter实现的。有些复杂的Filter，例如身份认证和鉴权，拥有自己的特定架构，并且会依赖Filter的顺序和执行过程中的上下文信息，这也是导致Spring Security在使用上相对复杂的原因之一。\n\nSpring Securiy的基本配置都是通过自定义`SecurityFilterChain`的Bean来实现的。下面是一个示例配置，它提供了自定义的登录页面，并且针对不同的URL配置了不同的角色权限，这些配置方法实际上就是配置不同的Security Filter，更详细的解释会在后面讲解具体特性的时候时展开说明。\n\n```\n@Bean\nstatic SecurityFilterChain mySecurityFilterChain(HttpSecurity http) throws Exception {\n    // 鉴权相关配置\n    http.authorizeHttpRequests((requests) ->\n            request.requestMatchers(\"/admin\").hasAuthority(\"ROLE_ADMIN\") // \"/admin\"要求有“ROLE_ADMIN\"角色权限\n                    .requestMatchers(\"/hello\").hasRole(\"USER\") // \"/hello\"要求有\"ROLE_USER\"角色权限\n                    .anyRequest().authenticated()); // 其它只需要身份认证通过即可，不需要其它特殊权限\n    // 登录相关配置\n    http.formLogin(formLogin -> formLogin\n            .loginPage(\"/authentication\") // 自定义登录页面，不再使用内置的自动生成页面\n            .permitAll() // 允许自定义页面的匿名访问，不需要认证和鉴权\n    );\n    return http.build(); // 返回构建的SecurityFilterChain实例\n}\n```\n\n> 【版本兼容性】Spring Security 6.0在配置方面引入了许多改变。在之前的老版本中，可以选择废弃的`WebSecurityConfigurerAdapter`进行配置，但从6.0版本开始，这个废弃类已经被删除了。而目前很多老项目以及网上的教程仍在使用`WebSecurityConfigurerAdapter`。 另外，配置DLS也发生了变化。Spring Security 6.0采用了基于Lambda表达式的DSL配置方式，取代了之前的纯链式调用方式，使得配置更加灵活和直观。一些方法名称也进行了修改，例如`antMatchers`替换为`requestMatchers`。\n\n除了Spring Boot的专有配置，Spring Security自身也提供了默认配置，这些默认配置在`HttpSecurityConfiguration#httpSecurity`方法中，它默认添加了很多Security Filter，核心代码如下：\n\n```\n@Bean(HTTPSECURITY_BEAN_NAME)\n@Scope(\"prototype\")\nHttpSecurity httpSecurity() throws Exception {\n    // ... //\n    http\n        .csrf(withDefaults())\n        .addFilter(webAsyncManagerIntegrationFilter)\n        .exceptionHandling(withDefaults())\n        .headers(withDefaults())\n        .sessionManagement(withDefaults())\n        .securityContext(withDefaults())\n        .requestCache(withDefaults())\n        .anonymous(withDefaults())\n        .servletApi(withDefaults())\n        .apply(new DefaultLoginPageConfigurer<>());\n    http.logout(withDefaults());\n    // ... //\n    return http;\n}\n```\n\n以上解释了Spring Security的实现原理和基本架构，而具体到特定的Security Filter，又有各种的框架，下面将展开说明认证和鉴权两个核心模块。\n\n## Authentication身份认证\n\n身份认证有很多种方式，大致可以分为以下4类：\n\n1.  标准的账号密码认证：这是很多网站都支持的方式，也是大家最熟悉的认证模式；\n2.  调用第三方服务或内部其它API进行认证：当服务自身无法直接获取用户的密码时，需要借助第三方服务或者内部API进行认证；\n3.  基于Token的认证：这是API服务一般使用的认知方式，通过令牌来进行身份验证；\n4.  OAuth2或其它OpenID认证：这种方式广泛用于允许用户使用其它平台的身份信息进行登录，例如微信登录，Google登录等。\n\nSpring Security支持大部分的认证方式，但不同的认证方式需要配置不同的Bean及其依赖Bean，否则很容易遇到各种异常和空指针。\n\n本文重点讨论标准的账号密码认证方式。\n\n### 实现原理\n\n如果你使用的是Spring Boot，那么Spring Boot Starter Security默认就配置了Form表单和Basic认证方式，其配置代码如下所示：\n\n```\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET)\nclass SpringBootWebSecurityConfiguration {\n    @Configuration(proxyBeanMethods = false)\n    @ConditionalOnDefaultWebSecurity\n    static class SecurityFilterChainConfiguration {\n        @Bean\n        @Order(SecurityProperties.BASIC_AUTH_ORDER)\n        SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {\n            http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); // 所有URL都需要认证用户\n            http.formLogin(withDefaults()); // 支持form表单认证，默认配置提供了自动生成的登录和注销页面\n            http.httpBasic(withDefaults()); // 支持HTTP Basic Authentication\n            return http.build();\n        }\n\n    }\n    // ...其它配置...\n}\n```\n\n为了讨论方便，我们用下面的配置覆盖Spring Boot默认的配置，只支持Form表单认证方式，讨论它具体是如何实现的。\n\n```\n@Configuration()  \npublic class MySecurityConfig {\n    @Bean\n    SecurityFilterChain mySecurityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); // (1)\n        http.formLogin(withDefaults()); // (2)\n        return http.build();\n    }\n}\n```\n\n1.  `authorizeHttpRequests`方法用于配置每个请求的权限控制，这里要求所有请求都要通过认证后才能访问。实际上，这个方法配置的更多是鉴权相关的内容，跟身份认证的关联较小，它本质上是增加了一个`AuthorizationFilter`用于鉴权，具体细节在鉴权部分会详细说明。\n2.  `http.formLogin`方法提供了Form表单认证的方式，`withDefaults`方法是Form表单认证的默认配置。这段配置的作用就是增加了用于账号密码认证的`UsernamePasswordAuthenticationFilter`，以及自动生成登录页面和注销页面的`DefaultLogoutPageGeneratingFilter`和`DefaultLogoutPageGeneratingFilter`共3个Security Filter。值得注意的是，登录页面和注销页面这两个Filter是配合`DefaultLoginPageConfigurer`配置一起注册的。如果你通过`formLogin.loginPage`提供了自定义的登录页面，那么这两个Filter就不会被注册。\n\n在本节中，我们主要讨论身份认证的实现，因此，接下来将详细探究Form表单认证方式中`UsernamePasswordAuthenticationFilter`的实现。\n\n**AbstractAuthenticationProcessingFilter**\n\n对于Filter，我们重点分析它的`doFilter`方法的源码。实际上，它继承了抽象类`AbstractAuthenticationProcessingFilter`，而这个抽象类的`doFilter`是一个模板方法，定义了整个认证流程。其核心流程非常简单，伪代码如下：\n\n```\nprivate void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n        throws IOException, ServletException {\n    // 首先判断该请求是否是认证请求或者登录请求\n    if (!requiresAuthentication(request, response)) { // (1)\n        chain.doFilter(request, response);\n        return;\n    }\n    try {\n        Authentication authenticationResult = attemptAuthentication(request, response); // (2) 实际认证逻辑\n        // 认证成功\n        successfulAuthentication(request, response, chain, authenticationResult); // (3)\n    }\n    catch (AuthenticationException ex) {\n        // 认证失败\n        unsuccessfulAuthentication(request, response, ex); // (4)\n    }\n}\n```\n\n1.  首先`requiresAuthentication`方法用于判断当前请求是否为认证请求或者登录请求，例如通常是`POST /login`。只有在登录认证的情况下，才需要通过这个Filter；\n2.  `attempAuthentication`方法是实际的认证逻辑，这是一个抽象方法，具体的逻辑由子类重写实现。它的规范行为是，如果认证成功，应该返回认证结果`Authentication`，否则以抛出异常`AuthenticationException`的方式表示认证失败；\n3.  `successfulAuthentication`：**认证成功后，该方法会将`Authentication`对象放到Security Context中，这是非常关键的一步，后续需要认证结果的时候都是从Security Context获取的，比如鉴权Filter**。此外，该方法还会处理其它一些相关功能，比如RememberMe，事件发布，最后再调用`AuthenticationSuccessHandler`；\n4.  `unsuccessfulAuthentication` ：在认证失败后，它会清空Security Context，调用RememberMe相关服务和`AuthenticationFailureHandler`来处理认证失败后的回调逻辑，比如跳转到错误页面。\n\n**Authentication模型**\n\n在这里，我们涉及到了一个非常重要的数据模型——`Authentication`，它是一个接口类型，它既是对认证结果的一个抽象表示，同时也是对认证请求的一个抽象，通常也被称为认证Token。它的方法都比较抽象，定义如下：\n\n```\npublic interface Authentication extends Principal, Serializable {\n    // 当前认证用户拥有的权限列表\n    Collection<? extends GrantedAuthority> getAuthorities();\n    // 用户的一个身份标识，通常就是用户名\n    Object getPrincipal();\n    // 可用于证明用户身份的一个凭证，通常就是用户密码\n    Object getCredentials();\n    // 当前用户是否认证通过\n    boolean isAuthenticated();\n    // 更新用户的认证状态\n    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;\n    // 获取附加的详情信息，比如原始的Http请求体等。\n    Object getDetails();\n}\n```\n\n具体的`Authentication`实现一般都命名为`XXXToken`，大部分都继承自抽象类`AbstractAuthenticationToken`，比如表示标准的用户名密码认证结果的`UsernamePasswordAuthenticationToken`，表示匿名登录用户认证结果的`AnonymousAuthenticationToken`等等，你也可以完全实现自己的`Authentication`。\n\n**attempAuthentication方法**\n\n接下来，我们看下`UsernamePasswordAuthenticationFilter`的认证具体实现方法`attempAuthentication`，它的源码如下：\n\n```\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)\n        throws AuthenticationException {\n    // 默认只支持POST请求\n    if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n        throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n    }\n    // 从form表单获取用户名和密码\n    String username = obtainUsername(request);\n    username = (username != null) ? username.trim() : \"\";\n    String password = obtainPassword(request);\n    password = (password != null) ? password : \"\";\n    // 构建一个用于认证的请求\n    UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username,\n            password);\n    // 附加详细信息，比如请求体，有些认证方式需要除了用户名密码外更多的信息\n    setDetails(request, authRequest);\n    // 委托给AuthenticationManager做具体的认证\n    return this.getAuthenticationManager().authenticate(authRequest);\n}\n```\n\n这个方法非常简单，它主要进行一些前置校验工作，从请求体中获取用户名和密码，并构建认证请求对象。然后，剩余的认证工作都是委托给`AuthenticationManager`接口来完成的，该接口的定义如下：\n\n```\npublic interface AuthenticationManager {\n    Authentication authenticate(Authentication authentication) throws AuthenticationException;\n}\n```\n\n**AuthenticationManager和AuthenticationProvider**\n\n`AuthenticationManager`接口只有一个方法，它的入参和出参都是`Authentication`对象。通常情况下，入参提供了必要的认证信息，例如用户名和密码。而在认证成功后，该方法会返回认证结果，并附加认证状态，用户拥有的权限列表等信息。如果认证失败，它会抛出`AuthenticationException`异常类的子类，其中包括`DisabledException`，`LockedException`和`BadCredentialsException`等账号相关的异常。\n\n`AuthenticationManager`接口定义了Spring Security的认证行为。你可以提供自定义的实现，Spring Security也提供了一个通用的实现类`ProviderManager`。`ProviderManager`将具体的认证工作委托给一系列的`AuthenticationProvider`。\n\n每个`AuthenticationProvider`对应不同的认证方式。比如最常见的用户名密码的认证实现是`DaoAuthenticationProvider`，而`JwtAuthenticationProvider`提供了JWT Token的认证。你可以通过添加不同的`AuthenticationProvider`的方式，在同一个服务内支持多种类型的认证方式，比如需要调用其它API检验密码的情况，就需要自定义`AuthenticationProvider`。\n\n此外，`ProviderManager`还可以配置父级`AuthenticationManager`，当这个`ProviderManager`的所有`AuthenticationProvider`都不支持所需的认证方式时，它会继续委托给父级的`AuthenticationManager`，而该父级通常也是一个`ProviderManager`类型。\n\n**UserDetailsService和PasswordEncoder**\n\n`DaoAuthenticationProvider`是最常用的认证实现之一，它通过`UserDetailsService`和`PasswordEncoder`来验证用户名和密码。\n\n`UserDetailsService`的作用是查找用户信息`UserDetails`，这些信息包括用户密码，状态，权限列表等。用户信息可以存储在内存，数据库或者其它任何地方。Spring Security默认的配置是内存存储，对应的`UserDetailsService`实现是`InMemoryUserDetailsManager`，而数据库存储则对应`JdbcUserDetailsManager`。\n\n从`UserDetailsService`获取到用户密码后，需要通过`PasswordEncoder`来验证密码的正确性。因为密码一般都不应该以明文形式存储，实际存储的是按一定规则编码后的文本，Spring Security支持多种编码方式，例如`bcrypt`，`argon2`，`scrypt`，`pbkdf2`等。你可以配置`PasswordEncoder` Bean来选择不同的编码方式。都是请注意，内置的编码方式默认对编码后的文本有一个格式要求，就是必须有类似`{bcrypt}`的前缀来表示编码方式。\n\n### 基本架构\n\n**架构图**\n\n上一节中，我们讲述了用户名密码认证的实现细节，现在，让我们以用户名密码认证方式为例，从整体上来看下身份认证的架构和流程。它的整体架构如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3a6433f7b04dd28314edd82889ff34~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n1.  当一个HTTP请求进来后，`UsernamePasswordAuthenticationFilter`会从HTTP请求体中获取用户名和密码，然后使用这些信息创建一个`UsernamePasswordAuthenticationToken`对象作为认证请求的参数。\n2.  接下来，`AuthenticationManager`（其实现类是`ProviderManager`）负责对接受到的`UsernamePasswordAuthenticationToken`进行认证。\n3.  `ProviderManager`会遍历配置的所有`AuthenticationProvider`，查找支持`UsernamePasswordAuthenticationToken`类型的`AuthenticationProvider`，然后委托其进行实际的认证工作，而在这里，匹配的就是`DaoAuthenticationProvider`。\n4.  `DaoAuthenticationProvider`首先调用`UserDetailService`获取用户信息，然后将获取到的密码（通常是编码后的密码）委托给`PasswordEncoder`进行验证。如果认证失败，`DaoAuthenticationProvider`会抛出`AuthenticationException`的子类表示认证失败。\n5.  当认证成功时，`AuthenticationManager`会返回一个`UsernamePasswordAuthenticationToken`对象作为认证结果，这个对象除了包含用户的基本信息外，最重要的是认证通过状态以及该用户拥有的权限列表，这些信息在后续的鉴权模块会用到。\n6.  认证结果会被放入`SecurityContext`，这样后续的模块（包括鉴权和用户业务模块等）如果需要这个结果（包括用户信息和权限列表），就可以通过以下方法获取：`SecurityContextHolder.getContext().getAuthentication()`。\n\n**组件替换**\n\n这个架构非常灵活，大部分组件都是可配置和可替换的，自底向上，我们分别可以替换以下组件来满足特定需求：\n\n1.  `UserDetailsService`：根据用户名查找用户信息的组件，默认配置的是内存存储`InMemoryUserDetailsManager`，你也可以配置为内置的数据库存储`JdbcUserDetailsManager`，但是它有很多默认的约定要遵守，对未来的扩展也不够灵活。通常会根据公司的规范要求或数据库存储的方式提供自定义的实现。\n2.  `PasswordEncoder`：对密码进行编码的组件，建议根据公司的编码要求或当前数据库中已使用的编码来配置。如果没有特殊要求，建议采用默认的`BCryptPasswordEncoder`。\n3.  `AuthenticationProvider`: 为了安全需要，公司内部很多应用是不允许直接访问用户的密码的，而通常会提供一个认证的API。此时，就需要自定义`AuthenticationProvider`，它的核心逻辑就是调用API做认证，然后把结果再包装成`Authentication`返回给`AuthenticationManager`。\n4.  `AuthenticationManager`：它的默认实现`ProviderManager`适用于大部分场景，通常不需要替换，除非你不想引入太多的概念。\n5.  `UsernamePasswordAuthenticationFilter`：如果你不想引入过多的概念和复杂度，可以提供自己的Security Filter，从而完全脱离该框架。**但是需要确保认证结果模型`Authentication`仍然被正确处理，并且将结果通过方法`SecurityContextHolder.getContext().setAuthentication`放入Security Context中。**\n\n> 【Tips】从整个Security框架的角度来看，认证模块的核心概念只有两个，分别是认证结果`Authentication`和`Security Context`。其它概念都可以认为是认证模块的内部实现细节。\n\n## 鉴权模块Authorization\n\n认证模块证明了用户的身份，但显然普通用户不应该可以随意访问管理页面或敏感资源，因此还需要有个模块来确保只有授权的用户才能执行特定的操作，这个模块称之为鉴权或者授权(Authorization)。\n\n当你通过`HttpSecurity.authorizeHttpRequests`方法来配置请求的访问权限控制时，就会自动添加鉴权的Security Filter：`AuthorizationFilter`，它是整个`SecurityFilterChain`的最后一个Filter。\n\n> 【版本兼容性】在Spring Security 6.0版本中，鉴权模块发生了很大变化。以前的版本中，鉴权模块使用`FilterSecurityInterceptor`，而6.0版本之后，这个被废弃了，取而代之的是`AuthorizationFilter`。同时，还有一些相关的依赖组件，如`AccessDecisionManager`和`AccessDecisionVoter`也被`AuthorizationManger`替换了。因此，本节的内容只限于6.0以及之后的版本。\n\n### 实现原理\n\n我们先看下鉴权模块的入口，也就是`AuthorizationFilter`的`doFilter`方法：\n\n```\n@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n        throws ServletException, IOException {\n    // ...其它非核心逻辑... //\n    try {\n        AuthorizationDecision decision = this.authorizationManager.check(this::getAuthentication, request); // （1）\n        this.eventPublisher.publishAuthorizationEvent(this::getAuthentication, request, decision);\n        if (decision != null && !decision.isGranted()) { // （2）\n            throw new AccessDeniedException(\"Access Denied\");\n        }\n        chain.doFilter(request, response);\n    }\n    finally {\n        request.removeAttribute(alreadyFilteredAttributeName);\n    }\n}\n\nprivate Authentication getAuthentication() {\n    Authentication authentication = this.securityContextHolderStrategy.getContext().getAuthentication(); // （3）\n    if (authentication == null) {\n        throw new AuthenticationCredentialsNotFoundException(\n                \"An Authentication object was not found in the SecurityContext\");\n    }\n    return authentication;\n}\n```\n\n1.  这个方法本身很简单，核心逻辑都委托给了`AuthorizationManager`。`AuthorizationManager`会校验`Authentication`的权限，并返回鉴权的结果`AuthorizationDecision`。\n2.  如果当前认证用户没有访问权限，就会抛出`AccessDeniedException`异常，表示拒绝访问。\n3.  待校验的`Authentication`是从Security Context获取的，通常是在前面的认证阶段设置的。在这里，实际上传给`AuthorizationManager`的是一个获取`Authentication`的方法，而不是`Authentication`本身，这样就把实际的获取操作延后到了真正进行授权的时候，这在某些场景下可以提高性能，比如`permitAll`，实际上它根本用不到`Authentication`。\n\n**AuthorizationManager**\n\n`AuthorizationManager`才是真正执行鉴权逻辑的类，最常用的实现类是`AuthorityAuthorizationManager`，它的实现逻辑很简单，它会调用`Authentication`的`getAuthorities`方法，获取当前登录用户的权限列表，然后将这些权限与请求需要的权限进行匹配。\n\n实际上，选择使用哪个`AuthorizationManager`是开发手动设置的。我们来分析一个常用的权限配置代码片段：\n\n```\n@Bean\nstatic SecurityFilterChain mySecurityFilterChain(HttpSecurity http) throws Exception {\n    http.authorizeHttpRequests((requests) -> // （1）\n            requests\n                    .requestMatchers(\"/admin\").hasAuthority(\"ROLE_ADMIN\") // （2）\n                    .requestMatchers(\"/hello\").hasRole(\"USER\") // （3）\n                    .anyRequest().authenticated()); // （4）\n    // ... 其它配置 ... //\n    return http.build();\n}\n```\n\n1.  调用`authorizeHttpRequests`方法就相当于打开了鉴权模块，它会注册`AuthorizationFilter`到`SecurityFilterChain`的最后。\n2.  对于匹配`/admin`的请求，要求有`ROLE_ADMIN`权限。`hasAuthority`的底层就是配置了一个要求`ROLE_ADMIN`权限的`AuthorityAuthorizationManager`对象。\n3.  对于匹配`/hello`的请求，要求有`USER`角色，等价于`ROLE_USER`权限。`hasRole`会自动在角色名称前面加上前缀`ROLE_`。`hasRole`的底层就是配置了一个要求`ROLE_USER`权限的`AuthorityAuthorizationManager`对象。\n4.  对于其它的请求，只要通过身份认证就可以访问，不需要特定的权限。类似的，`authenticated`方法的底层配置了一个`AuthenticatedAuthorizationManager`对象。\n\n在Spring Security中，很多初学者都容易混淆`Role`和`Authority`的区别，实际上在技术实现层面上，这两者没有本质区别，底层都仅仅是一个表示权限的字符串标识符。更多的区别在于权限管理的概念上，一般情况下，`Authority`表示细粒度的操作权限，比如`ADD_USER`，`DELETE_USER`等，通常是动词；而`Role`则会与实际业务角色想对应，比如管理员`ADMIN`，普通员工`STAFF`等，通常是名称。此外，一般一个`Role`会对应多个`Authority`，同时角色之间可以存在继承关系，比如`ADMIN`可以继承`STAFF`的所有权限。\n\n写作我们来看下`hasAuthority`的源码，以分析它是如何配置`AuthorizeManager`的：\n\n```\npublic AuthorizationManagerRequestMatcherRegistry hasAuthority(String authority) {\n    return access( // （3）\n      withRoleHierarchy( //（2）\n          AuthorityAuthorizationManager.hasAuthority(authority) // （1）\n      )\n    );\n}\n\npublic static <T> AuthorityAuthorizationManager<T> hasAuthority(String authority) {\n    Assert.notNull(authority, \"authority cannot be null\");\n    return new AuthorityAuthorizationManager<>(authority);\n}\n\npublic AuthorizationManagerRequestMatcherRegistry access(\n        AuthorizationManager<RequestAuthorizationContext> manager) {\n    Assert.notNull(manager, \"manager cannot be null\");\n    return AuthorizeHttpRequestsConfigurer.this.addMapping(this.matchers, manager);\n}\n\nprivate AuthorityAuthorizationManager<RequestAuthorizationContext> withRoleHierarchy(           \nAuthorityAuthorizationManager<RequestAuthorizationContext> manager) {\n    manager.setRoleHierarchy(AuthorizeHttpRequestsConfigurer.this.roleHierarchy.get());\n    return manager;\n}\n```\n\n1.  `AuthorityAuthorizationManager.hasAuthority`方法简单地创建了一个要求特定`authority`权限的`AuthorityAuthorizationManager`实例。\n2.  `withRoleHierarchy`是一个装饰器方法，它打开了角色继承的功能。角色继承允许一个角色继承另一个角色的所有权限，从而简化权限配置。\n3.  最后，`access`方法将这个`AuthorityAuthorizationManager`实例注册到权限控制中。\n\n`access`方法是公开的，你可以自己实现一个`AuthorizationManager`，然后通过这个方法进行注册。例如，我们可以提供一个拒绝所有请求的实现：\n\n```\nhttp.authorizeHttpRequests((requests) ->\n    requests.anyRequest().access((authentication, object) -> null));\n```\n\n> 【Tips】通过自定义`AuthorizationManager`，我们可以完全接管鉴权的逻辑，实现更加灵活和复杂的权限控制。\n\n### 基本架构\n\n相比认证模块，鉴权模块不需要太多的灵活性和扩展性需求，因此它的架构相对简单。\n\n同样，我们以一个标准的鉴权流程为例，来看整体的架构和流程图。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0181aa081281469ea5ea23bfabfcec10~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n1.  一个HTTP请求进来，经过了一系列Security Filter后，最终来到`AuthorizationFilter`，进而调用`AuthorizationManager#check`方法进行权限校验。\n2.  实际的校验工作继续委托给`AuthoritiesAuthorizationManager`。\n3.  `AuthoritiesAuthorizationManager`先从Security Context中获取到`Authentication`对象（这个对象一般是前面的某个认证Filter设置的），然后基于其`Authorites`权限列表构建`GrantedAuthority`列表，用于权限项的匹配。\n4.  最终会返回一个`AuthorizationDecision`表示权限校验结果。\n\n## 总结\n\n本文重点分析了Spring Security的源码和架构，帮助读者理解其实现原理。由于篇幅有限，本文只覆盖了身份认证和鉴权模块的核心逻辑，很多特性没有涉及，包括Session管理，Remember Me服务，异常分支和错误处理等等，不过有了上述的基础知识，读者完全可以自己分析源码并深入理解这些特性。\n\n## FAQ\n\n**认证和鉴权失败抛出的异常是如何处理的？**\n\n当发生认证或鉴权失败时，Spring Security有专门的Security Filter `ExceptionTranslationFilter`来捕获并处理这些异常。如果是认证异常错误`AuthenticationException`及其子类，会触发`AuthenticationEntryPoint#commence`方法，而如果是鉴权错误`AccessDeniedException`及其子类，则会触发`AccessDeniedHandler#handle`方法。\n\n**一个请求被Security拒绝了，应该如何Debug排查？**\n\n如果遇到身份认证错误，建议直接Debug相关Filter的`doFilter`方法，比如Form表单登录的Filter就是`UsernamePasswordAuthenticationFilter`；而如果是鉴权错误，可以从`AuthorizationFilter`开始Debug。\n\n但需要注意的是，出于安全考虑，Security相关的错误通常不会提供明确的错误信息，甚至不会显示错误信息，而是直接跳转到登录页面，比如`CsrfFilter`可能会导致这种情况。在这种情况下，可以从第一个Filter开始Debug，启动日志搜索`Will secure any request with`，就可以找到所有Security Filter列表。或者直接从入口`FilterChainProxy#doFilter`开始Debug。\n\n**SecurityFilterChain的配置方法底层是如何实现的？**\n\n`SecurityFilterChain`是通过`HttpSecurity`提供的一套DSL进行配置的。诸如`formLogin`，`csrf`，`authorizeHttpRequests`等方法的逻辑都类似，参数都是一个lambda表达式，用于做各种自定义配置。而每个方法都会对应一个特定的配置类，比如`FormLoginConfigurer`，`CsrfConfigurer`等，在执行`HttpSecurity#build`方法的时候，会调用这些配置类的`configure`方法，该方法的作用就是根据用户的自定义配置，创建一个或者多个Security Filter，并将其注册到`SecurityFilterChain`。\n\n此外，开发者还可以通过`HttpSecurity.addFilter`方法直接添加自定义的Security Filter。而对于复杂且有许多配置选项的Filter，也可以自定义`SecurityConfigurerAdapter`类，并通过`HttpSecurity#apply`方法来配置和注册Filter。\n\n**Spring Security Starter有哪些默认配置？**\n\nSpring Security Starter默认配置在`spring-boot-autoconfigure-x.x.x`包下的文件`META-INF\\spring\\org.springframework.boot.autoconfigure.AutoConfiguration.imports`中可以找到。而具体的核心配置类有`HttpSecurityConfiguration`和`SpringBootWebSecurityConfiguration`。\n\n**Spring Security版本跟本文的不一样，遇到问题如何排查？**\n\n每次Spring Security升级，尤其是大版本升级，都可能引入破坏性或者不兼容的更新。不过，基于Filter和SecuiryFilterChain的框架和架构通常是不会改变的。但是，通常会废弃掉老的配置方法，引入新的配置，某些特定模块的实现也有可能完全替换，比如6.0的鉴权模块`AuthorizationFilter`就完全替换了老的鉴权模块。\n\n你可以先从Security Filter列表开始排查，也可以通过入口`FilterChainProxy#doFilter`来Debug。\n\n**Spring Security整体太复杂了，能不能不使用它，而完全自己实现？**\n\nSecurity是个一个非常复杂的领域，很多开发者对其了解不深。使用Spring Security不仅提供了大部分的安全特性，还包含了很多安全领域的最佳实践。自己从头实现安全功能成本很高，并可能缺乏一些重要的安全特性。不过Spring Security的复杂设计以及频繁的破坏性更新，的确给开发带来了很大的学习成本和维护成本。\n\nSpring Security的架构非常灵活，因此作者的建议是，不需要完全照搬整体框架，对于不同的应用类型和场景，可以选择性地引入部分功能。比如Admin应用可以提供自定义的`AuthenticationProvider`，而API服务完全可以自定义Securiy Filter，只要维护好Security Context的`Authentication`，就可以很好的集成到Spring Security框架里，同时开发的学习和维护成本也能降到最低。', 'public/uploads/1694354659231.png', 3, 4, 1, 725, '2023-06-10 14:04:20', 1);
INSERT INTO `article` VALUES (33, 2, '都用HTTPS了，还能被查出浏览记录？', '大家好，我卡颂。1\n\n最近，群里一个刚入职的小伙因为用公司电脑访问奇怪的网站，被约谈了。他很困惑 —— 访问的都是`HTTPS`的网站，公司咋知道他访问了啥？\n![](http://127.0.0.1:3000/public/uploads/1697547449784.png)\n\n\n实际上，由于网络通信有很多层，即使加密通信，仍有很多途径暴露你的访问地址，比如：\n\n-   `DNS`查询：通常`DNS`查询是不会加密的，所以，能看到你`DNS`查询的观察者（比如运营商）是可以推断出访问的网站\n    \n-   `IP`地址：如果一个网站的`IP`地址是独一无二的，那么只需看到目标 `IP`地址，就能推断出用户正在访问哪个网站。当然，这种方式对于多网站共享同一个`IP`地址（比如`CDN`）的情况不好使\n    \n-   流量分析：当访问一些网站的特定页面，可能导致特定大小和顺序的数据包，这种模式可能被用来识别访问的网站\n    \n-   `cookies`或其他存储：如果你的浏览器有某个网站的`cookies`，显然这代表你曾访问过该网站，其他存储信息（比如`localStorage`）同理\n    \n\n除此之外，还有很多方式可以直接、间接知道你的网站访问情况。\n\n本文将聚焦在`HTTPS`协议本身，聊聊只考虑`HTTPS`协议的情况下，你的隐私是如何泄露的。\n\n欢迎围观朋友圈、加入[人类高质量前端交流群](https://juejin.cn/user/1943592291009511/pins \"https://juejin.cn/user/1943592291009511/pins\")，带飞\n\n## HTTPS简介\n\n我们每天访问的网站大部分是基于`HTTPS`协议的，简单来说，`HTTPS` = `HTTP` + `TLS`，其中：\n\n-   `HTTP`是一种应用层协议，用于在互联网上传输超文本（比如网页内容）。由于`HTTP`是明文传递，所以并不安全\n    \n-   `TLS`是一种安全协议。`TLS`在传输层对数据进行加密，确保任何敏感信息在两端（比如客户端和服务器）之间安全传输，不被第三方窃取或篡改\n    \n\n所以理论上，结合了`HTTP`和`TLS`特性的`HTTPS`，在数据传输过程是被加密的。但是，`TLS`建立连接的过程却不一定是加密的。\n\n### TLS的握手机制\n\n当我们通过`TLS`传递加密的`HTTP`信息之前，需要先建立`TLS`连接，比如：\n\n-   当用户首次访问一个`HTTPS`网站，浏览器开始查询网站服务器时，会发生`TLS`连接\n    \n-   当页面请求`API`时，会发生`TLS`连接\n    \n\n建立连接的过程被称为**TLS握手**，根据`TLS`版本不同，握手的步骤会有所区别。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d9f087a271a4d25af68367ba1f95803~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n但总体来说，**TLS握手**是为了达到三个目的：\n\n1.  协商协议和加密套件：通信的两端确认接下来使用的`TLS`版本及加密套件\n    \n2.  验证省份：为了防止“中间人”攻击，握手过程中，服务器会向客户端发送其证书，包含服务器公钥和证书授权中心（即`CA`）签名的身份信息。客户端可以使用这些信息验证服务器的身份\n    \n3.  生成会话密钥：生成用于**加密接下来数据传输**的密钥\n    \n\n## TLS握手机制的缺点\n\n虽然`TLS`握手机制会建立安全的通信，但在握手初期，数据却是明文发送的，这就造成**隐私泄漏**的风险。\n\n在握手初期，客户端、服务端会依次发送、接收对方的**打招呼信息**。首先，客户端会向服务端打招呼（发送**client hello信息**），该消息包含：\n\n-   客户端支持的`TLS`版本\n    \n-   支持的加密套件\n    \n-   一串称为**客户端随机数**（`client random`）的随机字节\n    \n-   `SNI`等一些服务器信息\n    \n\n服务端接收到上述消息后，会向客户端打招呼（发送**server hello消息**），再回传一些信息。\n\n其中，`SNI`（`Server Name Indication`，服务器名称指示）就包含了用户访问的网站域名。\n\n那么，握手过程为什么要包含`SNI`呢？\n\n这是因为，当多个网站托管在一台服务器上并共享一个`IP`地址，且每个网站都有自己的`SSL`证书时，那就没法通过`IP`地址判断客户端是想和哪个网站建立`TLS`连接，此时就需要**域名信息**辅助判断。\n\n打个比方，快递员送货上门时，如果快递单只有收货的小区地址（`IP`地址），没有具体的门牌号（域名），那就没法将快递送到正确的客户手上（与正确的网站建立`TLS`连接）。\n\n所以，`SNI`作为`TLS`的扩展，会在`TLS`握手时附带上域名信息。由于打招呼的过程是明文发送的，所以在建立`HTTPS`连接的过程中，中间人就能知道你访问的域名信息。\n\n企业内部防火墙的访问控制和安全策略，就是通过分析`SNI`信息完成的。\n\n> 虽然防火墙可能已经有授信的证书，但可以先分析`SNI`，根据域名情况再判断要不要进行深度检查，而不是对所有流量都进行深度检查\n\n那么，这种情况下该如何保护个人隐私呢？\n\n## Encrypted ClientHello\n\n[Encrypted ClientHello](https://link.juejin.cn/?target=https%3A%2F%2Fblog.cloudflare.com%2Fencrypted-client-hello%2F \"https://blog.cloudflare.com/encrypted-client-hello/\")（`ECH`）是`TLS`1.3的一个扩展，用于加密`Client Hello`消息中的`SNI`等信息。\n\n当用户访问一个启用`ECH`的服务器时，网管无法通过观察`SNI`来窥探域名信息。只有目标服务器才能解密`ECH`中的`SNI`，从而保护了用户的隐私。\n\n> 当然，对于授信的防火墙还是不行，但可以增加检查的成本\n\n开启`ECH`需要同时满足：\n\n-   服务器支持`TLS`的`ECH`扩展\n    \n-   客户端支持`ECH`\n    \n\n比如，[cloudflare SNI测试页](https://link.juejin.cn/?target=https%3A%2F%2Fcrypto.cloudflare.com%2Fcdn-cgi%2Ftrace \"https://crypto.cloudflare.com/cdn-cgi/trace\")支持`ECH`扩展，当你的浏览器不支持`ECH`时，访问该网站`sni`会返回`plaintext`：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305c0dc705384af0a19207aaab046f5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n对于`chrome`，在[chrome://flags/#encrypted-client-hello](https://link.juejin.cn/?target=)中，配置`ECH`支持：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad28bbce903468da71ef55488892455~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n再访问上述网站，`sni`如果返回`encrypted`则代表支持`ECH`。\n\n## 总结\n\n虽然`HTTPS`连接本身是加密的，但在建立`HTTPS`的过程中（`TLS`握手），是有数据明文传输的，其中`SNI`中包含了服务器的域名信息。\n\n虽然`SNI`信息的本意是解决**同一IP下部署多个网站，每个网站对应不同的SSL证书**，但也会泄漏**访问的网站地址**。\n\n`ECH`通过对`TLS`握手过程中的敏感信息（主要是`SNI`）进行加密，为用户提供了更强的隐私保护。', '', 2, 4, 0, 1027, '2023-10-17 14:58:56', 1);
INSERT INTO `article` VALUES (34, 5, 'iOS单例对象：延迟加载和线程安全的最佳实践', '单例模式是iOS开发中常见的设计模式之一，作为一种经典的设计模式，它能够保证在整个应用程序中只会创建一个对象实例。在iOS开发中，我们常常需要在多个地方使用同一个对象，这时候通过单例模式可以方便地实现对象的共享。\n\n## 苹果的框架自带的单例模式\n\n1.  `FileManager.default`：这是一个全局的单例对象，用于提供文件管理功能\n2.  `UserDefaults.standard`：这是一个全局的单例对象，用于提供用户默认设置的读写功能\n3.  `UIApplication.shared`：这是一个全局的单例对象，用于提供应用程序级别的配置和交互功能\n4.  `NotificationCenter.default`：这是一个全局的单例对象，用于提供通知机制的处理和分发功能\n\n## Swift单例\n\n## Static Property + Private Initializer（推荐）\n\n在`Swift`中，使用`static let`来定义单例属性是线程安全的，因为`Swift`语言本身支持线程安全的延迟初始化（`lazy initialization`）。即只有在第一次访问这个属性时才会创建它，且只会创建一次，保证了单例的唯一性\n\n另外可以注意到，由于构造器使用了`private`关键字，即不允许在类的外部创建实例，保证单例的原子性\n\n```\nclass Singleton {\n     \n    static let shared = Singleton(with: \"param\")\n    \n    private init(with param: String) {}\n}\n```\n\n> 个人觉得通过该方式实现单例，代码可读性强，且直观，故比较推荐\n\n## Global Variables\n\n最直接简洁的方式：直接声明一个全局实例变量\n\n```\nlet shared = Singleton(with: \"param\")\nclass Singleton {\n    init(with param: String) {}\n}\n```\n\n> 在`Swift`中，全局变量使用延迟加载（`lazy initialization`）的方式进行初始化。这意味着全局变量的初始化器只会在第一次访问该变量时才被调用。\n> \n> `Swift`的这种实现方式有一个额外的好处，就是使用了`dispatch_once`函数来保证全局变量仅被初始化一次。这一点非常重要，因为仅需要初始化单例对象一次。在以前的`Objective-C`中，我们通常使用`@synchronized`关键字来保证线程安全并保证只有一个实例被创建。但是，`Swift`中使用`dispatch_once`函数可以更好地保证全局变量的唯一性和线程安全性。\n\n## OC单例\n\nGCD是iOS中的一种多线程编程技术，也是一种常见的OC单例实现方式。以下是一个使用GCD实现的单例类示例：\n\n```\n@interface Singleton : NSObject\n\n+ (instancetype)sharedInstance;\n\n@end\n\n@implementation Singleton\n\n+ (instancetype)sharedInstance {\n    static Singleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n+ (instancetype)allocWithZone:(struct _NSZone *)zone {\n    static dispatch_once_t onceToken;\n    static Singleton *sharedInstance = nil;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [super allocWithZone:zone];\n    });\n    return sharedInstance;\n}\n\n- (instancetype)init {\n    static Singleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [super init];\n    });\n    return sharedInstance;\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n    return self;\n}\n\n- (id)mutableCopyWithZone:(NSZone *)zone {\n    return self;\n}\n\n@end\n```\n\n在上述示例中，我们使用了`dispatch_once`来确保在整个应用程序生命周期中只会创建一个对象实例。同时，我们重写了`allocWithZone`、`init`、`copyWithZone`和`mutableCopyWithZone`方法，以确保在对象被复制时依然只会创建一个对象实例。\n\n## 优点\n\n1.  提供了一种方便的方式来访**问和共享唯一的对象实例**，避免了重复创建相同的对象\n2.  由于单例只有一个实例，因此可以**减少内存消耗和资源占用**，提高应用程序的性能\n3.  在多线程环境下，单例可以提供一种线程安全的方式来访问和修改共享数据，**避免竞态条件和死锁**等问题\n\n## 缺点\n\n1.  单例模式可能会导致**代码耦合度较高**，因为单例类被广泛使用，它的修改可能会影响整个应用程序\n2.  单例在应用程序中的生命周期非常长，往往从应用程序启动到关闭都存在，因此可能会导致内存泄漏、资源占用等问题\n3.  **单例状态的混乱**，一般需要对单例的状态进行监控，这样会使程序过于复杂，同时也产生很多无谓的监听\n4.  单例类的创建和初始化往往比较复杂，所以在设计和实现时需要考虑到其可扩展性和可维护性\n\n## 总结\n\n单例模式是iOS开发中常见的设计模式之一，它能够确保在整个应用程序中只会创建一个对象实例。在OC和Swift两种语言中，实现单例模式的方法各有不同。在OC中，我们常用懒加载和GCD来实现单例，而在Swift中，推荐使用全局常量或static变量来实现单例。无论使用哪种方法，单例模式都能够方便地实现对象的共享，提高应用程序的性能。\n\n## 参考文献\n\n[What Is a Singleton and How To Create One In Swift](https://link.juejin.cn/?target=https%3A%2F%2Fcocoacasts.com%2Fwhat-is-a-singleton-and-how-to-create-one-in-swift%2F \"https://cocoacasts.com/what-is-a-singleton-and-how-to-create-one-in-swift/\")', '', 5, 0, 0, 602, '2023-09-10 07:37:04', 1);
INSERT INTO `article` VALUES (35, 5, 'iOS 开发中如何禁用第三方输入法\r\n', 'OS 目前已允许使用第三方输入法，但在实际开发中，无论是出于安全的考虑，还是对某个输入控件限制输入法，都有禁用第三方输入法的需求。基于此，对禁用第三方输入法的方式做一个总结。\r\n\r\n1. 全局禁用\r\nObjective-C 语言版本：\r\n\r\nc\r\n复制代码\r\n- (BOOL)application:(UIApplication *)application\r\n  shouldAllowExtensionPointIdentifier:(UIApplicationExtensionPointIdentifier)extensionPointIdentifier\r\n{\r\n  // 禁用三方输入法\r\n  // UIApplicationKeyboardExtensionPointIdentifier 等价于 @\"com.apple.keyboard-service\"\r\n  if ([extensionPointIdentifier isEqualToString:UIApplicationKeyboardExtensionPointIdentifier]) {\r\n    return NO;\r\n  }\r\n  return YES;\r\n}\r\nSwift 语言版本：\r\n\r\nswift\r\n复制代码\r\nfunc application(\r\n  _ application: UIApplication,\r\n  shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier\r\n) -> Bool {\r\n  // 禁用三方输入法\r\n  if extensionPointIdentifier == .keyboard {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n2. 针对某个视图禁用\r\nswift\r\n复制代码\r\nfunc application(\r\n  _ application: UIApplication, \r\n  shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier\r\n) -> Bool {\r\n  // 遍历当前根控制器的所有子控制器，找到需要的子控制器\r\n  for vc in self.window?.rootViewController?.childViewControllers ?? []\r\n      where vc.isKind(of: BaseNavigationController.self)\r\n  {\r\n    // 如果首页禁止使用第三方输入法\r\n    for vc1 in vc.childViewControllers where vc1.isKind(of: HomeViewController.self) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}', '', 4, 3, 1, 912, '2023-09-08 11:19:27', 1);
INSERT INTO `article` VALUES (36, 8, 'iOS 摸鱼周报 #87 | Planning for AGI', '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a83df2d0105d403a848643b237de8357~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### 本期概要\n\n> -   本期话题：App Store 的定价机制升级扩展；四位女性开发者与 App Store 的故事\n> -   内容推荐：推荐近期的一些优秀博文，涵盖结构化并发、开发者故事、开发经验分享、Swift Builtin 函数等方面的内容\n> -   摸一下鱼：Planning for AGI；GPT4 发布；stable-diffusion-webui 尝试；一个 Alfred 插件 AJTools；苹果新版定价解读\n\n## 本期话题\n\n### [App Store 的定价机制升级现已扩展至所有购买类型](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fnews%2F%3Fid%3Ddbrszv62 \"https://developer.apple.com/cn/news/?id=dbrszv62\")\n\n[@远恒之义](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feternaljust \"https://github.com/eternaljust\")：即日起，App Store 最全面的定价机制升级迎来更新，包括新增价格点和按店面管理定价的全新工具。其中，你可在 900 个价格点中选择更灵活的定价，根据你熟悉的国家或地区来生成生成全球均衡价格，也可以为各个市场分发定制的内容和服务。此外，全新的增强定价机制更适用于当地顾客的价格，该机制将会在 2023 年 5 月 9 日更新调整。\n\n### [四位女性通过 app 与游戏推动文化发展并创造改变](https://link.juejin.cn/?target=https%3A%2F%2Fwww.apple.com.cn%2Fnewsroom%2F2023%2F03%2Fmeet-four-women-using-apps-and-games-to-drive-culture-and-create-change%2F \"https://www.apple.com.cn/newsroom/2023/03/meet-four-women-using-apps-and-games-to-drive-culture-and-create-change/\")\n\n[@远恒之义](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feternaljust \"https://github.com/eternaljust\")：女性开发者在开发者生态圈是一股不可忽视的力量，Apple 也一直在竭尽全力帮助女性开发者获得更好的成长，此前开展了包括 Apple Entrepreneur Camp（苹果企业家培训营）课程活动，以及针对中国女性开发者的“女性开发者社区日”特别活动。本篇内容为国际妇女节的主题特写，Apple 沟通了四位不同女性，这些女性主导的团队正在努力彰显女性的声音，文中分享了她们如何利用技术来鼓舞女性、创造社会变革的心得。\n\n## 内容推荐\n\n推荐近期的一些优秀博文，涵盖结构化并发、开发者故事、开发经验分享、Swift Builtin 函数等方面的内容\n\n整理编辑：[东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\")\n\n1、[神秘的 Swift 内置模块](https://juejin.cn/post/7208534700223250487 \"https://juejin.cn/post/7208534700223250487\") -- 作者：ankit 中文翻译：桃红宿雨\n\n[@东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\"): 如果你已经阅读过 Swift 的 stdlib 库，那大概率注意到了有很多 Builtin.\\* 类的函数，诸如：`Builtin.Int1`、`Builtin.RawPointer`、`Builtin.NativeObject` 等，这些神秘的 Builtin 到底是什么呢？本文主要解释了 Builtin 存在的原因：加快编译速度（Swift 很多 struct 值类型，最终内部都封装了 IILV IR 基础类型，不需要过多转换）；提高运行性能（由于不需要做过多转换，直接使用的 IILV IR 的函数，相当于使用很多类似底层函数在开发，性能更高）。\n\n2、[手工打造 HTML 解析器的那些事](https://link.juejin.cn/?target=https%3A%2F%2Fzhgchg.li%2Fposts%2F2724f02f6e7%2F \"https://zhgchg.li/posts/2724f02f6e7/\") -- 作者：ZhgChgLi\n\n[@东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\"): [ZMarkupParser](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FZhgChgLi%2FZMarkupParser \"https://github.com/ZhgChgLi/ZMarkupParser\") 是一个纯 Swift 库，可帮助你将 HTML 字符串转换为具有自定义样式和标签的 NSAttributedString。在本文中，ZhgChgLi 详细介绍了开发该库过程中所涉及的技术细节(HTML String 的 Tokenization 转换、Normalization 处理、Abstract Syntax Tree 的产生、Visitor Pattern / Builder Pattern 的应用)以及一些开发杂谈。本文篇幅很长，难得有开发者会做如此详尽的记录。\n\n3、[结构化并发](https://link.juejin.cn/?target=http%3A%2F%2Fchuquan.me%2F2023%2F03%2F11%2Fstructured-concurrency%2F \"http://chuquan.me/2023/03/11/structured-concurrency/\") -- 作者：楚权\n\n[@东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\"): 对于异步与并发，一直以来，业界都有着非常广泛的研究，针对特定场景提出了很多相关的技术，如：Future/Promise、Actor、CSP、异步函数等等。本文通过 GOTO 有害论引出编程历史中结构化编程的演化。以结构化编程作为类比，介绍了结构化并发的核心观点，以及结构化并发的设计理念。结构化并发主要包括作用域、异步函数、计算续体、协程等技术，此外还需要运行时系统的调度，才能最终实现理想的结构化并发。\n\n4、[通过 vacuuming 优化 CoreData 存储文件尺寸](https://link.juejin.cn/?target=https%3A%2F%2Fblog.eidinger.info%2Fkeep-your-coredata-store-small-by-vacuuming \"https://blog.eidinger.info/keep-your-coredata-store-small-by-vacuuming\") -- 作者：Marco Eidinger\n\n[@东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\"): 默认情况下，当你从表中删除数据或删除表、视图或索引等数据库对象时，SQLite 数据库不会自动“释放”磁盘空间。因为 SQLite 只是将删除的对象标记为空闲并保留空间以供将来使用。结果，数据库文件的大小总是在增长。在这篇博文中，Marco Eidinger 将解释 VACUUM 这个概念以及如何将这个概念应用到你的 CoreData 存储中来减少存储文件的尺寸。\n\n5、[独立开发周报 #4 (0306-0312)](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcEieMaUxSxDAZq0Cm_gwEQ \"https://mp.weixin.qq.com/s/cEieMaUxSxDAZq0Cm_gwEQ\") -- 作者：vulgur\n\n[@东坡肘子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fatbobman.com%2F \"https://www.fatbobman.com/\"): vulgur 是“极简时钟”、“极简日记”等 App 的作者，从一个月前开始，每周都通过博客的方式来记录自己的开发生活。通过他的记录，你可以对国内独立开发者的工作、生活状态有更多的了解。\n\n## 摸一下鱼\n\n整理编辑：[zhangferry](https://link.juejin.cn/?target=https%3A%2F%2Fzhangferry.com \"https://zhangferry.com\")\n\n1、[OpenAI：通用人工智能规划及未来](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FKu97-qx0EGnV9NVU20LyAA \"https://mp.weixin.qq.com/s/Ku97-qx0EGnV9NVU20LyAA\")：这是 OpenAI 发布的文章[Planning for AGI and beyond](https://link.juejin.cn/?target=https%3A%2F%2Fopenai.com%2Fblog%2Fplanning-for-agi-and-beyond \"https://openai.com/blog/planning-for-agi-and-beyond\")的翻译版。人工智能的等级分三级：\n\n-   ANI（Artificial Narrow Intelligence，弱人工智能），像是 Alpha Go，只能应用在单一领域。\n-   AGI（Artificial General Intelligence，强人工智能，也叫通用人工智能），可以胜任人类几乎所有工作。目前还没有达到，随着 ChatGPT 的问世，这种能力应该很快就会到来。\n-   ASI（Artificial Superintelligence，超人工智能）。超越人类智慧的人工智能，拥有任何人都无法企及的智慧，这个会更远一些。\n\n技术的发展通常都是一把双刃剑，这篇文章主要就在讲 OpenAI 在考虑和规划 AGI 到来所面临的一系列问题。这个问题不只是 OpenAI 所面临的，而是整个社会都将面临的。\n\n> 我们希望AGI能让人类在宇宙中最大限度地繁荣。我们不期望未来变成糟糕的乌托邦，我们希望把有利因素的最大化，把不利因素的最小化，让AGI成为人性良知的放大器。\n> \n> 我们希望AGI的益处、使用和治理能够被广泛和公平地共享。\n> \n> 我们希望成功应对巨大的风险。\n> \n> 在面对这些风险时，我们承认，理论上看似正确的事情，在实践中往往表现得比预期的更奇怪。我们相信，我们必须不断地学习和适应，部署功能较弱的技术版本，以尽量减少追求“一次做对”的场景。\n\n2、[GPT4 发布](https://link.juejin.cn/?target=https%3A%2F%2Fopenai.com%2Fresearch%2Fgpt-4 \"https://openai.com/research/gpt-4\")：GPT 4 相比 3.5 训练量大幅提升，训练参数已超万亿，这使其在多种自然语言处理任务上更加强大。它现在可以识别图像含义，可以快速创建一个完成程序，在多项人类的考试中均获得非常好的成绩。它能做的事情更多，做的速度也更快了。更厉害的是，相比于很多产品的概念发布和产品预热，这次发布是针对成品的。New bing 已经确认应用了 GPT4，除了图片识别的功能还在 alpha 阶段，其他文字类功能已经提供了可用的 API 调用。\n\n从 3.5 到 4.0 已经是一个非常快的发展，而传言 GPT5 会在年底发布，相比于 GPT 4 它的训练量是这样的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e628a39b8ea4c1d95089513cccac7a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n届时会增加对视频和声音的理解，AI 的 进化是飞速的，甚至就是指数级的。如果 GPT 4 的能力能代替 1% 的工作，那下一代的 GPT 5 对应的就不是 %2，而是10%，20%。所以关于 AGI 的到来会对社会有什么影响，如何将现有社会运作方式与 AGI 能力配合起来，都是不得不考虑的问题。\n\n3、[stable-diffusion-webui](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAUTOMATIC1111%2Fstable-diffusion-webui \"https://github.com/AUTOMATIC1111/stable-diffusion-webui\")：Stable-diffusion 的 WebUI 版本，支持 Apple Silicon 设备，参考地址：[Installation on Apple Silicon](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAUTOMATIC1111%2Fstable-diffusion-webui%2Fwiki%2FInstallation-on-Apple-Silicon \"https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon\")。通常运行起来遇到最多的问题就是环境的安装，大部分参照 Issues 都能解决。运行前给 `webui-user.sh`文件添加一个环境变量：\n\n```\nexport COMMANDLINE_ARGS=\"--skip-torch-cuda-test --upcast-sampling --no-half-vae --use-cpu interrogate --xformers --disable-nan-check\"\n```\n\n这表示运行 `webui.sh` 命令时填写的参数，以适用于 mac 设备。\n\n运行起来需要现配置模型，再输入关键字。模型有两类，一类叫 base model（底模型），像 SD v1.5 ，这类模型通常比较大，一般几个 G。另一类叫「修正模型」，像 Lora 就属于修正模型，会有很多特征的 Lora 变体模型，它是运行在底模型之上的，这类文件比较小，一般几百 M。模型可以在这个网站下载：[civitai](https://link.juejin.cn/?target=https%3A%2F%2Fcivitai.com%2F \"https://civitai.com/\")，下面是我跑出来的几张效果图，512 \\* 512，一张耗时大概 50s。图片非常细腻，只看图，真的很难分辨出是否是真人照片。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ccdc78f786459790380e2359e6d142~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576bf07330fb4f8a8c21a18d821b494a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n4、[AJTools - 开发工具](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkaqijiang%2FAJTools-AlfredWorkflowa \"https://github.com/kaqijiang/AJTools-AlfredWorkflowa\")：一个 Alfred Workflow 工具集，用 Python 实现，封装了一系列开发常用功能。包含：时间戳转换、URL 解析、copy SHH Key、打开当前窗口在iTerm2中、当前文件夹下快速新建文件、ChatGPT聊天等。\n\n5、[苹果内购录：关于新定价规则的理解与思考](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZQlBFHuRoDYmYpMfgnsp2Q \"https://mp.weixin.qq.com/s/ZQlBFHuRoDYmYpMfgnsp2Q\")：苹果在 3 月 9 号 发布了[新的定价规则](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fnews%2F%3Fid%3Ddbrszv62 \"https://developer.apple.com/cn/news/?id=dbrszv62\")，其中有一些修改点可能会对现有业务逻辑带来一些影响。本文对历史规则进行了回顾，同时也对新的定价规则进行了分析解读。\n\n除此之外，推荐需要处理内购的同学可以关注一下该 `#苹果内购录` 系列文章。\n\n## 关于我们\n\niOS 摸鱼周报，主要分享开发过程中遇到的经验教训、优质的博客、高质量的学习资料、实用的开发工具等。周报仓库在这里：[github.com/zhangferry/…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fzhangferry%2FiOSWeeklyLearning \"https://github.com/zhangferry/iOSWeeklyLearning\") ，如果你有好的的内容推荐可以通过 issue 的方式进行提交。另外也可以申请成为我们的常驻编辑，一起维护这份周报。另可关注公众号：iOS成长之路，后台点击进群交流，联系我们，获取更多内容。\n\n### 往期推荐\n\n[iOS 摸鱼周报 #86 | 更多基于 ChatGPT API 的产品诞生了](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fy1_V0WKfdwsUL2WjP2zPyA \"https://mp.weixin.qq.com/s/y1_V0WKfdwsUL2WjP2zPyA\")\n\n[iOS 摸鱼周报 #85 | ChatGPT 的 API 开放使用](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FHhb7ZCDDqEcpIRTlUKiGTQ \"https://mp.weixin.qq.com/s/Hhb7ZCDDqEcpIRTlUKiGTQ\")\n\n[iOS 摸鱼周报 #84 | 开箱即用的云服务 AirCode](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfKutqWAHfzkbbFgYCvPfIA \"https://mp.weixin.qq.com/s/fKutqWAHfzkbbFgYCvPfIA\")\n\n[iOS 摸鱼周报 #83 | ChatGPT 的风又起来了](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FTy95hGBIevHaJQ5TU774aQ \"https://mp.weixin.qq.com/s/Ty95hGBIevHaJQ5TU774aQ\")', '', 5, 3, 0, 715, '2023-09-10 07:32:01', 1);
INSERT INTO `article` VALUES (37, 6, '多端登录如何实现踢人下线', 'SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. To connect to a database or schema, simply double-click it in the pane. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source.', '', 1, 2, 0, 961, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (38, 2, 'iOS/MacOS开发需要了解的苹果官方开源库', '![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391b11e6649740dc9979bf3c16f12990~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 在大家印象中, Apple 和`开源`没有任何关系, 相比 Android 的各种定制和魔改, 苹果可谓是封闭之极, 开发者必须在苹果的框架下开发, 无法逾越一步。\n\n封闭的商业模式在保证了极致的`用户体验`的同时也决定了苹果的开源无法想其他的公司一样, 被众多的开发者认识和了解\n\n实际上苹果封闭的只有系统的用户体验层和商业软件，系统的底层库大部分是开源的,不论是系统内核Darwin Xnu、GCD还是 Swift、OC runtime，亦或是 WebKit 这个重要的 Web 组件，无不证明苹果的开源精神, 苹果也在拥抱广大开源爱好者。\n\n本文介绍苹果官方的一些开源网站和组件, 包含源码地址、文档和版本等信息, 作为iOS/MacOS开发您不容错过。\n\n首先是Apple三个主要开源网站\n\n1.  [opensource.apple.com](https://link.juejin.cn/?target=https%3A%2F%2Fopensource.apple.com \"https://opensource.apple.com\")\n    \n    苹果专门设计的一个开源官网, 列出了苹果主导和参与的一些开源库\n    \n2.  [github.com/apple](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple \"https://github.com/apple\")\n    \n    包含 `Swift`语言和swift-package-manager swift-foundation swift-nio等Swift组件库, 苹果开源的`主战场`\n    \n3.  [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions \"https://github.com/apple-oss-distributions\")\n    \n    iOS/MacOS `系统组件库`, 包括内核`xnu`、动态链接器`dyld`、`objc4`(runtime) GCD(libdispatch), 和各个系统组件库\n    \n\n下面介绍常用的组件和库\n\n## Swift\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c18f210262744c608575cb32d1e8f3a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   官网: [www.swift.org](https://link.juejin.cn/?target=https%3A%2F%2Fwww.swift.org \"https://www.swift.org\")\n    \n-   源码: [github.com/apple/swift](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift \"https://github.com/apple/swift\")\n    \n-   中文教程: [www.cnswift.org](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnswift.org \"https://www.cnswift.org\")\n    \n-   最新版本: 5.9\n    \n\n目前苹果开源的核心, 最先进的生产力和现代开发语言, 让大家都能开发出众的 App。\n\n旨在为开发者提供充分的自由。Swift 易用并且开源，只要有想法，谁都可以创造非凡。\n\n`open and powerful`\n\n## SPM\n\nswift-package-manager\n\n-   源码: [github.com/apple/swift…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-package-manager \"https://github.com/apple/swift-package-manager\")\n-   说明文档: [www.swift.org/getting-sta…](https://link.juejin.cn/?target=https%3A%2F%2Fwww.swift.org%2Fgetting-started%2F%23using-the-package-manager \"https://www.swift.org/getting-started/#using-the-package-manager\")\n-   最新版本: 0.6.0\n\n帮助Swift开发人员管理项目，以便复用代码及简化管理流程。\n\n和 Cocoapods、Carthage 作用类似\n\n支持 iOS、macOS、watchOS 和 tvOS 系统\n\n## swift-nio\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7734fe2ca61409da87c07e25c35f93a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/apple/swift…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-nio \"https://github.com/apple/swift-nio\")\n-   最新版本: 2.57.0\n\n基于事件驱动的`Swift for Server`开发框架，用于快速开发高性能且易于维护的Server程序\n\n为了提升性能，SwfitNIO 使用非阻塞 IO，不论是发送数据还是接收数据，应用程序都无需等待，系统内核会在有可操作的 IO 时通知 SwfitNIO。\n\n作用类似 Netty，但开发语言是 Swift。\n\n支持的平台\n\n```\nUbuntu 18.04+\nmacOS 10.14+\niOS 12+\n```\n\n## swift-corelibs-foundation\n\n-   源码: [github.com/apple/swift…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-corelibs-foundation \"https://github.com/apple/swift-corelibs-foundation\")\n\nFoundation 框架是苹果 macOS 和 iOS 的核心框架，几乎所有的 Swift/OC 项目都使用 Foundation 框架, 提供了各种最基础的工具类和应用API。\n\n使用 Swift 重新实现了 Foundation 框架, 不再需要 C 和 Swift 桥接，从而提高性能。该项目旨在为`Server Side`开发提供体量更小更方便的跨平台开发框架。\n\n## objc4(OC Runtime)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b5ce7a7598403f92281cd4a5a3b2ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2Fobjc4 \"https://github.com/apple-oss-distributions/objc4\")\n-   官方文档: [developer.apple.com/documentati…](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fobjectivec%2Fobjective-c_runtime \"https://developer.apple.com/documentation/objectivec/objective-c_runtime\")\n-   最新版本: objc4-876\n\n`Objective-C` `runtime` 库源码，它是 Objective-C 面向对象和动态机制的基石\n\n## xnu\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2Fxnu \"https://github.com/apple-oss-distributions/xnu\")\n-   最新版本: xnu-8796.101.5\n\n`xnu is not unix`\n\nxnu内核是Mac和iOS的核心，是结合了微内核与宏内核特性的混合内核，它包括三个部分：`Mach、BSD 和 I/O Kit`。\n\n## GCD\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2Flibdispatch \"https://github.com/apple-oss-distributions/libdispatch\")\n-   最新版本: libdispatch-1415.100.11\n\n`Grand Central Dispatch`（GCD） 是 Apple 开发的`多线程`编程技术。优化App以支持多核处理器。它在线程池模式的基础上执行的并发任务。支持 iOS 和 MacOS系统\n\n优势:\n\n1.  优化多核的并行运算\n2.  自动利用更多的 CPU 内核（比如双核、四核）\n3.  自动管理线程的生命周期（创建线程、调度任务、销毁线程）\n4.  只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码\n\n## dyld\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2Fdyld \"https://github.com/apple-oss-distributions/dyld\")\n-   最新版本: dyld-1066.8\n\ndyld 全称 `the dynamic link editor`，即动态链接器，是专门用来加载`动态库`的库。\n\n苹果系统的重要组成部分，在App被编译打包成可执行文件格式的 Mach-O 文件之后 ，交由 dyld 负责链接和加载程序。\n\n## Core Foundation\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2FCF \"https://github.com/apple-oss-distributions/CF\")\n-   最新版本: CF-1153.18\n\nCore Foundation和Foundation 功能基本一致, 区别是Core Foundation是由`C语言`实现的，而Foundation是 Objective-C 实现的, 为iOS和MacOS提供基本数据管理和服务功能。\n\n## distribution-macOS\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/770575cbe2924a4ba2894f0acde11448~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/apple-oss-d…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple-oss-distributions%2Fdistribution-macOS \"https://github.com/apple-oss-distributions/distribution-macOS\")\n-   最新版本: macOS 13.0\n\nMacOS 系统的驱动框架、IOKit和各种底层库的集合\n\n## 下面是苹果参与的开源项目\n\n## Webkit\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d60599fa3fc486eb82c8d89a66a8de6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/WebKit/WebK…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FWebKit%2FWebKit \"https://github.com/WebKit/WebKit\")\n-   官网: [webkit.org](https://link.juejin.cn/?target=https%3A%2F%2Fwebkit.org \"https://webkit.org\")\n-   最新版本: WebKit-7615.3.12.11.3\n\nWebKit是跨平台的`Web浏览器引擎`, 是 Apple Web的核心\n\nSafari、Mail、App Store 以及 macOS/iOS/Linux很多 App 都是基于WebKit来构建 web 服务的。\n\n## llvm/Clang\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c1be7757584470aaf359d86c8a15f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/llvm/llvm-p…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fllvm%2Fllvm-project \"https://github.com/llvm/llvm-project\")\n-   官网: [llvm.org](https://link.juejin.cn/?target=https%3A%2F%2Fllvm.org \"https://llvm.org\")\n-   最新版本: LLVM 16.0.6\n\nApple一开始使用`GCC`作为编译器，GCC对Objective-C的语言特性支持一直不够\n\n所以苹果重新开发了LLVM这一整套编译`前端`和`后端`的项目，llvm是这个项目的代号,\n\n它是高度优化的编译器、优化器和运行时环境。\n\nClang是LLVM的前端，用来编译`C`、`C++`和`Objective-C`代码,\n\n## sqlite\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/902201ac06534eb682842a5186ca8878~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   源码: [github.com/sqlite/sqli…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsqlite%2Fsqlite \"https://github.com/sqlite/sqlite\")\n-   官网: [sqlite.org](https://link.juejin.cn/?target=https%3A%2F%2Fsqlite.org \"https://sqlite.org\")\n-   最新版本: version-3.42.0\n\n`SQLite` 是开源跨平台轻量级数据库, 是移动端数据库的标准, 实现了无服务器的、零配置的、事务性的 SQL `数据库引擎`。\n\n优势:\n\n1.  不需要一个单独的服务器进程或操作的系统（无服务器的）。\n2.  不需要安装或管理。\n3.  跨平台, 数据库文件所有平台通用, 包括Android、iOS、Linux/Unix、Mac OS和 Windows\n4.  库非常小, 轻量级\n5.  没有任何外部的依赖\n6.  事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。\n7.  支持 SQL92（SQL2）标准的大多数查询语言的功能。\n\n## GNU step(开源Cocoa)\n\n-   源码: [github.com/gnustep/lib…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgnustep%2Flibs-base \"https://github.com/gnustep/libs-base\")\n-   下载地址: [wwwmain.gnustep.org/resources/d…](https://link.juejin.cn/?target=http%3A%2F%2Fwwwmain.gnustep.org%2Fresources%2Fdownloads.php%3Fsite%3Dftp%253A%252F%252Fftp.gnustep.org%252Fpub%252Fgnustep \"http://wwwmain.gnustep.org/resources/downloads.php?site=ftp%3A%2F%2Fftp.gnustep.org%2Fpub%2Fgnustep\")\n-   官网介绍: [gnustep.github.io/resources/d…](https://link.juejin.cn/?target=https%3A%2F%2Fgnustep.github.io%2Fresources%2Fdocumentation%2FDeveloper%2FBase%2FReference%2FBase.html \"https://gnustep.github.io/resources/documentation/Developer/Base/Reference/Base.html\")\n-   最新版本: base-1\\_29\\_0\n\nGNU step是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍。使用GNUstep了解`Cocoa`框架的实现原理。\n\n虽然GNU step不是苹果官方源码，但还是具有一定的参考价值 !!\n\nGNUstep Base\n\n-   KVO: Source/NSKeyValueObserving.m\n-   KVC: Source/NSKeyValueCoding.m\n-   NSRunLoop: Source/NSRunLoop.m\n-   NSThread: Source/NSThread.m\n-   NSOperation : Source/NSOperation.m\n\nGNUstep GUI\n\n-   NSView\n-   NSViewController', '', 5, 6, 0, 79, '2023-09-10 07:11:06', 1);
INSERT INTO `article` VALUES (39, 5, 'WWDC23-Elevate your windowed app for spatial computing', '> 文章引用来源：WWDC23 session **[Elevate your windowed app for spatial computing](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10110 \"https://developer.apple.com/videos/play/wwdc2023/10110\")**\n\n## 概述\n\n-   SwiftUI 可以将多平台应用程序引入 visionOS 和 Shared Space(共享空间)。SwiftUI 代码可以自动适应以支持 visionOS 平台的独特上下文和呈现。通过不局限于更新自定义视图、改进应用的 UI 以及添加特定于此平台的功能和控件等方法，可以使窗口应用程序在这个新的空间平台上真正引人注目。借助 Spatial Computing(空间计算)，可以使应用程序在物理空间中存在，从而实现全新类别的令人惊叹的三维体验。\n\n## 关键词\n\n-   SwiftUI、Shared Space、Dynamic Content scaling、Vector Assets、Vibrancy Material、Hover effects、Ornaments、TabView、Toolbar。\n\n## SwiftUI\n\n## 前言\n\n-   visionOS 从开始构建时就考虑到了 SwiftUI。事实上，在 Vision Pro 中的大多数系统应用程序都是用 SwiftUI 编写的，例如 Keynote、Freeform 和 TV，它们都将其熟悉的界面带入了你的的物理环境中。尽管这些应用程序看起来与 iPad 应用程序相似，但它们充分利用了该平台上的新设计语言和交互方法。\n    \n    > 本文将以一款 支持 iPhone、iPad、Mac、和 Apple Watch 平台的 Backyard Birds 应用为例，讲述如何将应用引入到 Vision Pro 中以及如何润色、增强你的应用的交互体验。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/766cb503ecc642ed93c76df8773ceaed~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 1 - Vision Pro 中的 Keynote\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6526e3e9849a42c987343240bedf1f38~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 2 - Vision Pro 中的 Freefrom\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dc0ad8ecd64ea9a7bd4d1b2b04e105~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 3 - Vision Pro 中的 Apple TV\n    \n\n## SwiftUI in the Shared Space(身处共享空间中的 SwiftUI)\n\n### 将 App 构建到 Vision Pro 的 Shared Space(共享空间)\n\n-   1、 Xcode 中选择主 Target，General->Supported Destination，点击+号，选择 xrOS Device， 选择 Enable。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e917038a16742728786e084ec398801~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 4 - Xcode 中启用 xrOS Device（1）\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29f183ea55549098bdff40e33124c4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 5 - Xcode 中启用 xrOS Device（2）\n    \n-   2、主 Target scheme 选择 xrOS Device，充构建应用程序即可。在模拟器中，当我四处移动光标时，应用程序会像在 Vision Pro 上的眼睛的移动的交互反馈一样给予你响应。例如，当光标移动到某一个可选项时，光标会呈现 Hover effects(悬浮效果)。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecfebb2122d744db803ee19f1b2db99f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 6 - Xcode 选择 xrOS Device 作为应用构建目标\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1121a9a491ed49c196a75be91e5c3d24~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 7 - Backyard Birds 构建成功后 Vision Pro 模拟器效果 & 光标移动到可选中时的 Hover effects 效果\n    \n\n### 应用特性\n\n#### Glass backgournds(玻璃背景)\n\n-   1、默认由应用程序的窗口提供。\n-   2、会根据照明条件和背后物体的颜色调整对比度和色彩平衡。\n-   3、没有 light 和 dark 外观的 style 区分。无论应用处在物理空间中的何处，玻璃效果都会自动确保应用保持清晰可读状态。\n\n## Polishing your app(润色你的应用)\n\n### Dynamic content scaling(动态内容缩放)\n\n-   与其他 Apple 平台不同，处于 Shared Space 物理环境中的应用，其没有带有物理像素的屏幕来定义内容可以绘制的质量。另外由于应用程序可以放置在任何地方，它们可能会被推得离你很远，或被拉近，甚至从某个角度观看，在此过程中，系统通过动态缩放内容来确保应用程序在所有场景下都看起来清晰可见。对此，对于内容就用了动态缩放的要求。\n\n1.  Prefer vectors over bitmaps：传统的位图，在缩放的时候会降低质量，为了保持质量，要让系统做到这一点，我们必须提供矢量资产。\n    \n2.  Text and [SF Symbols](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fsf-symbols%2F \"https://developer.apple.com/sf-symbols/\") are vectors：文本和 SF 符号默认是矢量的，可缩放。\n    \n3.  在 Xcode 中设置矢量资产\n    \n    1.  将图片的 individual scale 切换为 single scale。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b3e07e093974860b7ad5c95982b6d6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n        \n        图 8 - 将图片资源的 individual scale 改设置为 single scale\n        \n    2.  将图片已设置的 2x、3x 等所有资源移除后，选择图片对应的矢量图，并勾选 Preserve Vector Data，以允许图片进行任意尺寸的缩放，该配置所有平台都支持。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df9c6b09f9ac439db6d4b828bea586c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n        \n        图 9 - 选择矢量图资源并勾选Preserve Vector Data\n        \n        ![Vector Asset设置及效果预览.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5477f13946474745b82d44f310c8ea65~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n        \n        视频 1 - 矢量图片的配置及缩放预览效果\n        \n\n### 适配 Vibrancy 以让内容以最佳形式展现：\n\n-   Vibrancy 材质引入了额外的对比度和亮度，以确保 Glass 效果顶部的内容无论透过什么都清晰可见。默认情况下，所有内置控件和容器都使用 Vibrancy 材质，如果我们使用的是标准控件，则无需额外的工作。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d94b890059b44e2ac8ac6229a16e69e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 10 - 系统空间 Vibrancy 材质效果\n    \n\n### 标准的语义风格：\n\n-   SwiftUI 的语义样式在每个平台上自动采用适当的外观。在 Vision Pro 上由于 Glass 背景会随着环境光变化，使用这些语义样式可以使我们的内容更清晰易读。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8ded8181d44586ab46e047f790ac4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 11 - SwitUI 中 Text 控件在 Vision Pro上的 4 种风格\n    \n\n### Remove Solid Color(去除固定颜色配置)\n\n-   下图中的植物选项卡显示所有植物的网格，因为在代码中写的是固定的纯色，导致植物后面的这些圆圈看起来很亮而且不合适，在物理空间中，植物网格应该适应物理空间的背景，有投过去的效果。\n\n```\n...\n// 植物网格背景\nvar backgroudColor: Color {\n    if colorScheme == .dark {\n        Color(white: 0.6)\n    } else {\n        Color(white: 0.8)\n    }\n}\n// 植物网格背景设置\nvar body: some View {\n    PlantIcon(plant)\n        .background(backgroudColor, in: .circle)\n}\n...\n```\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6626cd66db67483ebf04a6e4c21641c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n图 8 - 植物网格纯色背景效果\n\n-   使用使用语义填充颜色替换纯色：替换后，可从 13~15 中发现，网格背景在每个不同光照的房间中，在 Glass 背景下，都有着很好的效果。\n    \n    ```\n       ...\n       // 植物网格背景设置\n       var body: some View {\n           PlantIcon(plant)\n               .background(.fill.tertiary, in: .circle)\n       }\n       ...\n    ```\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b8c9f9879648daadd94af8e3854784~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 9 - 植物网格语义填充色背景图(1)\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b184578359b4ce1a13b63900e526a30~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 10 - 植物网格语义填充色背景图(2)\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09f5dc3eb6ec46c08a0747c2f77b95c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 11 - 植物网格语义填充色背景图(3)\n    \n\n### 提升可交互组件的操作性\n\n-   Vision Pro 中与 App 交互的 4 种方法：眼、手、光标、无障碍访问。\n    \n    -   最常见的交互是间接捏合手势配合注视控件并将手指合拢以执行点击。如果某个应用程序离你很近，你只需伸出手触摸它就可以直接与其进行交互。如果你配置了触控板，则可以将其用作精确输入的指针。无障碍技术的 VoiceOver 和 Switch Control 等工具使都每个人能在使用应用程序时获得同样出色的体验。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4bdf1e6b5ae439d9e13f1c556c80bde~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n        \n        图 12 - Vision Pro 中与 App 交互的方法\n        \n\n-   #### Hover effects：\n    \n-   -   Vision Pro 中，当用户用眼睛注释到某个可交互的系统控件时，控件会高亮以显示你可以与其交互，这种悬浮效果称为 Hover effects。它有以下的有点：\n    -   1、使应用感觉响应迅速。\n    -   2、给予你更多与 App 进行互动的信息。\n    -   3、系统的标准控件自带 Hover effects 效果。\n    -   使用 SwiftUI 自带的 hoverEffect 为植物网格背景添加 hover effects 效果。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1880d5759c294c799d901cd406d9a170~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n图 13 - 设置内容圆角和背景 hover effects 效果\n\n#### Hover effects privacy\n\n-   1、悬浮效果旨在保护隐私。\n-   2、这些效果由应用进程之外的系统执行。系统悬停效果是使你的应用程序对用户所注视的位置做出反应的唯一方法。\n-   3、应用程序仅接收交互通知：只有当有用户捏手指、直接触摸你的应用程序或将手指或指针悬停在你的控件上时，你的应用程序才会被告知该展示悬浮效果了。\n\n## Brand new concepts(全新的功能)\n\n### Ornaments 之 TabView\n\n-   不同于传统的 iPad 应用中的 tabBar、toolBar，TabView 独立于 App 主窗口单独显示。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc34538b5a9445ea69ad6a289f7923f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 14 - 系统 Photo 应用左侧 TabView 收起效果图。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c34582f6bfd9406097ee9f7860600ddf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 15 - 系统 Photo 应用左侧 TabView 展开效果图\n    \n-   将 应用的 NavigationSplitView 改造为 TabView，如下图：\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cbcdf7888cb493aa756cfe53797957e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 16 - Backyard Birds 原有使用 NavigationSplitView\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c08961f9c34cc89829a47e3bf44eb2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 17 - Backyard Birds 将 NavigationSplitView 改造为 TabView\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55499efb810746fa95c05be2cc4fcf20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 18 - Backyard Birds 改造后 TabView 显示效果-展开\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef17fad3f6884cb4904154c92c90705d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 19 - Backyard Birds 改造后 TabView 显示效果-收起\n    \n\n### Ornaments 之 Toolbar\n\n-   Toolbar 同 TabView 同属于 Ornaments。它独立显示于应用底部，和TabView 一样自动提供玻璃化的胶囊背景，有着对应的 Hover effects、点击响应等效果。\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3248cb75be2749f89b5739f8230551fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 20 - Ornaments 之 Toolbar 效果\n    \n\n### 自定义Ornaments\n\n-   通过`ornaments()`函数调用，可以实现自定的 Ornaments。\n    \n-   `attachmentAnchor`：确定 Ornaments 将附加在你的的应用程序中的哪个位置。这里是底部。\n    \n-   `contentAligment`： 允许你选择装饰物的哪一部分与 `attachmentAnchor` 对齐。这里是居中对齐。\n    \n-   `glassBackgroundEffect()`：针对自定义的控件，需要自己调用方法以启用 Glass 背景效果。(系统控件自带)\n    \n    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453152e06a8744f88208430da73e7335~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n    \n    图 21 - 自定义 ornament\n    \n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/419768aa0d4845ea8bf778c92516712a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n图 22 - Backyard Birds 改造通知为 Ornaments 效果图\n\n## 进一步\n\n-   你还可以通过《[Take SwiftUI to the next dimension](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10113 \"https://developer.apple.com/videos/play/wwdc2023/10113\")》session 了解 3D 内容的体积和空间体验的沉浸式空间；通过《[Go beyond the window with SwiftUI](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10111 \"https://developer.apple.com/videos/play/wwdc2023/10111\")》了解如何将你的 app 扩展到窗口之外。\n    \n-   相关的其他 Session：\n    \n    -   [Meet SwiftUI for spatial computing](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10109 \"https://developer.apple.com/videos/play/wwdc2023/10109\")\n    -   [Meet UIKit for spatial computing](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F111215 \"https://developer.apple.com/videos/play/wwdc2023/111215\")\n    -   [Run your iPad and iPhone apps in the Shared Space](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10090 \"https://developer.apple.com/videos/play/wwdc2023/10090\")\n    -   [What\'s new in privacy](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10053 \"https://developer.apple.com/videos/play/wwdc2023/10053\")', 'public/uploads/1694331374522.png', 5, 2, 2, 339, '2023-09-10 07:36:15', 1);
INSERT INTO `article` VALUES (40, 5, '前端铜九铁十面试必备八股文——手写代码', '## 实现一个new操作符\n\n```\n/** 手写 new 操作符\n * 用法：创建一个实例化对象\n * 思路：\n *  1、判断传入的 fn 是否为 function\n *  2、创建一个空对象\n *  3、将这个空对象的原型设置为构造函数的 prototype 属性。\n *  4、使用 apply 执行构造函数 并传入参数 arguments 获取函数的返回值\n *  5、判断这个返回值 如果返回的是 Object || Function 类型 就返回该对象 否则返回创建的对象\n * @param {Function} fn 构造函数\n * @return {*}\n */\nfunction myNew(fn, ...args) {\n  // 判断 fn 是否为函数\n  if (typeof fn !== \'function\') {\n    return new TypeError(\'fn must be a function\')\n  }\n\n  // 创建一个空的对象\n  let obj = null\n\n  // 将这个空对象的原型设置为构造函数的 prototype 属性。\n  obj = Object.create(fn.prototype)\n\n  // 通过 apply 执行构造函数 传入参数 获取返回值\n  let result = fn.apply(obj, args)\n\n  // 判断这个返回值 如果返回的是 Object || Function 类型 就返回该对象 否则返回创建的对象\n  const flag = result && (typeof result === \'object\' || typeof result === \'function\')\n\n  return flag ? result : obj\n}\n\n```\n\n## 实现一个intanceof操作符\n\n```\n/** 手写 instanceof 方法\n * 用法：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n * 思路：\n *  1、通过 Object.getPrototypeOf 获取 obj 的原型\n *  2、循环判断 objProtoType 是否和 constructor 的原型相等\n *    2.1、如果相等就返回 true\n *    2.2、如果不相等 就重新赋值一下 obj 的原型 进入下一次循环\n *  3、判断是 objProtoType 是否为空 如果为空就说明不存在 返回 false\n * @param {Object} obj 需要判断的数据\n * @param {Object} constructor\n * @return {*}\n */\nfunction myInstanceof(obj, type) {\n  let objPrototype = Object.getPrototypeOf(obj)\n\n  while (true) {\n    if (!objPrototype) return false\n    if (objPrototype === type.prototype) return true\n\n    objPrototype = Object.getPrototypeOf(objPrototype)\n  }\n}\n```\n\n## 手写 Object.create\n\n```\n/** 手写 Object.create\n * 用法：创建一个新的对象，将传入的对象原型指向新对象并返回\n * 思路：\n *  1、将原型写入到一个函数里面，然后将函数返回\n * @param {*} obj\n * @return {*} \n */\nfunction myCreate(obj) {\nfunction F() {}\nF.prototype = obj\n\nreturn new F()\n}\n```\n\n## 手写节流\n\n> 函数在 n 秒内只执行一次，如果 n 秒内多次触发，则忽略执行。\n\n```\n/** 手写节流\n * 用法：函数在 n 秒内只执行一次，如果多次触发，则忽略执行。\n * 思路：\n *  1、记录函数上一次执行的时间戳 startTime\n *  2、返回一个闭包函数 当被调用时会记录一下执行时间 nowTime\n *  3、比较两次执行时间间隔 是否超过了 wait 时间\n *  4、如果是大于 wait 时间 说明已经过了一个 wait 时间 可以执行函数\n *    4.1、更新 startTime 方便下次对比\n *    4.2、通过 apply 执行函数fn 传入 arguments 参数\n *  5、如果没有超过 wait 时间  说明是在 wait 时间内又执行了一次  忽略\n * @param {Function} fn 执行函数\n * @param {Number} wait 等待时间\n * @return {*} \n */\nfunction throttle(fn, wait) {\n  let startTime = Date.now()\n\n  return function () {\n    const nowTime = Date.now()\n\n    // 计算两次执行的间隔时间 是否大于 wait 时间\n    if (nowTime - startTime >= wait) {\n      startTime = nowTime\n      return fn.apply(this, arguments)\n    }\n  }\n}\n```\n\n## 手写防抖\n\n> 函数在 n 秒后执行，如果多次触发，重新计时，保证函数在 n 秒后执行\n\n```\n/** 手写防抖\n * 用法：函数在 n 秒后再执行，如果 n 秒内被触发，重新计时，保证最后一次触发事件 n 秒后才执行。\n * 思路：\n *  1、保存一个变量 timer\n *  2、返回一个闭包函数 函数内判断一下 timer 是否有值\n *    2.1、如果有值 说明 定时器已经开启 需要将定时器清空\n *  3、设置定时器 等待 wait 后执行 将定时器赋值给 timer 记录\n *  4、通过 apply 执行函数 传入 arguments\n * @param {*} fn\n * @param {*} wait\n * @param {boolean} [immediate=false]\n * @return {*} \n */\nfunction debounce(fn, wait, immediate = false) {\n  let timer = null\n\n  return function () {\n    // 存在定时器 清空\n    if (timer) {\n      clearInterval(timer)\n      timer = null\n    }\n    // 立即执行\n    if (immediate) {\n      // 判断是否执行过  如果执行过 timer 不为空\n      const flag = !timer\n\n      // 执行函数\n      flag && fn.apply(this, arguments)\n\n      // n 秒后清空定时器\n      timer = setTimeout(() => {\n        timer = null\n      }, wait)\n    } else {\n      timer = setTimeout(() => {\n        fn.apply(this, arguments)\n      }, wait)\n    }\n  }\n}\n```\n\n## 手写浅拷贝\n\n```\n/** 浅拷贝\n * 用法：浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。\n * 思路：\n *  1、判断是否为对象\n *  2、根据obj类型创建一个新的对象\n *  3、for in 遍历对象 拿到 key\n *  4、判断 key 是否在 obj 中\n *  5、将 key 作为新对象的key 并赋值 value\n *\n * @param {*} obj\n * @return {*} \n */\nfunction shallowCopy(obj) {\n  // 只拷贝对象\n  if (!obj || typeof obj !== \'object\') {\n    return obj\n  }\n\n  // 新的对象\n  const newObj = Array.isArray(obj) ? [] : {}\n\n  // 循环遍历 obj 将 key 作为 newObj 的 key 并赋值value\n  for (const key in obj) {\n    // 判断 key 是否在 obj 中\n    if (obj.hasOwnProperty(key)) {\n      newObj[key] = obj[key]\n    }\n  }\n\n  return newObj\n}\n```\n\n## 手写深拷贝\n\n```\n/** 深拷贝\n * 用法：拷贝一个对象的属性值 如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用\n * 思路：\n *  1、判断是否为对象\n *  2、判段对象是否在 map 中 如果存在就不需要操作\n *  3、将 obj 放入 map 中 避免重复引用\n *  4、for in 遍历对象 拿到 key 判断 key 是否在 obj 中\n *  5、value 如果为对象 就递归拷贝 否则就赋值\n * @param {*} obj\n * @param {*} [map=new Map()]\n * @return {*} \n */\nfunction deepCopy(obj, map = new Map()){\n  if (!obj || typeof obj !== \'object\'){\n    return obj\n  }\n\n  // 判断 obj 是否在 map 中存在 如果存在就不需要递归调用 直接返回数据\n  if (map.get(obj)) {\n    return map.get(obj)\n  }\n  const newObj = Array.isArray(obj) ? [] : {}\n\n  // 放入 map 中 记录当前对象 避免重复拷贝 循环引用\n  map.set(obj, newObj)\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // 如果 value 还是一个对象 递归获取 否则就赋值\n      newObj[key] = typeof obj[key] === \'object\' ? deepCopy(obj[key], map) : obj[key]\n    }\n  }\n\n  return newObj\n}\n```\n\n## 手写call\n\n```\n/** 手写 call\n * 用法：call 方法用于调用一个函数，并指定函数内部 this 的指向，传入一个对象\n * 思路：\n *  1、判断 this 是否指向一个函数  只有函数才可以执行\n *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window\n *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上 然后执行获取 result 传入 ...args 确保参数位置正确\n *  4、删除 context 对象的 fn 属性 并将 result 返回\n */\n\nFunction.prototype.myCall = function (context, ...args) {\n  if (typeof this !== \'function\') {\n    return new TypeError(\'type error\')\n  }\n  context = context || window\n\n  // 缓存this\n\n  context.fn = this\n\n  const result = context.fn(...args)\n\n  delete context.fn\n\n  return result\n}\n```\n\n## 手写apply\n\n```\n/** 手写 apply\n * 用法：apply 方法用于调用一个函数，并指定函数内部 this 的指向，传入一个数组\n * 思路：\n *  1、判断 this 是否指向一个函数  只有函数才可以执行\n *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window\n *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上的一个 fn 属性上\n *  4、执行 fn 函数 判断 args 是否有 如果没有参数就直接执行 如果有参数 将参数展开传入 fn\n *  5、删除 context 对象的 fn 属性 并将 result 返回\n */\n\nFunction.prototype.myApply = function (context, args) {\n  if (typeof this !== \'function\') {\n    return new TypeError(\'type error\')\n  }\n\n  // 和 call 一样 只不过传入的参数只有一个 类型为数组 在执行 fn 的时候将参数展开\n  context = context || window\n\n  context.fn = this\n\n  const result = args ? context.fn(...args) : context.fn()\n\n  delete context.fn\n\n  return result\n}\n\n```\n\n## 手写bind\n\n```\n/** 手写 bind\n * 用法：bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n * 思路：\n *  1、判断 this 是否指向一个函数  只有函数才可以执行\n *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window\n *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上的一个 fn 属性上\n *  4、返回一个函数 供外部调用 执行函数后传入新的参数\n *  5、执行在闭包内缓存的 fn 将两次参数一起传入 删除 fn 返回 result\n */\n\nFunction.prototype.myBind = function (context, ...args1) {\n  if (typeof this !== \'function\') {\n    return new TypeError(\'type error\')\n  }\n  context = context || window\n  context.fn = this\n\n  // 和 call apply 不一样的是 bind 返回一个函数 需要在外部执行  参数为多个对象 且返回的对象里也会有参数\n  return function (...args2) {\n    const result = context.fn(...args1, ...args2)\n    delete context.fn\n    return result\n  }\n}\n```\n\n## 函数柯里化的实现\n\n```\n/** 函数柯里化\n * 用法：函数柯里化是一种将接受多个参数的函数转换为接受一系列单一参数的函数的技术\n * 思路：\n *  1、使用 fn.length 获取函数的形参数量\n *  2、如果没有传入初始参数数组 则将其初始化为空数组 在递归的时候会接受上一次的形参\n *  3、返回一个闭包函数 接受函数的实参 将 args 中的形参和当前的形参进行合并 得到 newArgs\n *  4、如果新的参数数组 newArgs 长度大于等于 length 函数的形参数量 调用 apply 执行函数 传入 newArgs\n *  5、如果新的参数数组长度小于函数的形参数量 则再次调用 curry 函数 将新的参数数组作为初始参数传入 返回一个新的闭包函数\n * @param {*} fn\n * @param {*} args\n * @return {*} \n */\nfunction curry(fn, args) {\n  // 获取 fn 获取 add 函数的形参数量\n  const length = fn.length\n\n  // 递归执行时传递的上一次参数 第一次执行 [] 第二次执行 [1]\n  args = args || []\n  return function () {\n    // 将上一次参数和这次的参数进行合并  得到新的参数数组\n    const newArgs = [...args, ...arguments]\n\n    // 判断 newArgs 长度是否和 add 函数形参长度一致 如果超过就执行 fn 函数 传递 newArgs\n    if (newArgs.length >= length) {\n      return fn.apply(this, newArgs)\n    } else {\n      // 小于 add 函数形参长度 递归调用 curry 函数 累积参数 传递 newArgs\n      return curry(fn, newArgs)\n    }\n  }\n}\n```\n\n## 手写promise\n\n```\nclass MyPromise {\n  constructor(executor) {\n    this.state = \'pending\'\n    this.value\n    this.reason\n\n    this.onResolveCallbacks = []\n    this.onRejectCallbacks = []\n\n    const resolve = (value) => {\n      if (this.state === \'pending\') {\n        this.value = value\n        this.state = \'fulfilled\'\n        this.onResolveCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    const reject = (reason) => {\n      if (this.state === \'pending\') {\n        this.reason = reason\n        this.state = \'rejected\'\n        this.onRejectCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    // 判断类型\n    onFulfilled = typeof onFulfilled === \'function\' ? onFulfilled : (value) => value\n    onRejected =\n      typeof onRejected === \'function\'\n        ? onRejected\n        : (reason) => {\n            throw reason\n          }\n\n    const p2 = new MyPromise((resolve, reject) => {\n      // 执行成功\n      // 执行失败\n      // pending状态放入任务队列\n      if (this.state === \'fulfilled\') {\n        setTimeout(() => {\n          try {\n            const x = onFulfilled(this.value)\n            this.resolvePromise(p2, x, resolve, reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0)\n      } else if (this.state === \'rejected\') {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.reason)\n            this.resolvePromise(p2, x, resolve, reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0)\n      } else {\n        this.onResolveCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onFulfilled(this.value)\n              this.resolvePromise(p2, x, resolve, reject)\n            } catch (error) {\n              reject(error)\n            }\n          }, 0)\n        })\n\n        this.onRejectCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.reason)\n              this.resolvePromise(p2, x, resolve, reject)\n            } catch (error) {\n              reject(error)\n            }\n          }, 0)\n        })\n      }\n    })\n\n    return p2\n  }\n\n  resolvePromise(p2, x, resolve, reject) {\n    // 判断 p2 和x是否相等\n    if (p2 === x) {\n      return reject(new TypeError(\'type error\'))\n    }\n\n    // 执行锁 确保执行一次完resolve或者reject后 不再执行\n    let called = false\n\n    // 判断x数据类型  如果是函数 对象 需要递归执行  如果是值类型 直接resolve\n    if (x !== null && (typeof x === \'object\' || typeof x === \'function\')) {\n      try {\n        // 判断 then是否为函数\n        const then = x.then\n        if (typeof then === \'function\') {\n          then.call(\n            x,\n            (y) => {\n              if (called) return\n              called = true\n              this.resolvePromise(p2, y, resolve, reject)\n            },\n            (r) => {\n              if (called) return\n              called = true\n              reject(r)\n            },\n          )\n        } else {\n          resolve(x)\n        }\n      } catch (error) {\n        if (called) return\n        called = true\n        reject(error)\n      }\n    } else {\n      resolve(x)\n    }\n  }\n}\n\n```\n\n## 实现all\n\n```\n  /**\n   * 1.返回一个新的promise对象\n   * 2.遍历传入的数据，将数据包装成一个 promise 对象\n   * 3. 执行resolve 或者reject\n   * 4. 返回结果\n   * 这里的代码是一个 forEach 循环，对于每个 Promise，调用 MyPromise.resolve 方法将其转换为 Promise 对象，然后调用 then 方法，将 fulfilled 的值存储到 results 数组中，count 加 1。当 count 等于 promises 数组的长度时，说明所有的 Promise 都 fulfilled，此时调用 resolve 方法，将 results 数组作为返回值传递给新的 Promise。\n   * 在遍历时记录当前promise在数组中的位置，这个位置就是index。\n   */\n  all(array) {\n    return new MyPromise((resolve, reject) => {\n      if (!Array.isArray(array)) {\n        throw new TypeError(\'You must pass an array to all.\')\n      }\n      const result = []\n      let count = 0\n      // 遍历 array 拿到每一条数据\n      array.forEach((promise, index) => {\n        MyPromise.resolve(promise).then(\n          (value) => {\n            result[index] = value\n            count++\n            // 判断 result 结果值的长度 和 array参数的长度相等  执行最外面的 resolve 返回 all 结果\n            if (count === array.length) {\n              resolve(array)\n            }\n          },\n          (err) => {\n            reject(err)\n          },\n        )\n      })\n    })\n  }\n```\n\n## 实现race\n\n```\n  race(array) {\n    return new MyPromise((resolve, reject) => {\n      if (!Array.isArray(array)) {\n        throw new TypeError(\'You must pass an array to all.\')\n      }\n\n      array.forEach((promise) => {\n        MyPromise.resolve(promise).then(\n          (value) => {\n            resolve(value)\n          },\n          (reason) => {\n            reject(reason)\n          },\n        )\n      })\n    })\n  }\n```\n\n## 实现数组的扁平化\n\n## 递归\n\n判断当前项是否为数组 如果是数组递归调用 不是就push到新数组\n\n```\nlet arr = [1, [2, [3, 4, 5]]]\n\nfunction flatten(arr) {\n  let newArr = []\n\n  // 递归获取数据\n  for (let index = 0; index < arr.length; index++) {\n    const element = arr[index]\n    Array.isArray(element) ? (newArr = newArr.concat(flatten(element))) : newArr.push(element)\n  }\n\n  return newArr\n}\n```\n\n## 栈\n\n新建一个栈来存储数据 每次从栈中取出一个数据 判断是否为数组 如果是 就将该数组放入到栈中 修改了栈的长度 开始下一次循环 如果不是 就放入新数组\n\n```\nfunction flatten(arr) {\n  const stack = [...arr]\n  const result = []\n\n  while (stack.length) {\n    const next = stack.pop()\n    if (Array.isArray(next)) {\n      stack.push(...next)\n    } else {\n      result.push(next)\n    }\n  }\n  return result\n}\n```\n\n## ES6 filter 结构赋值\n\n```\nfunction flatten(arr) {\n  while (arr.some((item) => Array.isArray(item))) {\n    arr = [].concat(...arr)\n  }\n  return arr\n}\n```\n\n## 实现数组去重\n\n## Set结构\n\n```\nconst arr = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8]\nconst uniqueArr = [...new Set(arr)]\n```\n\n## 使用 filter 和 indexOf\n\n```\nconst uniqueArr = arr.filter((item, index) => {\n  return arr.indexOf(item) === index\n})\n```\n\n## 使用Map存储\n\n```\nfunction uniqueArray(array) {\n  let map = {}\n  let res = []\n  for (var i = 0; i < array.length; i++) {\n    if (!map.hasOwnProperty([array[i]])) {\n      map[array[i]] = 1\n      res.push(array[i])\n    }\n  }\n  return res\n}\n```\n\n## 实现reduce方法\n\n`reduce`函数于累积数组元素并返回一个最终的累积结果，接受一个回调函数和一个初始值作为参数。回调函数将接受四个参数：累积结果（上一次的回调返回值或初始值）、当前元素、当前索引和原始数组。\n\n```\nfunction myReduce(arr, callback, initialValue) {\n  let accumulator = initialValue !== undefined ? initialValue : arr[0];\n  const startIndex = initialValue !== undefined ? 0 : 1;\n\n  for (let i = startIndex; i < arr.length; i++) {\n    accumulator = callback(accumulator, arr[i], i, arr);\n  }\n\n  return accumulator;\n}\n```\n\n## 实现数组 push 方法\n\n`push`方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n\n```\nArray.prototype.myPush = function () {\n  // 循环遍历 arguments.length 也就是传入的参数个数\n  for (let index = 0; index < arguments.length; index++) {\n    // this.length 指向调用这个方法的数组 获取数组的长度 将当前元素放入最后一个\n    this[this.length] = arguments[index]\n  }\n\n  return this.length\n}\n// let arr = [1,2,3]\n// arr.myPush(6, 4, 5)\n```\n\n## 实现数组 filter 方法\n\n`filter`方法创建给定数组一部分的浅拷贝，其包含通过所提供函数实现的测试的所有元素。\n\n```\nArray.prototype.myFilter = function (callback) {\n  if (!callback || typeof callback !== \'function\') {\n    throw Error(\'callback must be a function \')\n  }\n\n  const res = []\n  // this.length 指向调用方法的数组\n  for (let index = 0; index < this.length; index++) {\n    // 执行 callback 函数传入数据 如果函数返回 true 就将当前数据放入 res 中\n    callback(this[index], index) && res.push(this[index])\n  }\n  return res\n}\n\n// let arr = [1, 2, 3]\n// console.log(\n//   arr.myFilter((item, index) => {\n//     console.log(\'item\', item)\n//     console.log(\'index\', index)\n//     return item > 2\n//   })\n// )\n```\n\n## 实现数组 map 方法\n\n`map`创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成\n\n```\nArray.prototype.myMap = function (callback) {\n  if (!callback || typeof callback !== \'function\') {\n    throw Error(\'callback must be a function \')\n  }\n  const result = []\n\n  // this.length 指向调用方法的数组\n  for (let index = 0; index < this.length; index++) {\n    result.push(callback(this[index], index))\n  }\n  return result\n}\n\n// const map1 = array1.map((x) => x * 2)\n// console.log(map1)\n```\n\n## 实现 add(1)(2)(3)\n\n参考柯里化实现\n\n## 将数字每千分位用逗号隔开\n\n## 不带小数\n\n```\nfunction format(num) {\n  if (!num && typeof num !== \'number\') {\n    return num\n  }\n  let str = num.toString()\n  let len = str.length\n\n  // 长度是否超过3\n  if (len <= 3) {\n    return num\n  } else {\n    // 判断是否为 3 的倍数\n    let remainder = len % 3\n\n    // 不是 3 的整倍数\n    if (remainder > 0) {\n      //  则根据数字长度对字符串进行拆分，每3位一组，最后再用逗号拼接起来\n\n      // 被 3 整除余下的 也就是最前面第一个数字 如 1234567 最前面就是 1\n      const firstNum = str.slice(0, remainder)\n\n      // 获取剩下的数组 每 3 个用 , 拼接  也就是从 remainder 位置到最后一位\n      const surplus = str.slice(remainder, len).match(/\\d{3}/g)\n\n      // 组合起来  第一位后面加上 ,\n      return firstNum + \',\' + surplus\n    } else {\n      // 是 3 的倍数 上面操作去掉第一位数据操作就是  直接用正则匹配数据 然后 join 拼接 ,\n      return str.match(/\\d{3}/g).join(\',\')\n    }\n  }\n}\n\n```\n\n## 带小数\n\n```\nfunction format1(num) {\n  if (!num && typeof num !== \'number\') {\n    return num\n  }\n  let str = num.toString()\n  let len = str.length\n\n  let decimals = \'\'\n  // 获取小数\n  str.includes(\'.\') ? (decimals = str.split(\'.\')[1]) : decimals\n\n  // 长度是否超过3\n  if (len <= 3) {\n    return num\n  } else {\n    // 判断是否为 3 的倍数\n    let remainder = len % 3\n\n    // 不是 3 的整倍数\n    if (remainder > 0) {\n      //  则根据数字长度对字符串进行拆分，每3位一组，最后再用逗号拼接起来\n\n      // 被 3 整除余下的 也就是最前面第一个数字 如 1234567 最前面就是 1\n      const firstNum = str.slice(0, remainder)\n\n      // 获取剩下的数组 每 3 个用 , 拼接  也就是从 remainder 位置到最后一位\n      const surplus = str.slice(remainder, len).match(/\\d{3}/g)\n\n      // 组合起来  第一位后面加上 ,  顺便带上小数\n      return firstNum + \',\' + surplus + \'.\' + decimals\n    } else {\n      // 是 3 的倍数 上面操作去掉第一位数据操作就是  直接用正则匹配数据 然后 join 拼接 , 顺便带上小数\n      return str.match(/\\d{3}/g).join(\',\') + \'.\' + decimals\n    }\n  }\n}\n\n```\n\n## 数组转树\n\n```\nlet source = [\n  {\n    id: 1,\n    pid: 0,\n    name: \'body\',\n  },\n  {\n    id: 2,\n    pid: 1,\n    name: \'title\',\n  },\n  {\n    id: 3,\n    pid: 2,\n    name: \'div\',\n  },\n  {\n    id: 4,\n    pid: 0,\n    name: \'html\',\n  },\n  {\n    id: 5,\n    pid: 4,\n    name: \'div\',\n  },\n  {\n    id: 6,\n    pid: 5,\n    name: \'span\',\n  },\n  {\n    id: 7,\n    pid: 5,\n    name: \'img\',\n  },\n][\n  // 转为\n  ({\n    id: 1,\n    pid: 0,\n    name: \'body\',\n    children: [\n      {\n        id: 2,\n        pid: 1,\n        name: \'title\',\n        children: [{ id: 3, pid: 2, name: \'div\' }],\n      },\n    ],\n  },\n  {\n    id: 4,\n    pid: 0,\n    name: \'html\',\n    children: [\n      {\n        id: 5,\n        pid: 4,\n        name: \'div\',\n        children: [{ id: 7, pid: 5, name: \'img\' }],\n      },\n    ],\n  })\n]\n```\n\n用map将所有id 做缓存 判断pid是否在 map 中 在就是子元素 不在就是跟元素\n\n```\nfunction arrToTree(arr) {\n  const map = {}\n  const result = []\n  for (const item of arr) {\n    map[item.id] = item\n  }\n  \n  for (let i = 0; i < arr.length; i++) {\n    // 获取 pid  看是否在 map 中查询得到对应的\n    const pid = arr[i].pid\n    if (map[pid]) {\n      // 当前 pid 在 map 中存在 将当前节点作为 map 中节点的子节点\n      map[pid].children = map.children || []\n      map[pid].children.push(arr[i])\n    } else {\n      // 不在 map 中 说明是根节点\n      result.push(arr[i])\n    }\n  }\n  return result\n}\n```\n\n## 树转数组\n\n```\nlet source1 = [\n  {\n    id: 1,\n    pid: 0,\n    name: \'body\',\n    children: [\n      {\n        id: 2,\n        pid: 1,\n        name: \'title\',\n        children: [{ id: 3, pid: 2, name: \'div\' }],\n      },\n    ],\n  },\n  {\n    id: 4,\n    pid: 0,\n    name: \'html\',\n    children: [\n      {\n        id: 5,\n        pid: 4,\n        name: \'div\',\n        children: [{ id: 7, pid: 5, name: \'img\' }],\n      },\n    ],\n  },\n][\n  // 转为\n  ({ id: 1, pid: 0, name: \'body\' },\n  { id: 4, pid: 0, name: \'html\' },\n  { id: 2, pid: 1, name: \'title\' },\n  { id: 5, pid: 4, name: \'div\' },\n  { id: 3, pid: 2, name: \'div\' },\n  { id: 7, pid: 5, name: \'img\' })\n]\n\n```\n\n\\[\\[手写代码#实现数组的扁平化#栈|参考数组扁平用栈方式\\]\\]\n\n```\nfunction treeToArr(arr) {\n  let stack = [...arr]\n  const result = []\n\n  while (stack.length) {\n    // 从数组中获取第一个\n    const first = stack.shift()\n\n    // 判断它有没有children\n    if (first[\'children\'] && first.children.length) {\n      // 有 children 将它展开再放入到栈中\n      stack.push(...first.children)\n\n      // 删除 children 属性\n      delete first.children\n    }\n\n    result.push(first)\n  }\n\n  return result\n}\n```\n\n## 实现每隔一秒打印 1,2,3,4\n\n```\n// 使用 let 块级作用域\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, i * 1000);\n}\n```\n\n## 使用 setTimeout 实现 setInterval\n\n```\nfunction mySetInterval(fn, delay) {\n  let timerId\n\n  function interval() {\n    // 执行回调\n    fn()\n    // 再次调用 interval\n    timerId = setTimeout(interval, delay)\n  }\n\n  // 开始执行 interval\n  setTimeout(interval, delay)\n\n  return {\n    clear() {\n      clearTimeout(timerId)\n    },\n  }\n}\n\n```\n\n## 实现发布-订阅模式\n\n```\nclass EventCenter {\n  constructor() {\n    // 事件中心\n    this.events = {}\n  }\n\n  /**\n   * 订阅事件\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @memberof EventCenter\n   */\n  subscribe(eventName, callback) {\n    // 确保当前 eventName 在事件中心是唯一的\n    if (!this.events[eventName]) {\n      // 创建事件容器\n      this.events[eventName] = []\n    }\n    // 存放事件\n    this.events[eventName].push(callback)\n  }\n\n  /**\n   * 取消订阅\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @return {*}\n   * @memberof EventCenter\n   */\n  unSubscribe(eventName, callback) {\n    // 事件中心里没有这个事件\n    if (!this.events[eventName]) {\n      return new Error(\'not find event \' + eventName)\n    }\n\n    // 只有事件名 移除事件\n    if (!callback) {\n      delete this.events[eventName]\n    } else {\n      // 找到索引\n      const index = this.events[eventName].findIndex((el) => el === callback)\n\n      if (index !== -1) {\n        return new Error(\'not find callback\')\n      }\n\n      // 移除事件下的某个函数\n      this.events[eventName].splice(index, 1)\n\n      // 查看事件容器是否为空 如果为空移除事件\n      if (this.events[eventName].length === 0) {\n        delete this.events[eventName]\n      }\n    }\n  }\n\n  /**\n   * 触发事件\n   *\n   * @param {string} eventName\n   * @param {Array} args\n   * @return {*}\n   * @memberof EventCenter\n   */\n  dispatch(eventName, ...args) {\n    if (!this.events[eventName]) {\n      return new Error(\'not find event \' + eventName)\n    }\n\n    // 触发事件\n    this.events[eventName].forEach((el) => {\n      el(...args)\n    })\n  }\n}\n\nconst eventCenter = new EventCenter()\n\n// 订阅事件\neventCenter.subscribe(\'click\', (x, y) => {\n  console.log(`clicked at (${x}, ${y})`)\n})\n\n// 发布事件\neventCenter.dispatch(\'click\', 10, 20) // 输出：clicked at (10, 20)\n\n\n\n```\n\n## 实现斐波那契数列\n\n## 递归方式\n\n```\nfunction fn(n) {\nif (n = 0) return 0\nif (n = 1) return 1\nreturn fn(n -2) + fn(n -1)\n}\n```\n\n## 非递归\n\n```\nfnction fn(n) {\nlet pre1 = 1\nlet pre2 = 1\nlet current = 2\n\nif (n = 2) return current \nfor( let i =2; i < n; i++) {\npre1 = pre2\npre2 = current\ncurrent = pre1 + pre2\n}\n\nreturn current\n}\n```\n\n## 排序算法\n\n## 冒泡排序\n\n从数组的第一个元素开始，依次比较相邻的两个元素，如果前一个元素大于后一个元素，就交换它们的位置，这样大的元素会逐步“冒泡”到数组的末尾。经过一轮比较，最大的元素会位于数组的最后一个位置。然后继续进行下一轮比较，但已经排序好的元素不再参与比较。\n\n```\nfunction bubbleSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n```\n\n## 选择排序\n\n在未排序部分选择最小的元素，然后将其与未排序部分的第一个元素交换，以此逐步构建已排序部分。在每一轮遍历中，算法会找到未排序部分的最小元素的索引，然后与当前轮的第一个元素交换位置，这样当前轮的第一个元素会是已排序部分的最小元素。\n\n与冒泡排序不同，选择排序每轮只进行一次交换操作，因此交换次数相对较少，性能稍优。\n\n```\nfunction selectionSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    let minIndex = i;\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n  }\n  return arr;\n}\n\n```\n\n## 插入排序\n\n将数组划分为已排序和未排序两个部分，初始状态下，第一个元素被视为已排序部分。然后从未排序部分逐个选择元素插入到已排序部分的正确位置，以此逐步构建有序数组。\n\n对于每个待插入元素 `current`，算法会从已排序部分从后往前遍历，将比 `current` 大的元素往后移动一个位置，直到找到合适的位置插入 `current`。\n\n```\nfunction insertionSort(arr) {\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let current = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > current) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = current;\n  }\n  return arr;\n}\n\n```\n\n## 希尔排序\n\n将数组分成多个子数组，分别进行插入排序。初始时，选取一个递减的间隔值 `gap`（通常为数组长度的一半），然后按照这个间隔将数组分成若干组。然后对每组分别进行插入排序，不断缩小间隔值，直到间隔值为 1，完成最后一次插入排序。\n\n希尔排序的关键在于选择合适的间隔序列，不同的间隔序列会影响算法的性能。经过一系列的实验和研究，确定了一些间隔序列，例如希尔序列（1，4，13，40，121...）。\n\n```\nfunction shellSort(arr) {\n  const n = arr.length;\n  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < n; i++) {\n      let temp = arr[i];\n      let j = i;\n      while (j >= gap && arr[j - gap] > temp) {\n        arr[j] = arr[j - gap];\n        j -= gap;\n      }\n      arr[j] = temp;\n    }\n  }\n  return arr;\n}\n\n```\n\n## 归并排序\n\n组递归地划分为两个子数组，然后分别对这两个子数组进行递归的归并排序，最后将两个有序子数组合并成一个有序数组。\n\n`mergeSort` 函数用于递归地将数组划分为子数组，直到每个子数组只包含一个元素或为空。然后，`merge` 函数用于将两个有序子数组合并成一个有序数组。在 `merge` 函数中，分别设置左子数组和右子数组的索引，然后依次比较两个子数组的元素，将较小的元素添加到 `result` 数组中，直到其中一个子数组的元素全部添加完毕。然后将剩余子数组的元素依次添加到 result `数组中`，最终得到有序的合并数组。\n\n```\nfunction mergeSort(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  const middle = Math.floor(arr.length / 2);\n  const left = arr.slice(0, middle);\n  const right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] < right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n\n```\n\n## 快速排序\n\n选择一个基准元素（通常是数组的第一个元素），然后将数组分成小于基准和大于基准的两个部分。接着，对这两个部分分别递归地应用快速排序，最终将所有子数组合并成有序数组。\n\n快速排序的核心是将数组划分为小于基准和大于基准的两部分，这是通过遍历数组并根据元素与基准的比较结果来实现的。首先选择第一个元素作为基准 `pivot`，然后遍历数组的其他元素，将小于基准的元素放入 `left` 数组，将大于基准的元素放入 `right` 数组。\n\n最后，递归地对 `left` 和 `right` 数组应用快速排序，然后将排序后的 `left` 数组、基准元素和排序后的 `right` 数组依次连接起来，形成最终有序的数组。\n\n```\nfunction quickSort(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  const pivot = arr[0];\n  const left = [];\n  const right = [];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(pivot, quickSort(right));\n}\n\n```\n\n## 堆排序\n\n将数组构建成一个堆（通常是最大堆），然后不断地将堆顶元素（最大元素）与堆末尾的元素交换，然后重新调整堆结构，使得交换后的堆仍然满足堆的性质。这样，每次交换后，堆中的最大元素会被置于末尾，最终形成一个有序的数组。\n\n首先通过 `heapify` 函数构建初始的最大堆。然后进行两个阶段的循环：第一个循环用于构建最大堆，从数组的中间位置开始，依次向前调用 `heapify` 函数，使得整个数组满足最大堆的性质；第二个循环用于不断地将堆顶元素与堆末尾元素交换，并重新调整堆，直到整个数组有序。\n\n```\nfunction heapSort(arr) {\n  const n = arr.length;\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n  return arr;\n}\n\nfunction heapify(arr, n, i) {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n  if (left < n && arr[left] > arr[largest]) {\n    largest = left;\n  }\n  if (right < n && arr[right] > arr[largest]) {\n    largest = right;\n  }\n  if (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\n```\n\n## 计数排序\n\n统计数组中每个元素出现的次数，然后根据统计信息构建有序数组。\n\n首先，通过 `Math.min()` 和 `Math.max()` 函数找到数组中的最小值和最大值，然后确定计数数组的范围。然后，创建一个 `countArr` 数组，用于统计每个元素出现的次数。接着，遍历原始数组，将每个元素映射到 `countArr` 数组中，并递增对应元素的计数值。\n\n然后，通过累积计数数组，将计数数组中的每个元素更新为小于等于当前索引的元素总数。这样，`countArr` 数组中的值表示原数组中小于等于该元素值的元素总数。\n\n接下来，从后往前遍历原始数组，根据元素值从 `countArr` 中获取位置，然后将元素放入输出数组 `output` 中，同时将对应计数数组的计数值减少 1。\n\n最后，将 `output` 数组的值赋给原始数组，完成排序。\n\n```\nfunction countingSort(arr) {\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const range = max - min + 1;\n  const countArr = new Array(range).fill(0);\n  const output = new Array(arr.length);\n  \n  for (let i = 0; i < arr.length; i++) {\n    countArr[arr[i] - min]++;\n  }\n  for (let i = 1; i < range; i++) {\n    countArr[i] += countArr[i - 1];\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[countArr[arr[i] - min] - 1] = arr[i];\n    countArr[arr[i] - min]--;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = output[i];\n  }\n  return arr;\n}\n\n```\n\n## 桶排序\n\n将待排序的数据元素分散到不同的桶中，然后对每个桶内的元素进行排序，最后将所有桶的元素按顺序合并起来，形成有序数组。\n\n首先，通过 `Math.min()` 和 `Math.max()` 函数找到数组中的最小值和最大值，然后确定需要的桶的数量。接着，创建一个数组 `buckets`，用于存放不同的桶，以及将待排序元素分散到各个桶中。每个元素根据其值映射到相应的桶中。\n\n然后，对每个桶内的元素进行排序，这里使用了插入排序作为每个桶内部的排序算法。对每个桶使用插入排序的原因是，桶的数量可能较小，而插入排序在小规模数据的排序上性能较好。\n\n最后，将排序后的各个桶的元素按顺序合并到原始数组中，完成整个排序过程。\n\n```\nfunction bucketSort(arr, bucketSize = 5) {\n  if (arr.length === 0) {\n    return arr;\n  }\n  const minValue = Math.min(...arr);\n  const maxValue = Math.max(...arr);\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;\n  \n  const buckets = new Array(bucketCount);\n  for (let i = 0; i < bucketCount; i++) {\n    buckets[i] = [];\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const bucketIndex = Math.floor((arr[i] - minValue) / bucketSize);\n    buckets[bucketIndex].push(arr[i]);\n  }\n  arr.length = 0;\n  for (let i = 0; i < bucketCount; i++) {\n    insertionSort(buckets[i]);\n    arr.push(...buckets[i]);\n  }\n  return arr;\n}\n\n```\n\n## 基数排序\n\n将待排序的非负整数按照个位、十位、百位等位数依次进行分配和收集，从低位到高位逐渐完成排序。\n\n首先，通过 `getMaxDigit` 函数找到数组中最大元素的位数。然后，从个位开始到最高位，循环进行位数的分配和收集操作。\n\n在每一轮循环中，创建一个桶列表 `bucketList`，其中包含 10 个桶（0 到 9）。然后遍历数组中的每个元素，根据当前位数的值将元素放入对应的桶中。之后，将桶列表中的元素按顺序取出并拼接，更新原数组，以便进入下一轮循环。\n\n最终，经过所有位数的循环，数组中的元素将会被依次排列成有序的序列。\n\n```\nfunction radixSort(arr) {\n  const maxDigit = getMaxDigit(arr);\n  for (let digit = 0; digit < maxDigit; digit++) {\n    const bucketList = Array.from({ length: 10 }, () => []);\n    for (let i = 0; i < arr.length; i++) {\n      const digitValue = getDigitValue(arr[i], digit);\n      bucketList[digitValue].push(arr[i]);\n    }\n    arr = bucketList.flat();\n  }\n  return arr;\n}\n\nfunction getMaxDigit(arr) {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    max = Math.max(max, arr[i].toString().length);\n  }\n  return max;\n}\n\nfunction getDigitValue(num, digit) {\n  return Math.floor(Math.abs(num) / Math.pow(10, digit)) % 10;\n}\n\n```', 'public/uploads/1694355177300.png', 2, 5, 1, 1095, '2023-09-12 06:44:14', 1);
INSERT INTO `article` VALUES (41, 4, 'Mr.', 'Genius is an infinite capacity for taking pains. Remember that failure is an event, not a person. The reason why a great man is great is that he resolves to be a great man. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. The Synchronize to Database function will give you a full picture of all database differences. To connect to a database or schema, simply double-click it in the pane. You cannot save people, you can just love them. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. It collects process metrics such as CPU load, RAM usage, and a variety of other resources over SSH/SNMP. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. Optimism is the one quality more associated with success and happiness than any other. The reason why a great man is great is that he resolves to be a great man. Anyone who has never made a mistake has never tried anything new. What you get by achieving your goals is not as important as what you become by achieving your goals. If it scares you, it might be a good thing to try. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. If the plan doesn’t work, change the plan, but never the goal. In the middle of winter I at last discovered that there was in me an invincible summer. Flexible settings enable you to set up a custom key for comparison and synchronization. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. If it scares you, it might be a good thing to try. Anyone who has ever made anything of importance was disciplined. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. To connect to a database or schema, simply double-click it in the pane. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily.', '', 1, 3, 0, 102, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (42, 4, 'Android使用无障碍模式跳过应用广告的实现（仿李跳跳功能）', '## 1.前言\n\n当代移动应用广告的过度侵扰问题已经引起了广大用户的关注和不满。而芒果TV平台运营中心的副总经理陈超推出了一项名为\"摇一摇开屏广告\"的新策略\n\n在这种策略下，用户在不经意间被强制打开广告，这对用户来说无疑是一种糟糕的体验。当人处于运动的状态下，打开某些APP。\n\n而“李跳跳”APP通过利用Android的无障碍模式，\"李跳跳\"成功帮助用户自动跳过这些令人困扰的开屏广告，从而有效地减轻了用户的不便。随之而来的不正当竞争指控引发了对于这类应用的法律和道德讨论。\n\n我决定仿“李跳跳”写一个广告跳过助手，以呼吁对于这种过度侵扰性广告的关注，同时也为广大Android开发者们分享运用的技术原理。\n\n## 2.效果图\n\n![ezgif-2-147d9e39be.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ee9ff7159045ab9797a33de6de58e9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=200&h=445&s=539245&e=gif&f=28&b=066d63)\n\n## 3.无障碍模式\n\n当我们深入探讨\"李跳跳\"及其仿制应用的功能实现时，了解Android的无障碍模式和AccessibilityService以及onAccessibilityEvent函数的详细内容至关重要。这些技术是这些应用背后的核心，让我们更深入地了解它们：\n\n## 3.1Android的无障碍模式\n\n无障碍模式是Android操作系统的一个功能，旨在提高设备的可用性和可访问性，特别是为了帮助那些有视觉、听觉或运动障碍的用户。通过无障碍模式，应用可以获取有关用户界面和用户操作的信息，以便在需要时提供更好的支持。\n\n## 3.2 onServiceConnected函数\n\n这是AccessibilityService的回调函数之一，当服务被绑定到系统时会被调用。在这个函数中，可以进行初始化操作，如设置服务的配置、注册事件监听等。\n\n```\n@Override\npublic void onServiceConnected() {\n    // 在这里进行服务的初始化操作\n    // 注册需要监听的事件类型\n}\n```\n\n## 3.3 onAccessibilityEvent函数\n\n这是AccessibilityService的核心函数，用于处理发生的可访问性事件。在这个函数中，可以检查事件类型、获取事件源信息以及采取相应的操作。 本次功能主要用到的就是这个函数\n\n```\n@Override \npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    // 处理可访问性事件 \n    // 获取事件类型、源信息，执行相应操作 \n}\n```\n\n## 3.4 onInterrupt函数\n\n这个函数在服务被中断时会被调用，例如，用户关闭了无障碍服务或系统资源不足。可以在这里进行一些清理工作或记录日志以跟踪服务的中断情况。\n\n```\n@Override\npublic void onInterrupt() {\n    // 服务中断时执行清理或记录日志操作\n}\n```\n\n## 3.5 onUnbind函数\n\n当服务被解绑时，这个函数会被调用。可以在这里进行资源的释放和清理工作。\n\n```\n@Override\npublic boolean onUnbind(Intent intent) {\n    // 解绑时执行资源释放和清理操作\n    return super.onUnbind(intent);\n}\n```\n\n## 3.6 onKeyEvent函数（未用到）\n\n这个函数用于处理键盘事件。通过监听键盘事件，可以实现自定义的按键处理逻辑。例如，可以捕获特定按键的按下和释放事件，并执行相应操作。\n\n```\n@Override\npublic boolean onKeyEvent(KeyEvent event) {\n    // 处理键盘事件，执行自定义逻辑\n    return super.onKeyEvent(event);\n}\n\n```\n\n## 3.7 onGesture函数（未用到）\n\nonGesture()函数允许处理手势事件。这些事件可以包括触摸屏幕上的手势，例如滑动、缩放、旋转等。通过监听手势事件，可以实现各种手势相关的应用功能。\n\n```\n@Override\npublic boolean onGesture(int gestureId) {\n    // 处理手势事件，执行自定义逻辑\n    return super.onGesture(gestureId);\n}\n\n```\n\n## 4.功能实现\n\n## 4.1无障碍服务的启用和注册\n\n-   创建AccessibilityService的类。\n\n```\npublic class AdSkipService extends AccessibilityService {\n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent event) {\n\n    }\n\n    @Override\n    public void onInterrupt() {\n\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        return super.onUnbind(intent);\n    }\n}\n```\n\n-   在AndroidManifest.xml文件中声明AccessibilityService。\n\n```\n<service android:name=\".service.AdSkipService\"\n    android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\"\n    android:enabled=\"true\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"android.accessibilityservice.AccessibilityService\" />\n    </intent-filter>\n    <meta-data\n        android:name=\"android.accessibilityservice\"\n        android:resource=\"@xml/accessibility_service_config\" />\n</service>\n```\n\n## 4.2 onAccessibilityEvent函数的实现\n\n-   在onAccessibilityEvent函数中获取当前界面的控件，并在异步遍历所有子控件\n\n```\n@Override\npublic void onAccessibilityEvent(AccessibilityEvent event) {\n    // 获取当前界面的控件\n    AccessibilityNodeInfo nodeInfo = event.getSource();\n    \n    taskExecutorService.execute(new Runnable() {\n        @Override\n        public void run() {\n            //遍历节点函数，查找所有控件\n            iterateNodesToSkipAd(nodeInfo);\n        }\n    });\n}\n\n```\n\n-   判断控件的文本是否带有“跳过”二字\n\n```\n/**\n * 判断节点内容是否是关键字(默认为”跳过“二字 )\n * @param node 节点\n * @param keyWords 关键字\n * @return 是否包含\n * */\npublic static boolean isKeywords(AccessibilityNodeInfo node, String keyWords){\n    CharSequence text = node.getText();\n    if (TextUtils.isEmpty(text)) {\n        return false;\n    }\n    //查询是否包含\"跳过\"二字\n    return text.toString().contains(keyWords);\n}\n```\n\n-   触发控件的点击事件\n\n```\n/**\n * 点击跳过按钮\n * @param node 节点\n * @return 是否点击成功\n * */\nprivate boolean clickSkipNode(AccessibilityNodeInfo node){\n    //尝试点击\n    boolean clicked = node.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n    //打印点击按钮的结果\n    LogUtil.e(\"clicked result = \" + clicked);\n    return clicked;\n}\n```\n\n**注：本篇章为了读者方便理解，对代码进行了简化，删去了繁琐的逻辑判断。具体实现详见源码**\n\n## 5.结语\n\n我们通过AccessibilityService和无障碍模式，提供了一种改善用户体验的方法，帮助用户摆脱令人不快的广告干扰。通过了解如何开发这样的应用，我们可以更好地理解无障碍技术的潜力，并在保护用户权益的前提下改善应用环境。\n\n如果对你有所帮助，请记得帮我点一个赞和star，有什么意见和建议可以在评论区给我留言\n\n源码地址：[github.com/Giftedcat/A…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGiftedcat%2FAdSkipHelper \"https://github.com/Giftedcat/AdSkipHelper\")', 'public/uploads/1694330017433.png', 4, 2, 0, 691, '2023-09-10 07:14:07', 1);
INSERT INTO `article` VALUES (43, 7, '架构师必备--分布式数据库Tidb安装部署实践', '本文针对分布式、高可用的tidb数据库，从搭建实际生产环境的集群服务，介绍下tidb的安装流程、安装前的环境检测和系统优化、服务访问等方面介绍下具体的流程，希望对大家熟悉和了解tidb数据库有所帮助，减少不必要的弯路。\n\n**1.概述**\n\nTidb是PingCAP公司自主设计、研发的开源分布式关系型数据库，同时支持在线事务处理与在线分析处理(HTAP)的融合型分布式数据库产品,具备水平扩容或者缩容、金融级高可用。TiDB 适合高可用、强一致要求较高、数据规模较大等各种应用场景。\n\n**2.硬件要求**\n\n生产环境最低要求如下：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51d84a505b848e6a0b254c4b07e2a22~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n开发及测试最低要求如下：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538c9ed474214c3cbc66e22d2d193c54~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n以上是tidb数据库的常用组件，本文只安装tidb、pd、tikv和监控组件\n\n**3.安装前环境检查及系统优化**\n\n-   3.1 磁盘挂载\n\n生产环境部署，建议使用 EXT4 类型文件系统的 NVME 类型的 SSD 磁盘存储 TiKV 数据文件。这个配置方案为最佳实施方案，其可靠性、安全性、稳定性已经在大量线上场景中得到证实。\n\n使用`root`用户登录目标机器，将部署目标机器数据盘格式化成 ext4 文件系统，挂载时添加`nodelalloc`和`noatime`挂载参数。`nodelalloc`是必选参数，否则 TiUP 安装时检测无法通过；`noatime`是可选建议参数。\n\n`注意` 如果你的数据盘已经格式化成 ext4 并挂载了磁盘，可先执行 umount /dev/nvme0n1p1 命令卸载，从编辑 /etc/fstab 文件步骤开始执行，添加挂载参数重新挂载即可。\n\n3.1.1查看数据盘。\n\n```\nfdisk -l\n```\n\n3.1.2 创建分区\n\n```\nparted -s -a optimal /dev/nvme0n1 mklabel gpt -- mkpart primary ext4 1 -1\n```\n\n`注意`\n\n使用 lsblk 命令查看分区的设备号：对于 nvme 磁盘，生成的分区设备号一般为 nvme0n1p1；对于普通磁盘（例如 /dev/sdb），生成的分区设备号一般为 sdb1。\n\n3.1.3 格式化文件系统\n\n```\nmkfs.ext4 /dev/nvme0n1p1\n```\n\n3.1.4查看数据盘分区 UUID。\n\n```\nlsblk -f\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e76e1af75c431287c7a250be00ddff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n3.1.5 编辑 `/etc/fstab` 文件，添加 `nodelalloc` 挂载参数。 执行如下命令进入fstab文件，然后将文本添加到最后一行并保存\n\n```\nvi /etc/fstab\n```\n\n文本：\n\n```\nUUID=c51eb23b-195c-4061-92a9-3fad812cc12f /data1 ext4 defaults,nodelalloc,noatime 0 2\n```\n\n上述的uuid要换成3.1.4步骤中机器实际的uuid，/data1换成服务器上实际被挂载的目录\n\n3.1.6 挂载数据盘\n\n```\nmount -a\n```\n\n3.1.7 `执行以下命令`，如果文件系统为 ext4，并且挂载参数中包含 `nodelalloc`，则表示已生效。\n\n```\nmount -t ext4\n```\n\n-   3.2 关闭防火墙\n\n关闭命令\n\n```\nsystemctl stop firewalld.service\n```\n\n关闭防火墙自启动服务\n\n```\nsystemctl disable firewalld.service\n```\n\n检查防火墙状态\n\n```\nsystemctl status firewalld.service\n```\n\n-   3.3 检测及关闭系统swap\n\nTiDB 运行需要有足够的内存。如果内存不足，不建议使用 swap 作为内存不足的缓冲，因为这会降低性能。建议永久关闭系统 swap。\n\n执行如下命令关闭：\n\n```\necho \"vm.swappiness = 0\">> /etc/sysctl.conf\n\nswapoff -a && swapon -a\n\nsysctl -p\n```\n\n-   3.4 检测及安装NTP服务\n\nTiDB 是一套分布式数据库系统，需要节点间保证时间的同步，从而确保 ACID 模型的事务线性一致性\n\n3.4.1执行以下命令，如果输出running表示 NTP 服务正在运行\n\n```\nsudo systemctl status ntpd.service\n```\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4e040abb4d4afcbab2467d5e751670~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n若返回报错信息Unit ntpd.service could not be found.，请尝试执行以下命令，以查看与NTP进行时钟同步所使用的系统配置是chronyd还是ntpd：\n\n`sudo systemctl status chronyd.service`\n\n3.4.2 执行 ntpstat 命令检测是否与 NTP 服务器同步\n\n```\nntpstat\n```\n\n如果输出synchronised to NTP server，表示正在与 NTP 服务器正常同步 如果系统使用的是ntpd时间同步服务，可忽略3.4.3步骤\n\n3.4.3执行chronyc tracking命令查看 Chrony 服务是否与 NTP 服务器同步。\n\n```\nchronyc tracking\n```\n\n`注意`：该操作仅适用于使用 Chrony 的系统，不适用于使用 NTPd 的系统。 如果该命令返回结果如下，则表示 Chrony 服务未正常运行：需要手动启动该服务 启动chronyd服务并设置自启动:\n\n```\nsystemctl start chronyd   启动服务\nsystemctl status chronyd  查看状态\nsystemctl enable chronyd  设置开机自启\n```\n\n-   3.5 操作系统检查及参数优化\n\n在生产系统的 TiDB 中，建议对操作系统进行如下的配置优化：\n\n1.  关闭透明大页（即 Transparent Huge Pages，缩写为 THP）。\n2.  将存储介质的 I/O 调度器设置为 noop。\n3.  为调整 CPU 频率的 cpufreq 模块选用 performance 模式。\n\n**检查流程：**\n\n3.5.1执行以下命令查看透明大页的开启状态\n\n```\ncat /sys/kernel/mm/transparent_hugepage/enabled\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e5a4b9b0ce4685b55ac50715301238~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) \\[always\\] madvise never表示透明大页处于启用状态，需要关闭。\n\n3.5.2 执行以下命令查看数据目录所在磁盘的 I/O 调度器。\n\n```\ncat /sys/block/sda/queue/scheduler\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a581f7109346efaef6b5ab26b1a663~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) noop \\[deadline\\] cfq 表示磁盘的I/O 调度器使用deadline，需要进行修改。\n\n3.5.3 执行以下命令查看磁盘的唯一标识 ID\\_SERIAL。\n\n`udevadm info --name=/dev/sda | grep ID_SERIAL`\n\n如果多个磁盘都分配了数据目录，需要多次执行以上命令，记录所有磁盘各自的唯一标识。\n\n3.5.4 执行以下命令查看 cpufreq 模块选用的节能策略。\n\n`cpupower frequency-info –policy`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea1182c752af4ce592d31d59687d39ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nThe governor \"powersave\" 表示 cpufreq 的节能策略使用 powersave，需要调整为 performance 策略。\n\n**优化流程：**\n\na、执行 tuned-adm list 命令查看当前操作系统的 tuned 策略。\n\n`tuned-adm list`\n\nCurrent active profile: balanced 表示当前操作系统的 tuned 策略使用 balanced，建议在当前策略的基础上添加操作系统优化配置。\n\nb、创建新的 tuned 策略。(ID\\_SERIAL要换成检查流程第3步中实际的磁盘唯一标识符)\n\n`mkdir /etc/tuned/balanced-tidb-optimal/`\n\n`vi /etc/tuned/balanced-tidb-optimal/tuned.conf`\n\n在文件中添加如下配置\n\n```\n[main]\ninclude=balanced\n\n[cpu]\ngovernor=performance\n\n[vm]\ntransparent_hugepages=never\n\n[disk]\ndevices_udev_regex=(ID_SERIAL=36d0946606d79f90025f3e09a0c1fc035)\nelevator=noop\n```\n\nc、应用新的 tuned 策略。\n\n`tuned-adm profile balanced-tidb-optimal`\n\nd、执行以下命令验证透明大页的状态\n\n`cat /sys/kernel/mm/transparent_hugepage/enabled`\n\ne、执行以下命令命令验证数据目录所在磁盘的 I/O 调度器。\n\n`cat /sys/block/sda/queue/scheduler`\n\nf、执行以下命令查看查看 cpufreq 模块选用的节能策略。\n\n`cpupower frequency-info –policy`\n\ng、执行以下命令修改 sysctl 参数。\n\n```\necho \"fs.file-max = 1000000\">> /etc/sysctl.conf\necho \"net.core.somaxconn = 32768\">> /etc/sysctl.conf\necho \"net.ipv4.tcp_tw_recycle = 0\">> /etc/sysctl.conf\necho \"net.ipv4.tcp_syncookies = 0\">> /etc/sysctl.conf\necho \"vm.overcommit_memory = 1\">> /etc/sysctl.conf\nsysctl -p\n```\n\nh、执行以下命令查配置用户的limits.conf文件\n\n```\ncat << EOF >>/etc/security/limits.conf\ntidb           soft    nofile          1000000\ntidb           hard    nofile          1000000\ntidb           soft    stack          32768\ntidb           hard    stack          32768\nEOF\n```\n\n此外，由于集群服务是安装在多台服务器上，所以需要设置机器之间ssh互信和sudo免密访问，但是如果使用tiup组件管理器，可以不用进行此操作，因为tiup可以自动设置互信和免密。至此，安装前的准备工作已完成，接下来就行实际安装流程。\n\n**4.搭建集群服务**\n\n-   4.1 下载并安装TiUP\n\n`curl --proto \'=https\' --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh | sh`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7caab0c08046e7a60a1ef59a72f206~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n-   4.2 声明全局环境变量\n\n`source ${your_shell_profile}`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a60a05e15cf046beb638982a5e1c8b48~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nTiUP 安装完成后会提示对应 Shell profile 文件的绝对路径。在执行以下 source 命令前，需要将 ${your\\_shell\\_profile} 修改为 Shell profile 文件的实际位置\n\n-   4.3 安装 TiUP 的 cluster 组件\n\n`tiup cluster`\n\n-   4.4 创建并启动集群\n\n安装集群前，需要先创建集群的拓扑文件，此处可以直接先在本地创建好，比如topo.yanl，复制以下内容，然后传到服务器即可。文件中路径和ip根据实际情况声明\n\n```\n# # Global variables are applied to all deployments and used as the default value of\n# # the deployments if a specific deployment value is missing.\nglobal:\n  user: \"tidb\"\n  ssh_port: 22\n  deploy_dir: \"/tidb-deploy\"  #该路径最好换成磁盘上实际挂载的目录下,比如/xxx/tidb-deploy\n  data_dir: \"/tidb-data\"      #该路径最好换成磁盘上实际挂载的目录下,比如/xxx/tidb-data\n\n# # Monitored variables are applied to all the machines.\nmonitored:\n  node_exporter_port: 9100\n  blackbox_exporter_port: 9115\n\nserver_configs:\n  tidb:\n    log.slow-threshold: 3000\n  tikv:\n    readpool.storage.use-unified-pool: false\n    readpool.coprocessor.use-unified-pool: true\n  pd:\n    schedule.leader-schedule-limit: 4\n    schedule.region-schedule-limit: 2048\n    schedule.replica-schedule-limit: 64\n\npd_servers:\n  - host: 10.0.0.1\n  - host: 10.0.0.1\n  - host: 10.0.0.1\n\ntidb_servers:\n  - host: 10.0.0.1\n  - host: 10.0.0.1\n\ntikv_servers:\n  - host: 10.0.0.1\n  - host: 10.0.0.1\n  - host: 10.0.0.1\n\nmonitoring_servers:\n  - host: 10.0.0.1\n\ngrafana_servers:\n  - host: 10.0.0.1\n\nalertmanager_servers:\n  - host: 10.0.0.1\n```\n\n-   4.5执行部署命令前，先检查环境是否满足要求\n\n`tiup cluster check  ./topo.yaml`\n\n如果报错：Error：none of ssh password，identity file ，SSH\\_AUTH\\_SOCK specified，改成如下命令，\n\n`tiup cluster check  ./topo.yaml --user root -p`\n\n然后输入密码即可检查环境。如果环境检查不通过，使用如下命令自行修复\n\n`tiup cluster check  ./topo.yaml --apply --user root -p`\n\n尽量保证检查的结果result栏为pass状态，如果没有绑核，numa绑核对应的那栏失败可以不用太关心，但是其他栏尽量都通过，最不济是warning状态\n\n-   4.6 部署\n\n命令如下：\n\n`tiup cluster deploy <cluster-name> <version> ./topo.yaml --user root -p`\n\n-   4.7 启动集群\n\n`tiup cluster start <cluster-name>`\n\n-   4.8 访问集群\n\n安装 MySQL 客户端。如果已安装 MySQL 客户端则可跳过这一步骤。\n\n```\nyum -y install mysql\n```\n\n访问 TiDB 数据库，密码为空，也可以使用数据库客户端连接\n\n```\nmysql -h 10.0.1.1 -P 4000 -u root\n```\n\n访问 TiDB 的 Grafana 监控：\n\n通过 [http://{grafana-ip}:3000](https://link.juejin.cn/?target=) 访问集群 Grafana 监控页面，默认用户名和密码均为 admin。\n\n访问 TiDB 的 Dashboard：\n\n通过 [http://{pd-ip}:2379/dashboard](https://link.juejin.cn/?target=) 访问集群 [TiDB Dashboard](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.pingcap.com%2Fzh%2Ftidb%2Fstable%2Fdashboard-intro \"https://docs.pingcap.com/zh/tidb/stable/dashboard-intro\") 监控页面，默认用户名为 root，密码为空。\n\n执行以下命令查看集群的拓扑结构和状态：\n\n```\ntiup cluster display <cluster-name>\n```\n\n到此，集群服务搭建完成，可以正常使用。\n\n以下为集群操作的几个常用命令\n\n```\n停止组件\n例如，下列命令只停止 TiDB 组件：\ntiup cluster stop ${cluster-name} -R tidb\n\n停止组件中的某一个节点\ntiup cluster stop ${cluster-name} -N 10.0.6.194:9090\n\n\n启动组件中的某一个节点\ntiup cluster start ${cluster-name} -N 10.0.6.194:9090\n\n\n更改组件的配置后，重启组件\ntiup cluster reload ${cluster-name} -R 组件名，比如tiup cluster reload tidb-pro -R tidb\n```\n\n参考链接[：环境与系统配置检查](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.pingcap.com%2Fzh%2Ftidb%2Fstable%2Fcheck-before-deployment \"https://docs.pingcap.com/zh/tidb/stable/check-before-deployment\")', 'public/uploads/1694354701378.png', 3, 5, 0, 208, '2020-09-10 14:05:02', 1);
INSERT INTO `article` VALUES (44, 1, '🎉OpenTiny 3.8.0 正式发布：推出「极客黑」新主题！', '你好，我是 Kagol，个人公众号：前端开源星球。\n\n[OpenTiny](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2F \"https://opentiny.design/\") 是一套华为云出品的企业级组件库解决方案，适配 PC 端 / 移动端等多端，涵盖 Vue2 / Vue3 / Angular 多技术栈，拥有主题配置系统 / 中后台模板 / CLI 命令行等效率提升工具，可帮助开发者高效开发 Web 应用。\n\n核心亮点：\n\n1.  `跨端跨框架`：使用 Renderless 无渲染组件设计架构，实现了一套代码同时支持 Vue2 / Vue3，PC / Mobile 端，并支持函数级别的逻辑定制和全模板替换，灵活性好、二次开发能力强。\n2.  `组件丰富`：PC 端游80+组件，移动端游30+组件，包含高频组件 Table、Tree、Select 等，内置虚拟滚动，保证大数据场景下的流畅体验，除了业界常见组件之外，我们还提供了一些独有的特色组件，如：Split 面板分割器、IpAddress IP地址输入框、Calendar 日历、Crop 图片裁切等\n3.  `配置式组件`：组件支持模板式和配置式两种使用方式，适合低代码平台，目前团队已经将 OpenTiny 集成到内部的低代码平台，针对低码平台做了大量优化\n4.  `周边生态齐全`：提供了基于 Angular + TypeScript 的 [TinyNG](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview \"https://opentiny.design/tiny-ng/overview\") 组件库，提供包含 10+ 实用功能、20+ 典型页面的 [TinyPro](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Fpro \"https://opentiny.design/pro\") 中后台模板，提供覆盖前端开发全流程的 TinyCLI 工程化工具，提供强大的在线主题配置平台 [TinyTheme](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome \"https://opentiny.design/designtheme/home\")\n\n2023年5月18日，我们发布了 [v3.8.0](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.8.0 \"https://github.com/opentiny/tiny-vue/releases/tag/v3.8.0\") 版本，修复了多处缺陷，并推出了一套新主题：`极客黑`。\n\n目前我们一共有三套主题：\n\n-   华为云默认主题\n-   无限主题\n-   极客黑主题\n\n## 极客黑主题效果\n\n我们一起来看看效果吧🎉\n\n### Button\n\n![1 button.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8459d4e5f2547fa8e9f126e42ad65f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Input / Textarea\n\n![2 input.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6524d00b43b14e4ba5c78bf7e30625b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### CheckBox / Radio / Switch\n\n![3 checkbox.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e252abd2bae48a1a4f77fa92d538c3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Alert\n\n![4 alert.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0323c026a65d4eac89b7f27b7eba849c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Form\n\n![5 form.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ce0d59bfda4836bd2f8aa9525d732f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nTooltip / Popover： ![6 popover.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdff666537174d5bbbef40d94dc8aee8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Modal\n\n![7 modal.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fcdbde514bd49af8677317605fbc4d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Message\n\n![8 message.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf442106fe6471c8d40bd4600f37e62~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Notify\n\n![9 notify.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e22eed4a624d65990eb87ac1ae6be1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Select\n\n![10 select.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6852fe696df472aa881e92d8b9bd832~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Pager\n\n![11 pager.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55894b56db3d45ddbe8de85bb346f1f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### DatePicker\n\n![12 date-picker.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c443f37b20c44e67bdb9187a8f469a50~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### Steps\n\n![13 steps.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2ec122042344f49aefdf2d7d8f85de4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n欢迎大家在评论区回复自己喜欢的主题，并说明原因，我先来！\n\n> 我喜欢极客黑，首先是因为它比较圆润，其次是因为黑色给人一种酷酷的科技感。\n\n## 使用极客黑主题\n\n这么好看的主题，我要怎么才能体验和使用呢？\n\n只需要三步：\n\n-   安装 @opentiny/vue@3.8.0\n-   初始化极客黑主题\n-   使用 OpenTiny 组件\n\n### 第一步：安装 @opentiny/vue@3.8.0\n\n```\nnpm i @opentiny/vue\\@3.8.0\n```\n\n### 第二步：初始化极客黑主题\n\n在 `main.ts` 文件中初始化极客黑主题。\n\n```\nimport TinyThemeTool from \'@opentiny/vue-theme/theme-tool\'\nimport { tinySmbTheme } from \'@opentiny/vue-theme/theme\' // 导入极客黑主题\n\nconst theme = new TinyThemeTool(tinySmbTheme, \'tinyStyleSheetId\') // 初始化极客黑主题\n```\n\n### 第三步：使用 OpenTiny 组件\n\n在 `App.vue` 文件中导入组件，并在模板中使用。\n\n```\n<script setup lang=\"ts\">\nimport { Button as TinyButton } from \'@opentiny/vue\'\n</script>\n\n<template>\n   <tiny-button>按钮</tiny-button>\n   <tiny-button type=\"primary\">主要按钮</tiny-button>\n</template>\n```\n\n效果如下：\n\n![截屏2023-05-21 下午12.54.09.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d6dde297b84b158d835ba28dae4ad3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 切换主题\n\n如果这三个主题我都很喜欢，我想在多个主题之间切换，这要如何实现呢？\n\n也很简单，只需要三步即可：\n\n-   将 theme 对象挂到 vue 实例中\n-   使用 Dropdown 组件做一个简易的主题切换器\n-   调用 changeTheme 当法方法实现主题切换\n\n### 第一步：将 theme 对象挂到 vue 实例中\n\n```\nconst theme = new TinyThemeTool(tinySmbTheme, \'tinyStyleSheetId\') // 初始化极客黑主题\napp.config.globalProperties.theme = theme // 将 theme 对象挂到 vue 实例中\n```\n\n### 第二步：使用 Dropdown 组件做一个简易的主题切换器\n\n```\n<script lang=\"ts\" setup>\nimport { getCurrentInstance } from \'vue\'\nimport {\n  Dropdown as TinyDropdown,\n  DropdownMenu as TinyDropdownMenu,\n  DropdownItem as TinyDropdownItem,\n} from \'@opentiny/vue\'\nimport { tinyInfinityTheme, tinySmbTheme } from \'@opentiny/vue-theme/theme\'\n\nconst THEME_MAP = {\n  \'default-theme\': \'\',\n  \'infinity-theme\': tinyInfinityTheme,\n  \'smb-theme\': tinySmbTheme\n}\n\nconst theme = getCurrentInstance().appContext.config.globalProperties.theme\n\nconst changeTheme = (value) => {\n  theme.changeTheme(THEME_MAP[value.vm.label])\n}\n</script>\n\n<template>\n  <tiny-dropdown\n    style=\"position: fixed; bottom: 60px; right: 60px; cursor: pointer;\"\n    @item-click=\"changeTheme\"\n  >\n    <svg\n      viewBox=\"0 0 1024 1024\"\n      width=\"32\"\n      height=\"32\"\n    >\n      <path d=\"M361.28 853.67h-1c-64.14-0.32-111.49-30-124.48-39.09-33.47-23.43-61.42-63.11-80.82-114.74-17.15-45.65-26.6-98.32-26.6-148.33 0-51.48 10.21-101.42 30.34-148.46 19.43-45.39 47.23-86.14 82.63-121.12 35.37-34.95 76.56-62.4 122.43-81.57 47.48-19.84 97.89-29.91 149.83-29.91 51.95 0 102.36 10.06 149.83 29.91 45.87 19.17 87.06 46.61 122.43 81.57 35.4 34.98 63.2 75.73 82.63 121.12 20.13 47.03 30.34 96.98 30.34 148.46 0 32.15 0 72.16-15.91 107.63-9.52 21.23-29.24 33.94-58.62 37.78-19.38 2.54-41.77 1.44-67.69 0.18-75-3.65-168.33-8.2-233.38 73.46-54.6 68.56-118.02 83.1-161.96 83.11z m152.35-619.22c-85.88 0-166.59 33.03-227.28 93-60.59 59.87-93.95 139.44-93.95 224.05 0 42.51 7.99 87.19 22.51 125.82 14.63 38.93 35.09 69.05 57.61 84.82 18.84 13.19 51.87 27.34 88.09 27.52h0.7c43.07 0 80.71-19.84 111.9-58.99 85.48-107.3 206.48-101.41 286.55-97.51 18.63 0.91 34.72 1.69 47.68 1.03 11.04-0.57 15.96-2.07 17.8-2.83 9.62-22.81 9.62-53.08 9.62-79.86 0-84.62-33.37-164.19-93.95-224.05-60.69-59.97-141.41-93-227.28-93z m310.93 398.49c-0.01 0-0.01 0 0 0-0.01 0-0.01 0 0 0z\" p-id=\"2373\"></path><path d=\"M271.62 644.31a66.11 66.57 0 1 0 132.22 0 66.11 66.57 0 1 0-132.22 0Z\" p-id=\"2374\"></path><path d=\"M293.45 451.7a51.63 52 0 1 0 103.26 0 51.63 52 0 1 0-103.26 0Z\" p-id=\"2375\"></path><path d=\"M437.12 335.46a49.05 49.4 0 1 0 98.1 0 49.05 49.4 0 1 0-98.1 0Z\" p-id=\"2376\"></path><path d=\"M599.66 367.02a49.04 49.39 0 1 0 98.08 0 49.04 49.39 0 1 0-98.08 0Z\" p-id=\"2377\"></path><path d=\"M681.94 504.15a49.04 49.39 0 1 0 98.08 0 49.04 49.39 0 1 0-98.08 0Z\" p-id=\"2378\"></path>\n    </svg>\n    <template #dropdown>\n      <tiny-dropdown-menu popper-class=\"my-class\" placement=\"top\">\n        <tiny-dropdown-item label=\"default-theme\">默认主题</tiny-dropdown-item>\n        <tiny-dropdown-item label=\"infinity-theme\">无限主题</tiny-dropdown-item>\n        <tiny-dropdown-item label=\"smb-theme\">极客黑主题</tiny-dropdown-item>\n      </tiny-dropdown-menu>\n    </template>\n  </tiny-dropdown>\n</template>\n```\n\n### 第三步：调用 changeTheme 当法方法实现主题切换\n\n```\nimport { getCurrentInstance } from \'vue\'\n\nconst theme = getCurrentInstance().appContext.config.globalProperties.theme\n\nconst changeTheme = (value) => {\n  theme.changeTheme(THEME_MAP[value.vm.label])\n}\n```\n\n效果如下：\n\n![截屏2023-05-21 下午1.02.21.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63341f4056ec4545a57e69bb51478c60~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 自定义主题\n\n只需要按照以下格式定义一个主题对象，即可自定义自己的主题，并且通过 changeTheme 方法进行切换。\n\n夏天来了，我想自定义一个西瓜红🍉主题。\n\n![6941684679590_.pic_hd.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88173691d6e34e3bb6841451f35f50a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n先从西瓜的照片里吸取一个颜色：`#ab1b2c`\n\n```\nconst watermelonRedTheme = {\n  id: \'watermelon-red-theme\', // 主题的唯一id，每个主题必须唯一\n  name: \'Watermelon Red Theme\', // 主题的英文名称\n  cnName: \'西瓜红主题\', // 主题的中文名称\n  data: {\n    \'ti-base-color-brand-6\': \'#ab1b2c\', // 西瓜红\n    ...\n  } // 主题变量\n}\n```\n\n然后初始化时传入这个watermelonRedTheme 对象即可：\n\n```\nconst theme = new TinyThemeTool(watermelonRedTheme, \'tinyStyleSheetId\') // 初始化西瓜红主题\n```\n\n你也可以在切换主题的时候传入这个 watermelonRedTheme 对象：\n\n```\ntheme.changeTheme(watermelonRedTheme)\n```\n\n效果如下：\n\n![西瓜红主题.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c214b92abaae45328f8592945756c232~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n如果我既想要极客黑的圆润，又想要西瓜红，怎么办呢？\n\n我们可以继承极客黑主题，在极客黑主题的基础上，加上西瓜红主题的变量，从而实现圆润版本的西瓜红主题。\n\n```\nconst watermelonRedTheme = {\n  id: \'watermelon-red-theme\', // 主题的唯一id，每个主题必须唯一\n  name: \'Watermelon Red Theme\', // 主题的英文名称\n  cnName: \'西瓜红主题\', // 主题的中文名称\n  data: {\n    ...tinySmbTheme.data, // 继承自极客黑主题\n    \'ti-base-color-brand-6\': \'#ab1b2c\', // 西瓜红\n    ...\n  } // 主题变量\n}\n```\n\n效果如下：\n\n![圆润的西瓜红主题.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bea1e9fa8fc42ab8e2754ffe6d6bfc0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n当然实际定制一个主题还有很多细节考虑，不止修改这一个主题变量。\n\n如果你觉得我们的默认主题不好看，不妨尝试下无限主题和极客黑主题。\n\n如果这两个主题依然满足不了你的需求，目前 OpenTiny 提供了 400 多个基础主题变量，5000 多个组件级变量，支持自定义主题，并提供了在线主题配置系统，你也可以轻松配置属于自己的主题。\n\n更详细的主题配置指南，请参考 OpenTiny 的官网文档：[opentiny.design/tiny-vue/zh…](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Fos-theme%2Fdocs%2Ftheme \"https://opentiny.design/tiny-vue/zh-CN/os-theme/docs/theme\")\n\n___\n\n欢迎加入 OpenTiny 开源社区。\n\n添加微信小助手：opentiny-official，一起参与共建！\n\n[OpenTiny](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2F \"https://opentiny.design/\") 官网：[opentiny.design/](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2F \"https://opentiny.design/\")\n\n[Vue组件库](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-vue \"https://opentiny.design/tiny-vue\")：[opentiny.design/tiny-vue](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-vue \"https://opentiny.design/tiny-vue\")\n\n[Angular组件库](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-ng \"https://opentiny.design/tiny-ng\")：[opentiny.design/tiny-ng](https://link.juejin.cn/?target=https%3A%2F%2Fopentiny.design%2Ftiny-ng \"https://opentiny.design/tiny-ng\")\n\nOpenTiny 代码仓库：[github.com/opentiny/](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fopentiny%2F \"https://github.com/opentiny/\") （欢迎 Star ⭐）\n\n往期文章推荐\n\n-   [🌈Create Vite App 支持 OpenTiny 啦](https://juejin.cn/post/7234825495333388325 \"https://juejin.cn/post/7234825495333388325\")\n-   [🌈使用 TinyCLI 两行命令创建一个美观大气的 Admin 系统](https://juejin.cn/post/7217828263258423356 \"https://juejin.cn/post/7217828263258423356\")\n-   [🌈一个 OpenTiny，Vue2 Vue3 都支持！](https://link.juejin.cn/?target=)\n-   [🌈历史性的时刻！OpenTiny 跨端、跨框架组件库正式升级 TypeScript，10 万行代码重获新生！](https://juejin.cn/post/7215971680350093349 \"https://juejin.cn/post/7215971680350093349\")\n-   [🌈OpenTiny 的这些特色组件，很实用，但你应该没见过](https://juejin.cn/post/7219304050668585015 \"https://juejin.cn/post/7219304050668585015\")', 'public/uploads/1694329045230.png', 2, 5, 1, 244, '2023-09-10 06:57:26', 1);
INSERT INTO `article` VALUES (45, 2, '何处是吾乡？（前端人年中总结）11', '![](http://127.0.0.1:3000/public/uploads/1697897486084.png)\n\n\n## 前言\n\n我的老家是湖北黄州，对，就是子瞻兄被贬的那个黄州，我很喜欢苏轼的豪放派诗词，为他积极乐观的生活态度和人格魅力着迷。\n\n本人不知不觉干前端快\\*\\*5个年头\\*\\*了，虽辗转了\\*\\*3个城市\\*\\*，依次在厦门，武汉，杭州历经了\\*\\*4份工作\\*\\*。但依然喜欢那句\\*\\*少年的征途是星辰大海\\*\\*，我不在乎之后我会在那儿，也正是苏轼说的，此心安处便是吾乡！\n\n半年已过，有失有得：\n\n## 失\n\n**第一：** 被裁员。今年开年2月份，公司资金链断裂，开始大规模裁员，那段时间，整个公司都笼罩在裁员的黑色恐怖下，各种新闻又提醒我们大环境不好找工作，前端已死等等，我当时也有所预感我会在名单之类（没有安排工作任务），内心很难过，是那种感觉自己要被抛弃的悲伤，尽管室友安慰我：“说我来公司这么久（一年半），要裁也是裁你之后来的，就算被裁，你也还年轻，肯定能找到”，但那一天终归是来了，部门经理走过来，无奈的拍我肩膀说：_**“兄弟，实在是不好意思，我也没办法了”**_，叫我去办公室谈，我心里的靴子终于落地了，脸上苦笑，在一群同事不可思议的目送下，跟着经理来到办公室，总监也早早坐在里面了，看到我，一声长叹息，接着一些诸如上面的决定，我也没办法这类的话后，我一阵愣神，也在这无奈中被迫接受了。离职流程走的真快，**赔偿n+1**方案我也妥协了！\n\n![](http://127.0.0.1:3000/public/uploads/1697897503649.png)\n\n\n**第二：** 失去了一位朋友。去年，一次同学聚会，认识了一个新朋友，是我同学的同学，聚会结束拍合照的时候，站在我身边，我看清她了，脸蛋圆圆的，双马尾，鼻子挺，戴个眼镜，长相中等，看到她的笑容，我内心OS：“我要找的不就是她吗？”，随后找我同学打听了下，单身可聊，我拿着零食，上去一番勇敢搭讪后，然后顺利要到了微信，向有经验的朋友请教怎么追女生。后来，我经常邀请她周末出来玩，看电影，动物园，火锅，也快速熟络起来，但在一个晚上，我突发奇想的向她表白了，不出意外被拒了，然后关系就慢慢地变得尴尬起来，找她聊微信也常常爱答不理了，我（纯情小处男）表示很受伤，问她原因，她说对我没感觉。我想大概是考验我？我得更加主动些，约她出来玩，找她聊天，可约不出来，聊天也不怎么回消息了，不知不觉到年底了，关系越来越拉胯了。\n\n那段时间，我内心经历了什么，我已不想回忆了，至于她，今年2月15号那天发了一条朋友圈，她官宣脱单，算是在告诉我，别再烦她了，恰恰这天，也是我在公司的last day。。。我本以为我已经释怀了，不曾想我的心头还是有一股说不出的酸楚，晚上和几个要好的同事攒了个酒局，算是离别晚宴吧，期间，酒桌上说了些什么我已经记不得，只记得我多喝了几杯，有些醉。我隐隐的感觉，我心中追逐的光熄灭了， 就像是夜幕下，在茫茫的大海中孤独航行的船，突然看到远方有一座灯塔，于是乎努力的朝着那微弱的灯光划去，使出了浑身解数，精疲力竭，却看到了灯塔骤然熄灭了，又重回黑暗！我也发了一条朋友圈：**失之东隅收之桑榆，塞翁失马焉知非福！** 算是为 被公司裁员的自我安慰和鼓励，也是对失去了这个段关系的自我劝解，罢了~\n\n![](http://127.0.0.1:3000/public/uploads/1697897516221.png)\n 第三：股票亏3w。**麻绳专挑细处断，噩运只找苦命**，如果说上面两件事情给我的是暴击，那投资的股票连续的亏损就是给我的魔法伤害，一直出血。。。那些人说的没错，股票就是放大你的贪婪和恐惧。前年本着价值投资，加入这个血雨腥风的二级市场，没曾想，这个市场就是个无情的机器，不断收割你的财富和精力，劝那些心存幻想的佳人们，**别来沾边**，离得越远越好！\n\n![](http://127.0.0.1:3000/public/uploads/1697897524814.png)\n\n\n## 得\n\n第一：找到工作！在离职了2个多月后，我一直赋闲在家，调整心态、写简历，复习前端知识。外公带给我一只拉布拉多犬，我每天牵着它溜达，照顾它，给它洗澡，在它陪伴下，我内心得到了不少治愈。后来我一起被裁的同事内推了我一家公司，去杭州，内心还犹豫了一下，同父亲聊，他鼓励我去，告诉我还年轻，多出去走走也不是坏事，三轮面试，都还挺顺利的过了，薪资也在我的意料之外，确认上班时间后，我和朋友开车去了趟恩施自驾游，回来就收拾行李去杭州入职了。不过，这次我更多地是运气占了上风，被裁后，自己投递的都没有面试机会，内推还是给力！后面再周末，下班回家，还得多提升自己~\n\n![](http://127.0.0.1:3000/public/uploads/1697897538301.png)\n 第二：鼻骨矫正手术。大学时，打篮球，意外受伤导致鼻骨偏曲了一些，一直没时间做手术，这次终于是有机会了，在离职后的几天，我母亲就为我安排了一个在鼻子整形方面很有名的医生为我做手术。开始我是拒绝的，一个男人做整形方面的手术，作为直男，我很抗拒，后来在我母亲和父亲的说服下，我还是同意了，躺在手术台，我整个紧张到冒汗，局麻，五针打在上嘴唇和鼻翼周围，还有鼻梁上，疼的眼泪直流，整体手术下来，我已经虚脱了。在医院住了几天后就回家调养，等半个月拆线后，看到我的新鼻子，顿时感觉这手术没白做。鼻子整个都挺起来了，山根变高了，脸也小了很多。\n\n![](http://127.0.0.1:3000/public/uploads/1697897550168.png)\n\n## 总结\n\n今年上半年，算是我的转折点， 有一些人离开了我，有一些人又进入到了我的世界中，只是在经历了失与得的之后，我又站在了新的起点，开始新的征程，此时又正如东坡的那句：**回首向来萧瑟去，归去，也无风雨也无晴！**', 'public/uploads/1697897574582.png', 2, 4, 1, 845, '2023-10-21 22:48:42', 1);
INSERT INTO `article` VALUES (46, 1, '10 个可提高开发人员工作效率的 Chrome 扩展程序🔥', '作为开发人员，生产力对于提高工作效率至关重要。幸运的是，有大量资源可以帮助实现这一目标，其中一些资源可以以 Chrome 扩展的形式找到。这些扩展是可以直接安装在 Chrome 中的小型附加组件，提供补充工具并增强整体开发体验。\n\n在本文中，我们将探讨 10 个可以增强我们的开发流程的 Chrome 扩展：\n\n## [Clear Cache](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fclear-cache%2Fcppjkneekbjaeellbfkmgnhonkkjfpdn%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/clear-cache/cppjkneekbjaeellbfkmgnhonkkjfpdn?hl=pt-BR\")\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16cf689c48374188870aced5f83f7afb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n该资源使开发人员能够轻松清除浏览器缓存，确保立即反映最新的代码和设计更改。通过消除所有缓存的数据，此扩展可以防止显示问题并促进更敏捷的开发体验。只需一键点击，没有任何弹出窗口，它就能有效地清除您的数据，并且可以根据您想要删除的数据量进行自定义。\n\n## [JSON Viewer](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fjson-viewer%2Fgbmdgpbipfallnflgajpaliibnhdgobh%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh?hl=pt-BR\")\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b88636d90ce4b5394eb619c96420bcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n此扩展提供了一种有效且改进的方法，可以直接在浏览器中查看 JSON 格式的结构化数据。使用 API 或 JSON 文件时，您可以利用此查看器以更有组织性和可读性的方式轻松分析数据。它清楚地突出显示语法和格式，使您可以更好地理解和评估信息。\n\n## [Wappalyzer](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fwappalyzer-technology-pro%2Fgppongmhjkpfnbhagpmjfkannfbllamg%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/wappalyzer-technology-pro/gppongmhjkpfnbhagpmjfkannfbllamg?hl=pt-BR\")\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9cc06b931bc40f2a081c18adb18ec89~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nWappalyzer 将识别任何访问的网站所使用的技术和工具。激活后，Wappalyzer 会分析网站的代码并提供有关内容管理系统 (CMS)、前端框架、JavaScript 库、Web 服务器、插件等的全面详细信息。Wappalyzer 提供了有关各个网站所采用的技术的宝贵见解，并且这些信息可用于多种目的。\n\n## [Smart Color Picker](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fsmart-color-picker%2Filifjbbjhbgkhgabebllmlcldfdgopfl \"https://chrome.google.com/webstore/detail/smart-color-picker/ilifjbbjhbgkhgabebllmlcldfdgopfl\")\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff46c67b0721493ea54f2b5941669636~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n此扩展使开发人员能够快速识别鼠标所指向的颜色。您可以将鼠标悬停在网页上的任何颜色上，然后复制该颜色的 RGB 或十六进制值。此外，智能拾色器还提供额外的功能，例如调色板和保存常用颜色的功能。例如，当您需要从其他地方获取颜色并通过 CSS 在网页中使用时，这会很方便。\n\n## [actiTIME Time Tracking & Project Management](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Factitime-time-tracking-pr%2Foogddkbohgikljeadnkcepdmekigegck \"https://chrome.google.com/webstore/detail/actitime-time-tracking-pr/oogddkbohgikljeadnkcepdmekigegck\")\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c46c0a2270e54020a271a13eb1941274~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n此扩展提供了一个集成的解决方案，用于跟踪您的时间和管理您的项目，这对于旨在提高生产力和效率的开发人员来说非常有价值。\n\n通过此扩展，您可以轻松记录在特定任务上花费的时间并将工作时间分配给各个项目。此外，该扩展还包括时间跟踪仪表板、目标设定功能，并且可以在用户之间协作使用，例如与同事一起工作时。\n\n## [Window Resizer](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fwindow-resizer%2Fkkelicaakdanhinjdeammmilcgefonfh%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/window-resizer/kkelicaakdanhinjdeammmilcgefonfh?hl=pt-BR\")\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf54e99a4fb14278be9bf5ab13826d9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n通过此扩展，您可以调整浏览器窗口的大小以模拟常见的平板电脑、笔记本电脑、台式机和移动设备尺寸。这有助于您观察您的网站或应用程序在各种设备上的运行情况。这对于确保基于窗口大小的更一致的用户体验至关重要。此外，该扩展还提供预设尺寸并允许用户定义自定义尺寸。\n\n## [CSSViewer](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fcssviewer%2Fggfgijbpiheegefliciemofobhmofgce%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce?hl=pt-BR\")\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10d6dd9e3f424774879d664e0dc64ef9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个有用的工具为 Web 开发人员提供了一种直接在任何网页上检查和分析 CSS 属性的简单方法。激活扩展后，开发人员可以轻松地将鼠标悬停在元素上，以立即观察其应用的 CSS 样式，例如字体、颜色、边距、填充等。它比使用 DevTools 检查更简单。这种实时 CSS 检查功能简化了理解和解决网站设计问题的过程。\n\n## [React Developer Tools](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Freact-developer-tools%2Ffmkadmapgofadopljbjfkapdkoienihi \"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\")\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7423f8b19fa4bcbb9b124de53b77d77~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个强大的扩展专为 React 开发人员量身定制，为直接在浏览器中调试和检查 React 组件提供了不可或缺的工具。通过与 React 生态系统的无缝集成，“React DevTools”使开发人员能够深入了解组件层次结构，仔细检查组件属性和状态，并监控实时组件更新。这种顺畅的集成简化了开发流程，使 React 开发人员能够快速识别和解决问题、提高性能并更深入地了解应用程序的行为。最终，这丰富了整个 React 开发体验。\n\n## [Fake Filler](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Ffake-filler%2Fbnjjngeaknajbdcgpfkgnonkmififhfo \"https://chrome.google.com/webstore/detail/fake-filler/bnjjngeaknajbdcgpfkgnonkmififhfo\")\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e939f8d52ba947b69f122dfff82253b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个方便的工具是专门为简化 Web 开发和测试期间的表单填写而设计的。通过“Fake Filler”，开发人员可以轻松地为输入字段生成真实的占位符数据，例如姓名、电子邮件地址、电话号码、地址等。通过自动化使用多样化且真实的信息填充表单的过程，“Fake Filler”为开发人员在测试和调试阶段节省了宝贵的时间。此扩展对于确保 Web 表单的正确功能和响应能力特别有用，而无需重复手动输入测试数据。总体而言，“Fake Filler”极大地提高了表单测试的效率和准确性，使其成为Web开发人员不可或缺的资源。\n\n## [Web Developer](https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fweb-developer%2Fbfbameneiokkgbdmiekhjnmfkcnldhhm%3Fhl%3Dpt-BR \"https://chrome.google.com/webstore/detail/web-developer/bfbameneiokkgbdmiekhjnmfkcnldhhm?hl=pt-BR\")\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753c00b0790d4a7e96e08af86d84a3cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n该扩展专为 Web 开发人员和设计人员量身定制，为用户提供了一套全面的功能，以简化他们的开发工作流程。从检查和修改 HTML/CSS 元素到分析页面性能和测试响应能力，“Web Developer”在用户友好的界面中提供了一系列实用程序。开发人员可以轻松禁用 JavaScript、清除 cookie、显示图像尺寸、检查页面结构以及其他功能。这一一体化扩展使开发人员能够快速访问基本的 Web 开发工具，促进网站和 Web 应用程序的高效调试、测试和优化。', 'public/uploads/1694329104893.png', 2, 3, 3, 983, '2023-09-10 06:58:32', 1);
INSERT INTO `article` VALUES (47, 1, 'Lodash 前端必备神器：学会这些技巧，让你代码量减半、效率翻倍！', '> Lodash 是一个流行的 JavaScript 实用工具库，提供了许多常用的函数和工具，能够方便地处理集合、字符串、数值、函数等多种数据类型，减少编写重复代码的时间和精力。Lodash 的 API 设计与 ES6 的新特性相似，同时兼容了更早的浏览器版本。Lodash 支持模块化加载，可以通过 npm 或在浏览器中直接引入来使用。\n\nLodash 有多达 300 多个函数，每个函数都有详细的文档和示例，能够快速地满足各种编程需求。同时，Lodash 的功能也非常完善，比如数组、对象等的操作，以及日期、数学计算、函数式编程等多方面支持。Lodash 还提供了链式调用的方式，简化操作的流程。\n\n因此，我很喜欢用它，Lodash 能够大幅度提高前端 JavaScript 编程的效率和可读性，使得代码编写更加快捷、简洁、易懂。如果你还没有使用过 Lodash，建议尝试使用它来优化你的项目，提高开发效率。向大家介绍或简单的展示一下它的能力，或许能够吸引到你。\n\n官方中文参考文档：[www.lodashjs.com](https://link.juejin.cn/?target=https%3A%2F%2Fwww.lodashjs.com \"https://www.lodashjs.com\")\n\n## 一、安装和导入\n\n安装 Lodash 可以使用 npm 命令进行快速安装：\n\n```\nnpm install lodash\n```\n\n安装完成后，可以通过以下两种方式导入 Lodash：\n\n```\nimport _ from \'lodash\';\n// 或者\nconst _ = require(\'lodash\');\n```\n\n也可以通过在 HTML 文件中引入 lodash 库：\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\"></script>\n```\n\n## 二、数组操作\n\n### 1\\. chunk\n\n`_.chunk(array, [size])` 函数可以将一个数组按照指定的大小分割成若干个数组，返回一个新的二维数组。\n\n```\nconst arr = [\'a\', \'b\', \'c\', \'d\', \'e\'];\nconst result = _.chunk(arr, 3);\nconsole.log(result); // [[\'a\', \'b\', \'c\'], [\'d\', \'e\']]\n```\n\n### 2\\. compact\n\n`_.compact(array)` 函数可以将数组中的 falsy 值去除（即 false、null、0、\"\"、undefined、NaN），返回一个新的数组。\n\n```\nconst arr = [\'a\', 0, \'\', null, undefined, NaN, \'b\'];\nconst result = _.compact(arr);\nconsole.log(result); // [\'a\', \'b\']\n```\n\n### 3\\. concat\n\n`_.concat(array, [values])` 函数可以将两个或多个数组合并成一个新数组。\n\n```\nconst arr1 = [\'a\', \'b\'];\nconst arr2 = [\'c\', \'d\'];\nconst result = _.concat(arr1, arr2, \'e\');\nconsole.log(result); // [\'a\', \'b\', \'c\', \'d\', \'e\']\n```\n\n### 4\\. difference\n\n`_.difference(array, [values])` 函数可以返回两个数组之间的差异，即在第一个数组中但不在第二个数组中的所有值组成的数组。\n\n```\nconst arr1 = [1, 2, 3];\nconst arr2 = [2, 3, 4];\nconst result = _.difference(arr1, arr2);\nconsole.log(result); // [1]\n```\n\n### 5\\. drop\n\n`_.drop(array, [n=1])` 函数可以从数组中删除前面指定的 n 个元素，并返回一个新的数组。\n\n```\nconst arr = [1, 2, 3, 4, 5];\nconst result = _.drop(arr, 2);\nconsole.log(result); // [3, 4, 5]\n```\n\n### 6\\. dropRight\n\n`_.dropRight(array, [n=1])` 函数可以从数组中删除后面指定的 n 个元素，并返回一个新的数组。\n\n```\nconst arr = [1, 2, 3, 4, 5];\nconst result = _.dropRight(arr, 2);\nconsole.log(result); // [1, 2, 3]\n```\n\n### 7\\. fill\n\n`_.fill(array, value, [start=0], [end=array.length])` 函数可以用指定的值填充数组。\n\n```\nconst arr = [1, 2, 3, 4, 5];\nconst result = _.fill(arr, \'*\', 1, 4);\nconsole.log(result); // [1, \'*\', \'*\', \'*\', 5]\n```\n\n### 8\\. findIndex\n\n`_.findIndex(array, [predicate=_.identity], [fromIndex=0])` 函数可以返回符合指定条件的元素的索引值，如果没有找到则返回 -1。\n\n```\nconst arr = [\n  { name: \'Alice\', age: 18 },\n  { name: \'Bob\', age: 20 },\n  { name: \'Charlie\', age: 22 }\n];\nconst result = _.findIndex(arr, { age: 20 });\nconsole.log(result); // 1\n```\n\n### 9\\. intersection\n\n`_.intersection([arrays])` 函数可以返回两个或多个数组之间的交集，即在所有数组中都存在的所有值组成的数组。\n\n```\nconst arr1 = [\'a\', \'b\'];\nconst arr2 = [\'b\', \'c\'];\nconst arr3 = [\'b\', \'d\'];\nconst result = _.intersection(arr1, arr2, arr3);\nconsole.log(result); // [\'b\']\n```\n\n## 三、对象操作\n\n### 1\\. assign\n\n`_.assign(object, [sources])` 函数可以合并多个对象，并返回一个新的对象。\n\n```\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2, c: 3 };\nconst result = _.assign(obj1, obj2);\nconsole.log(result); // { a: 1, b: 2, c: 3 }\n```\n\n### 2\\. clone\n\n`_.clone(value)` 函数可以复制一个对象或数组，并返回一个新的对象或数组。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.clone(obj);\nconsole.log(result); // { name: \'Tom\', age: 18 }\n```\n\n### 3\\. has\n\n`_.has(object, path)` 函数可以判断一个对象是否包含指定的属性。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.has(obj, \'age\');\nconsole.log(result); // true\n```\n\n### 4\\. keys\n\n`_.keys(object)` 函数可以返回一个对象所有的属性名组成的数组。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.keys(obj);\nconsole.log(result); // [\'name\', \'age\']\n```\n\n### 5\\. mapKeys\n\n`_.mapKeys(object, [iteratee=_.identity])` 函数可以将一个对象的属性名进行修改，并返回一个新的对象。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.mapKeys(obj, (value, key) => {\n  return key.toUpperCase();\n});\nconsole.log(result); // { NAME: \'Tom\', AGE: 18 }\n```\n\n### 6\\. omit\n\n`_.omit(object, [paths])` 函数可以删除一个对象中指定的属性，并返回一个新的对象。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.omit(obj, \'age\');\nconsole.log(result); // { name: \'Tom\' }\n```\n\n### 7\\. pick\n\n`_.pick(object, [paths])` 函数可以选择一个对象中的指定属性，并返回一个新的对象。\n\n```\nconst obj = { name: \'Tom\', age: 18 };\nconst result = _.pick(obj, \'name\');\nconsole.log(result); // { name: \'Tom\' }\n```\n\n## 四、字符串操作\n\n### 1\\. capitalize\n\n`_.capitalize([string=\'\'])` 函数可以将字符串的第一个字符转换为大写，其余字符转换为小写。\n\n```\nconst str = \'lodash\';\nconst result = _.capitalize(str);\nconsole.log(result); // \'Lodash\'\n```\n\n### 2\\. repeat\n\n`_.repeat([string=\'\'], [n=1])` 函数可以将一个字符串重复 n 次，并返回一个新的字符串。\n\n```\nconst str = \'lodash\';\nconst result = _.repeat(str, 3);\nconsole.log(result); // \'lodashlodashlodash\'\n```\n\n### 3\\. startCase\n\n`_.startCase([string=\'\'])` 函数可以将一个字符串中每个单词的首字母大写，并返回一个新的字符串。\n\n```\nconst str = \'hello world\';\nconst result = _.startCase(str);\nconsole.log(result); // \'Hello World\'\n```\n\n### 4\\. trim\n\n`_.trim([string=\'\'], [chars=whitespace])` 函数可以删除一个字符串两端指定的字符（默认为空格），并返回一个新的字符串。\n\n```\nconst str = \'   lodash   \';\nconst result = _.trim(str);\nconsole.log(result); // \'lodash\'\n```\n\n## 五、高级函数\n\n### 1\\. debounce\n\n`_.debounce(func, [wait=0], [options={}])` 防抖函数可以延迟执行一个函数，并且只有当延迟时间过去后该函数没有被再次调用时才会执行。其中，参数 `func` 是要延迟执行的目标函数；`wait` 是延迟的毫秒数，默认为 0；`options` 是一个可选的配置对象，可以用来额外控制防抖的行为。\n\n```\n// 例如，下面是一个带有搜索框的页面，并且需要在用户停止输入 500 毫秒后才开始搜索：\nfunction search(keyword) {\n  // 根据关键词进行搜索\n  console.log(`Searching for \'${keyword}\'...`)\n}\n\nconst inputEl = document.getElementById(\'search-input\');\n\n// 创建 debounce 函数，最多每 500 毫秒执行一次 search 函数\nconst debouncedSearch = _.debounce(search, 500);\n\n// 监听 input 变化，如果有变化则调用 debouncedSearch 函数\n// 每当出现输入变化时，我们会将输入内容传递给 `debouncedSearch` 函数，这个函数会将搜索操作延迟 500 毫秒后执行。因此，只有用户停止输入 500 毫秒之后，才会真正执行搜索操作\ninputEl.addEventListener(\'input\', (evt) => {\n  const keyword = evt.target.value.trim();\n  debouncedSearch(keyword);\n});\n```\n\n### 2\\. throttle\n\n`_.throttle(func, [wait=0], [options={}])` 节流函数可以限制一个函数在一定时间范围内最多执行一次。也就是说，如果同一个函数在短时间内多次触发，这个函数只会以固定的频率执行。\n\n```\n// 例如，下面是一个点击按钮时每隔 1 秒输出一次 log 的示例：\nfunction log() {\n  console.log(\'Clicked!\');\n}\n\nconst btnEl = document.getElementById(\'click-button\');\n\n// 创建 throttle 函数，最多每 1 秒执行一次 log 函数\nconst throttledLog = _.throttle(log, 1000);\n\n// 监听 click 事件，如果有点击则调用 throttledLog 函数\n// 每当用户点击按钮时，我们会调用 `throttledLog` 函数，这个函数会通过限制函数的执行频率，保证每隔 1 秒钟输出一条日志。即使用户连续点击按钮，也只有第一次点击可以触发函数的执行，后续的点击都会被忽略\nbtnEl.addEventListener(\'click\', (evt) => {\n  throttledLog();\n});\n```\n\n### 3\\. delay\n\n`_.delay(func, [wait], [args])` 函数可以延迟执行一个函数，并指定延迟的时间和参数。\n\n```\nfunction log(name) {\n  console.log(`Hello, ${name}`);\n}\n_.delay(log, 2000, \'Tom\'); // 两秒后输出：\'Hello, Tom\'\n```\n\n### 4\\. forEach\n\n`_.forEach(collection, [iteratee=_.identity])` 函数可以遍历一个集合中的每个元素，并对每个元素进行指定的操作。\n\n```\nconst arr = [\'a\', \'b\', \'c\'];\n_.forEach(arr, (value, index) => {\n  console.log(`${index}: ${value}`);\n});\n// 输出：\n// 0: a\n// 1: b\n// 2: c\n```\n\n### 5\\. sortBy\n\n`_.sortBy(collection, [iteratees=[_.identity]])` 函数可以对一个集合中的元素进行排序，并返回一个新的数组。\n\n```\nconst arr = [\n  { name: \'Tom\', age: 18 },\n  { name: \'Bob\', age: 20 },\n  { name: \'Charlie\', age: 22 }\n];\nconst result = _.sortBy(arr, [\'age\']);\nconsole.log(result); // [{ name: \'Tom\', age: 18 }, { name: \'Bob\', age: 20 }, { name: \'Charlie\', age: 22 }]\n```\n\n## 六、函数式编程\n\n### 1\\. flow\n\n`_.flow([funcs])` 函数可以将多个函数组合成一个新的函数，并返回该新函数。\n\n```\nfunction add(a, b) {\n  return a + b;\n}\nfunction square(n) {\n  return n * n;\n}\nconst newFunc = _.flow([add, square]);\nconst result = newFunc(2, 3); // 等价于 square(add(2, 3))\nconsole.log(result); // 25\n```\n\n### 2\\. memoize\n\n`_.memoize(func, [resolver])` 函数可以对一个函数进行记忆化处理，即缓存该函数的计算结果。\n\n```\nfunction fibonacci(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\nconst memoizedFibonacci = _.memoize(fibonacci);\nconsole.log(memoizedFibonacci(50)); // 第一次运行时会进行计算，后续运行时直接返回缓存的结果\n```\n\n### 3\\. curry\n\n`_.curry(func, [arity=func.length])` 函数可以将一个函数转换为柯里化函数，即逐步传入参数并返回一个新的函数。\n\n```\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconst curriedAdd = _.curry(add);\nconsole.log(curriedAdd(1)(2)(3)); // 6\nconsole.log(curriedAdd(1, 2)(3)); // 6\nconsole.log(curriedAdd(1)(2, 3)); // 6\n```\n\n## 七、数学函数\n\n### 1\\. round\n\n`_.round(number, [precision=0])` 函数可以将一个数字四舍五入到指定的精度。\n\n```\nconst num = 3.1415926;\nconst result = _.round(num, 2);\nconsole.log(result); // 3.14\n```\n\n### 2\\. sum\n\n`_.sum(array)` 函数可以计算一个数组中所有元素的和。\n\n```\nconst arr = [1, 2, 3, 4, 5];\nconst result = _.sum(arr);\nconsole.log(result); // 15\n```\n\n### 3\\. random\n\n`_.random([lower=0], [upper=1], [floating])` 函数可以生成一个随机数。\n\n```\nconst result = _.random(1, 10);\nconsole.log(result); // 生成 1~10 中的一个随机整数\n```\n\n## 八、日期函数\n\n### 1\\. now\n\n`_.now()` 函数可以返回当前的时间戳。\n\n```\nconst timestamp = _.now();\nconsole.log(timestamp); // 当前的时间戳\n```\n\n### 2\\. moment\n\n`_.moment([dateString])` 函数可以将一个日期字符串解析为一个 Moment.js 对象。\n\n```\nconst m = _.moment(\'2019-01-01\');\nconsole.log(m.year()); // 2019\nconsole.log(m.month()); // 0（表示 1 月）\nconsole.log(m.date()); // 1\n```\n\n## 九、异常处理\n\n### 1\\. attempt\n\n`_.attempt(func, [args])` 函数可以尝试执行一个函数，并返回该函数执行的结果，如果出现错误则返回错误对象。\n\n```\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error(\'除数不能为 0\');\n  }\n  return a / b;\n}\nconst result1 = _.attempt(divide, 6, 0);\nconsole.log(result1); // 返回错误对象\nconst result2 = _.attempt(divide, 6, 2);\nconsole.log(result2); // 返回计算结果（3）\n```\n\n### 2\\. isError\n\n`_.isError(value)` 函数可以判断一个值是否为错误对象。\n\n```\nconst err = new Error(\'错误\');\nconsole.log(_.isError(err)); // true\nconsole.log(_.isError(\'hello\')); // false\n```\n\n## 十、对象处理\n\n### 1\\. defaults\n\n`_.defaults(object, [sources])` 函数可以将一个或多个源对象的属性复制到目标对象中，如果目标对象已经存在该属性，则不会被覆盖。\n\n```\nconst object = { a: 1 };\nconst result = _.defaults(object, { a: 2, b: 2 }, { b: 3, c: 3 });\nconsole.log(result); // { a: 1, b: 2, c: 3 }\n```\n\n### 2\\. merge\n\n`_.merge(object, [sources])` 函数可以将一个或多个源对象的属性递归地合并到目标对象中，如果目标对象已经存在该属性，则会被覆盖。\n\n```\nconst object = {\n  a: { b: { c: 1 } },\n  d: [2, 3]\n};\nconst result = _.merge(object, {\n  a: { b: { d: 2 } },\n  d: [4],\n  e: 3\n});\nconsole.log(result);\n// {\n//   a: { b: { c: 1, d: 2 } },\n//   d: [4, 3],\n//   e: 3\n// }\n```\n\n### 3\\. pickBy\n\n`_.pickBy(object, [predicate=_.identity])` 函数可以从一个对象中筛选出符合条件的属性，并返回一个新的对象。\n\n```\nconst object = { a: 1, b: \'hello\', c: true };\nconst result = _.pickBy(object, _.isNumber);\nconsole.log(result); // { a: 1 }\n```\n\n## 十一、集合处理\n\n### 1\\. filter\n\n`_.filter(collection, [predicate])` 函数用于过滤出集合中符合给定条件 `predicate` 的元素，并返回一个新的数组。\n\n-   `collection`：要被遍历的集合，可以是数组、对象或字符串。\n-   `predicate`： 一个函数或对象，用于判断元素是否应该被保留。（断言函数）调用三个参数： _(value, index|key, collection)_ 。\n\n```\n// 1. 一个数字数组 `numbers`。我们想要筛选出其中的偶数。\nconst numbers = [1, 2, 3, 4, 5];\n\nconst result = _.filter(numbers, (num) => num % 2 === 0);\nconsole.log(result);\n// [2, 4]\n// ------------------------------------------------------------------\n// 2.一个包含用户对象的数组 `users`。我们想要筛选出年龄为 `30` 的用户对象。\nconst users = [\n  { name: \'Alice\', age: 25 },\n  { name: \'Bob\', age: 30 },\n  { name: \'Charlie\', age: 20 }\n];\n\nconst result = _.filter(users, { age: 30 });\nconsole.log(result);\n// [{ name: \'Bob\', age: 30 }]\n```\n\n### 2\\. partition\n\n`_.partition(array, predicate)` 是 Lodash 中的函数，用于将一个数组根据给定的条件拆分为两个数组，并返回这两个数组。\n\n该函数接受两个参数：`array` 和 `predicate`。`array` 是要处理的数组，而 `predicate` 是一个函数，用于指定拆分条件。\n\n`_.partition` 方法可以非常方便地根据条件拆分数组，并且保持了原始数组中元素的顺序。\n\n```\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst result = _.partition(numbers, n => n % 2 === 0);\nconsole.log(result);\n\n// [\n//   [2, 4, 6], // 偶数数组\n//   [1, 3, 5]  // 奇数数组\n// ]\n\n\nconst users = [\n  { name: \'John\', age: 25 },\n  { name: \'Jane\', age: 30 },\n  { name: \'Bob\', age: 20 }\n];\n\nconst result = _.partition(users, \'age\');\nconsole.log(result);\n\n//[\n//  [\n//    { name: \'John\', age: 25 },\n//    { name: \'Bob\', age: 20 }\n//  ],\n//  [{ name: \'Jane\', age: 30 }]\n//]\n```\n\n### 3\\. union\n\n`_.union([arrays])` 函数可以返回多个数组合并后去重后的新数组。\n\n```\nconst arr1 = [1, 2, 3];\nconst arr2 = [2, 3, 4];\nconst arr3 = [3, 4, 5];\nconst result = _.union(arr1, arr2, arr3);\nconsole.log(result); // [1, 2, 3, 4, 5]\n```\n\n### 4\\. reject\n\n`_.reject(collection, [predicate])` 函数用于从集合中排除符合给定条件 `predicate` 的元素，并返回一个新的数组。\n\n-   `collection`：要被遍历的集合，可以是数组、对象或字符串。\n-   `predicate`：一个函数或对象，用于判断元素是否应该被排除。如果传递一个对象，则会使用 [`_.matches`](https://link.juejin.cn/?target=https%3A%2F%2Flodash.com%2Fdocs%2F4.17.15%23matches \"https://lodash.com/docs/4.17.15#matches\") 进行浅层相等比较。\n\n通过使用 `_.reject` 函数，你可以轻松地根据自定义条件排除集合中的元素，得到一个符合要求的新数组。\n\n```\nconst users = [\n  { name: \'Alice\', age: 25 },\n  { name: \'Bob\', age: 30 },\n  { name: \'Charlie\', age: 20 }\n];\n\nconst result = _.reject(users, { age: 30 });\nconsole.log(result);\n// [{ name: \'Alice\', age: 25 }, { name: \'Charlie\', age: 20 }]\n\nconst numbers = [1, 2, 3, 4, 5];\nconst result = _.reject(numbers, (num) => num % 2 === 0);\nconsole.log(result);\n// [1, 3, 5]\n```\n\n### 5\\. groupBy\n\n`_.groupBy(collection, [iteratee])` 函数根据指定的标准将集合进行分组，并返回一个包含分组结果的对象。\n\n-   `collection`：要被分组的集合，可以是数组、对象或字符串。\n-   `iteratee`：一个函数或属性名称，用作每个元素的分组标准。默认情况下，它使用自身作为键进行分组。\n\n通过使用 `_.groupBy` 函数，你可以根据指定的标准轻松对集合进行分组，并得到一个包含分组结果的对象。\n\n```\n// 我们有一个包含用户对象的数组 `users`。我们想根据用户的名称对它们进行分组。通过调用 `_.groupBy` 函数，并传入 `\'name\'` 作为分组标准，它会遍历整个集合并按照名称进行分组。\nconst users = [\n  { name: \'Alice\', age: 25 },\n  { name: \'Bob\', age: 30 },\n  { name: \'Charlie\', age: 20 },\n  { name: \'Alice\', age: 35 }\n];\n\nconst result = _.groupBy(users, \'name\');\nconsole.log(result);\n/*\n{\n  Alice: [\n    { name: \'Alice\', age: 25 },\n    { name: \'Alice\', age: 35 }\n  ],\n  Bob: [\n    { name: \'Bob\', age: 30 }\n  ],\n  Charlie: [\n    { name: \'Charlie\', age: 20 }\n  ]\n}\n*/\n\n// 我们有一个数字数组 `numbers`。我们使用一个函数作为 `iteratee` 参数，判断元素是奇数还是偶数，并根据结果进行分组\nconst numbers = [1, 2, 3, 4, 5];\nconst result = _.groupBy(numbers, (num) => num % 2 === 0 ? \'even\' : \'odd\');\nconsole.log(result);\n/*\n{\n  odd: [1, 3, 5],\n  even: [2, 4]\n}\n*/\n```\n\n以上就是 Lodash 中一些常用函数的介绍，Lodash 还提供了更多的函数和工具，可以查阅 Lodash 的官方文档以获取更多信息和使用方式， 我很喜欢用它，现希望大家在使用中可以考虑用用，减少重复工作吧。', 'public/uploads/1694329177602.png', 2, 4, 2, 548, '2023-09-10 06:59:49', 1);
INSERT INTO `article` VALUES (48, 4, 'Miss.', 'All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. Anyone who has never made a mistake has never tried anything new. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. Success consists of going from failure to failure without loss of enthusiasm. If it scares you, it might be a good thing to try. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. Genius is an infinite capacity for taking pains. It wasn’t raining when Noah built the ark. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. Navicat Cloud could not connect and access your databases. By which it means, it could only store your connection settings, queries, model files, and virtual group; your database passwords and data (e.g. tables, views, etc) will not be stored to Navicat Cloud. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. A man’s best friends are his ten fingers. Genius is an infinite capacity for taking pains. Genius is an infinite capacity for taking pains. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. Sometimes you win, sometimes you learn. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. There is no way to happiness. Happiness is the way. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. The past has no power over the present moment. Success consists of going from failure to failure without loss of enthusiasm. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections. In the middle of winter I at last discovered that there was in me an invincible summer. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. Difficult circumstances serve as a textbook of life for people. Actually it is just in an idea when feel oneself can achieve and cannot achieve. Anyone who has ever made anything of importance was disciplined. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy.', '', 1, 5, 0, 469, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (49, 6, 'Nuxt3 常用插件集成方案', '### ElementPlus 集成\n\n#### 按需加载\n\n> 目前来看按需加载仅仅针对组件，对于样式并不能实现按需加载。\n\n安装 `Element` 组件库和图标插件。\n\n```\npnpm install element-plus @element-plus/icons-vue\n```\n\n新建 `assets/index.scss` 并输入内容；**注意：** 使用 `.scss` 文件，请先安装对应的 `loader`；`pnpm install sass sass-loader -D`\n\n```\n@use \"element-plus/dist/index.css\";\n```\n\n然后在 `nuxt.config.ts` 中增加如下内容。\n\n```\nexport default defineNuxtConfig({\n  // 定义需要全局加载的文件。\n  css: [\'~/assets/index.scss\'],\n  build: {\n    // 生产环境使用 babel 转译依赖。\n    transpile: process.env.prod ? [\'element-plus\']: []\n  }\n});\n```\n\n最后在 `app.vue` （这只是示例，实际你可以在任何地方去使用） 中去使用它。\n\n```\n<template>\n  <div id=\"app\">\n    <ElConfigProvider size=\"small\" :z-index=\"3000\" :local=\"zhCn\">\n      <ElButton type=\"primary\" size=\"small\">按钮</ElButton>\n      <ElIcon :size=\"20\">\n        <Edit />\n      </ElIcon>\n    </ElConfigProvider>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ElConfigProvider, ElButton, ElIcon } from \'element-plus\';\nimport { ElIcon } from \'@element-plus/icons-vue\';\nimport zhCn from \'element-plus/dist/locale/zh-cn.mjs\';\n</script>\n```\n\n在引用国际化时可能会有些错误，**找不到模块“element-plus/dist/locale/zh-cn.mjs”或其相应的类型声明** 个人目前的解决方案是在项目的根目录新建 `index.d.ts` 然后输入以下内容。如果有更好的方法，欢迎分享。\n\n```\ndeclare module \'element-plus/dist/locale/zh-cn.mjs\'\ndeclare module \'element-plus/dist/locale/en.mjs\'\n```\n\n#### 全量加载\n\n新建 `plugins/element-plus.ts` 在此文件中新增如下配置，注册全局组件。\n\n与按需加载唯一的区别可能就是每次使用时不再需要 `import { * } from \'element-plus\';`。**但实际上按需加载也可以在这里面做，具体方案可以参考下面的 `vant` 以及 `antd` 的集成方案，也是我认为比较合理的方式。**\n\n```\nimport ElementPlus from \'element-plus\';\nimport * as ElementPlusIcons from \'@element-plus/icons-vue\';\n\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.vueApp.use(ElementPlus);\n  for (const [key, component] of Object.entries(ElementPlusIcons)) {\n    nuxtApp.vueApp.component(key, component);\n  }\n});\n```\n\n#### 自动导入\n\n安装插件 `unplugin-vue-components` [`Vue` 组件的按需自动导入](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantfu%2Funplugin-vue-components \"https://github.com/antfu/unplugin-vue-components\")\n\n```\npnpm install unplugin-vue-components -D\n```\n\n然后在 `nuxt.config.ts` 中增加如下配置。遗憾的是 `ElementPlus` 的 `icon` 并不支持这样的操作，或者说是我没有找到对应的方案。\n\n```\nimport Components from \'unplugin-vue-components/vite\';\nimport { ElementPlusResolver } from \'unplugin-vue-components/resolvers\';\n\nexport default defineNuxtConfig({\n  vite: {\n    plugins: [\n      Components({ \n        resolvers: [ElementPlusResolver()]\n      })\n    ],\n    ssr: {\n      noExternal: [\'element-plus\'],\n    }\n  }\n});\n```\n\n### vant 集成\n\n#### 按需加载\n\n实际上 `vant` 的按需加载完全可以按照 `element-plus` 那样照葫芦画瓢来做，但这里示范官网比较推荐的方式来演示。\n\n需要注意的是：**`vant` 同样不支持样式的按需引入**；ok 先安装组件库。\n\n```\npnpm add vant\n```\n\n再 `plugins/vant.ts` 中去引入全局的样式并且注册组件。\n\n```\nimport { Row, Col, Icon, Image, Cell, Button } from \'vant\';\nimport \'vant/lib/index.css\';\n\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.vueApp\n    .use(Row)\n    .use(Col)\n    .use(Image)\n    .use(Icon)\n    .use(Cell)\n    .use(Button);\n});\n```\n\n最后由于 `nuxt` 框架本身的限制，还需要在 `nuxt.config.ts` 添加一些配置。[问题溯源](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt%2Fframework%2Fissues%2F4084 \"https://github.com/nuxt/framework/issues/4084\")\n\n```\nexport default defineNuxtConfig({\n  experimental: {\n    externalVue: true\n  }\n});\n```\n\n在 `plugins/vant.ts` 中注册后的组件则不需要在像 `ElementPlus` 一样手动导入在使用，可以直接在项目中使用。\n\n```\n<template>\n  <VanButton type=\"primary\" size=\"small\">按钮</VanButton>\n</template>\n```\n\n#### 全量加载\n\n全量的加载也仅仅只是在导入组件时的语法差异上有所体现。\n\n```\nimport Vant from \'vant\';\nimport \'vant/lib/index.css\';\n\nexport default defineNuxtPlugin(nuxtApp => {\n  nuxtApp.vueApp.use(Vant);\n});\n```\n\n#### viewport 移动端适配\n\n安装 `postcss-px-to-viewport` 插件用来转换单位\n\n```\npnpm install postcss-px-to-viewport -D   \n```\n\n随后在 `nuxt.config.ts` 中增加如下配置后重启项目即可生效。\n\n```\nexport default defineNuxtConfig({\n  postcss: {\n    plugins: {\n      \'postcss-px-to-viewport\': {\n        viewportWidth: 375\n      }\n    }\n  }\n});\n```\n\n插件的配置信息显然不止这么多，查看更多配置请移步 [文档](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fevrone%2Fpostcss-px-to-viewport%2Fblob%2Fmaster%2FREADME_CN.md%23%25E9%2585%258D%25E7%25BD%25AE%25E5%258F%2582%25E6%2595%25B0 \"https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0\")\n\n启动项目后在终端中可能会出现 `WARN`⚠️ `postcss-px-to-viewport: postcss.plugin was deprecated. Migration guide: https://evilmartians.com/chronicles/postcss-8-plugin-migration`\n\n`postcss-px-to-viewport` 这个插件配不上 `v8` 版本的 `postcss`，换个插件即可。\n\n```\npnpm install postcss-px-to-viewport-8-plugin\n```\n\n在使用的层面与之前完全一致包括它的配置项。\n\n#### rem 移动端适配\n\n`rem` 布局需要依赖两个插件配合 `postcss-pxtorem` 负责将像素转换为 `rem`。`lib-flexible` 则是用来设置基准值。\n\n```\npnpm install postcss postcss-pxtorem amfe-flexible -D\n```\n\n在 `nuxt.config.ts` 中设置插件内容\n\n```\nexport default defineNuxtConfig({\n  postcss: {\n    plugins: {\n      \'postcss-pxtorem\': {\n        rootValue: 37.5,\n        propList: [\'*\']\n      }\n    }\n  }\n});\n```\n\n最后在 `plugins/vant.ts` 中引入 `lib-flexible` 设置基准值。**注意该库的执行时机**\n\n```\nimport Vant from \'vant\';\nimport \'vant/lib/index.css\';\n// 保证下面的代码在客户端中执行。\nif (process.client) {\n  import(\'amfe-flexible\');\n}\n// ....\n```\n\n插件的配置信息显然不止这么多，查看更多配置请移步 [文档](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcuth%2Fpostcss-pxtorem%23options \"https://github.com/cuth/postcss-pxtorem#options\")\n\n对 `lib-flexible` 有兴趣可以查看 [文档](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible \"https://github.com/amfe/lib-flexible\")\n\n如果你的设计图不是 375 而是其他的大小可以参考 [`vant` 官方配置](https://link.juejin.cn/?target=https%3A%2F%2Fvant-contrib.gitee.io%2Fvant%2F%23%2Fzh-CN%2Fadvanced-usage%23qi-ta-she-ji-gao-chi-cun \"https://vant-contrib.gitee.io/vant/#/zh-CN/advanced-usage#qi-ta-she-ji-gao-chi-cun\")\n\n> 个人见解：从 `lib-flexible` 的文档中来看，目前来说这已经不算是一个完美的方案了，比较推荐实用 `viewport` 方式做移动端开发。\n\n#### 自动引入\n\n安装自动引入插件 `unplugin-vue-components`。\n\n```\npnpm isntall unplugin-vue-components -D\n```\n\n`nuxt.config.ts` 中增加如下配置。\n\n```\nimport Components from \'unplugin-vue-components/vite\';\nimport { VantResolver } from \'unplugin-vue-components/resolvers\';\n\nexport default defineNuxtConfig({\n  vite: {\n    plugins: [\n      Components({\n        resolvers: [VantResolver({ importStyle: \'css\' })]\n      })\n    ],\n    ssr: {\n      noExternal: [\'vant\']\n    }\n  },\n  experimental: {\n    externalVue: true\n  }\n});\n```\n\n此时如果你使用 `rem` 的适配方案就会出现样式的问题。还记得在 `plugins/vant.ts` 中导入的 `lib-flexible` 文件吗？改为自动导入后，实在没有合适的时机去导入这个文件，你当然可以使用 `cdn` 的方式去配置，比如下面这样，但我不是很推荐。\n\n```\nexport default defineNuxtConfig({\n  app: {\n    head: {\n      script: [\n        { src: \'http://amfe-flexible\' }\n      ]\n    }\n  }\n});\n```\n\n也许此时可以弃用 `rem` 的适配方案，使用 `viewport` 方案就不会遇到以上问题，这也是目前比较推荐的方式。\n\n当然自动引入也会存在一些不方便的地方，比如 `Toast` `Dialog` `Notify` `ImagePreview` 这些组件的样式需要你自行去导入。[文档](https://link.juejin.cn/?target=https%3A%2F%2Fvant-contrib.gitee.io%2Fvant%2F%23%2Fzh-CN%2Fquickstart%234.-yin-ru-han-shu-zu-jian-de-yang-shi \"https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart#4.-yin-ru-han-shu-zu-jian-de-yang-shi\")\n\n### antd 集成\n\n#### 按需加载\n\n安装组件库和图标插件。\n\n```\npnpm install ant-design-vue @ant-design/icons-vue\n```\n\n在 `plugins/antd.ts` 中注册组件。**注意：`antd` 的 `icon` 并不是那么的纯粹，所以不能像 `ElementPlus` 那样批量的注册**\n\n```\nimport { Button, Col, Row } from \'ant-design-vue\';\nimport { MessageOutlined , MessageFilled } from \'@ant-design/icons-vue\';\nimport \'ant-design-vue/dist/antd.css\';\n\nconst iconMap = { MessageOutlined, MessageFilled };\nexport default defineNuxtPlugin((nuxtApp) => {\n  // 注册组件\n  nuxtApp.vueApp\n    .use(Button)\n    .use(Col)\n    .use(Row);\n  // 注册 Icon 组件\n  for (let key in iconMap) {\n    nuxtApp.vueApp.component(key, (iconMap as any)[key]);\n  }\n});\n```\n\n或者你也可以像 `ElementPlus` 那样在 `.vue` 文件中那样导入并且直接使用它，不过并不是很推荐那种方式。\n\n随后在 `index.vue` 中使用组件。\n\n```\n<template>\n  <div class=\"index-page\">\n    <MessageOutlined />\n    <AButton type=\"primary\" @click=\"showMessage\">按钮</AButton>\n  </div>\n</template>\n  \n<script setup lang=\'ts\'>\n// 类似于 message 这种方法还是需要手动的导入。\nimport { message } from \'ant-design-vue\'\n  \nconst showMessage = () => {\n  message.success({ content: \'success\' });\n}\n</script>\n```\n\n#### 全量加载\n\n只需要修改导入的方式即可完成全量的加载。\n\n```\nimport antd from \'ant-design-vue\';\n// ....\n\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.vueApp.use(antd);\n  // ....\n}); \n```\n\n#### 自动导入\n\n安装插件 `unplugin-vue-components` [`Vue` 组件的按需自动导入](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantfu%2Funplugin-vue-components \"https://github.com/antfu/unplugin-vue-components\")\n\n```\npnpm install unplugin-vue-components -D\n```\n\n然后在 `nuxt.config.ts` 中增加如下配置，**注意的是像 `message` 这种组件的样式以及需要自行导入。**\n\n```\nimport Components from \'unplugin-vue-components/vite\';\nimport { AntDesignVueResolver } from \'unplugin-vue-components/resolvers\';\n\nexport default defineNuxtConfig({\n  // message 组件的样式文件\n  css: [\'ant-design-vue/es/message/style/css\'],\n  vite: {\n    plugins: [\n      Components({ \n        resolvers: [AntDesignVueResolver({resolveIcons: true})]\n      })\n    ],\n    ssr: {\n      noExternal: [\'moment\', \'compute-scroll-into-view\', \'ant-design-vue\',\'@ant-design/icons-vue\'],\n    }\n  }\n});\n```\n\n### tailwindcss 集成\n\n`tailwind` 的集成倒是非常简单，按照 [文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.tailwindcss.cn%2Fdocs%2Fguides%2Fnuxtjs \"https://www.tailwindcss.cn/docs/guides/nuxtjs\") 跟下来就可以了，不过既然是汇总还是简单记录下。\n\n下载相关依赖包。\n\n```\npnpm install -D @nuxtjs/tailwindcss tailwindcss@latest postcss@latest autoprefixer@latest\n```\n\n在 `nuxt.config.ts` 的 `modules` 中注册插件。\n\n```\nexport default defineNuxtConfig({\n  modules: [\'@nuxtjs/tailwindcss\']\n});\n```\n\n生成 `tailwind.config.js`，并增加 `purge` 选项，在生产环境可以对未使用样式的文件进行 `tree shaking`。\n\n```\n# 生成配置文件\nnpx tailwindcss init\n```\n\n```\n/** @type {import(\'tailwindcss\').Config} */\nmodule.exports = {\n  content: [\n    \'./components/**/*.{vue,js}\',\n    \'./layouts/**/*.vue\',\n    \'./pages/**/*.vue\',\n    \'./plugins/**/*.{js,ts}\',\n    \'./nuxt.config.{js,ts}\',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n最后在 `assets/css/tailwind.css` 中增加以下内容（没有该文件则手动创建）。\n\n```\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n其实完成上面的一系列操作后，`tailwind` 在项目中已经可以使用了。但是 `css` 文件内可能会出现 `Unknown at rule @tailwindcss(unknownAtRules)` 这样的错误，其实原因也很简单就是 `css` 不认识该语法。\n\n根目录下新增 `.vscode/settings.json` 并增加以下内容解决以上问题。这属实是 🤣 物理外挂了；\n\n```\n{\n  \"css.lint.unknownAtRules\": \"ignore\"\n}\n```\n\n### Pinia 集成\n\n`nuxt` 推荐使用内部提供的 `useState` 方法来做 `store`，这确实是一个好的办法，但对于一些企业级的应用，`pinia` 应该更加的适合，当然 `pinia` 也是 `nuxt` 官方比较推荐的仓库管理工具。\n\n如果你想了解更多官方推荐插件 [Nuxt Module](https://link.juejin.cn/?target=https%3A%2F%2Fmodules.nuxtjs.org%2F%3Fversion%3D3.x \"https://modules.nuxtjs.org/?version=3.x\")。\n\n`nuxt` 集成 `pinia` 需要两个包支持。\n\n```\npnpm install @pinia/nuxt pinia\n```\n\n然后在 `nuxt.config.ts` 的 `modules` 中注册插件。[更多的配置参考](https://link.juejin.cn/?target=https%3A%2F%2Fpinia.vuejs.org%2Fzh%2Fssr%2Fnuxt.html%23auto-imports \"https://pinia.vuejs.org/zh/ssr/nuxt.html#auto-imports\")\n\n```\nexport default defineNuxtConfig({\n  modules: [\'@pinia/nuxt\']\n});\n```\n\n至此插件就已经可以使用了，但与普通的 `vue` 项目中使用方式略显不同，减少了 `createPinia` 的步骤。\n\n创建 `/store` 目录并在 `/store/counter.ts` 中写入示例代码。\n\n```\nimport { defineStore } from \'pinia\';\n\nexport const useCounterStore = defineStore({\n  id: \'counter-store\',\n  state: () => ({\n    count: 0\n  }),\n  getters: {\n    doubleCount: state => state.count * 2\n  },\n  actions: {\n    countPlusOne() {\n      this.count++\n    }\n  }\n})\n```\n\n在文件中去使用导入并使用它。\n\n```\n<template>\n  <div class=\"index-page\">\n    count: {{ store.count }}\n    <br />\n    doubleCount: {{ store.doubleCount }}\n    <AButton type=\"primary\" @click=\"store.countPlusOne\">PlusOne</AButton>\n  </div>\n</template>\n  \n<script setup lang=\'ts\'>\nimport { useCounterStore } from \'~/store/count\';\nconst store = useCounterStore();\n</script>\n```\n\n#### 持久化 `store` 集成\n\n`pinia` 的持久化依赖于 `pinia-plugin-persistedstate`。\n\n```\npnpm install pinia-plugin-persistedstate\n```\n\n注册该插件的方式也有两种。分别为 客户端 和 `ssr` 两种方式。在开始之前可以先将 `counterStore` 中增加如下配置。[更多配置参考](https://link.juejin.cn/?target=https%3A%2F%2Fprazdevs.github.io%2Fpinia-plugin-persistedstate%2Fguide%2Fconfig.html \"https://prazdevs.github.io/pinia-plugin-persistedstate/guide/config.html\")\n\n```\nexport const useCounterStore = defineStore({\n  id: \'counter-store\',\n  state: () => ({/** ... */}),\n  getters: {/** ... */},\n  actions: {/** ... */},\n  // 确认该仓库使用持久化\n  persist: true\n})\n```\n\n客户端持久化：`plugins` 下创建 `persistedstate.client.ts` 并输入以下内容。\n\n```\nimport { createPersistedState } from \'pinia-plugin-persistedstate\';\n\nexport default defineNuxtPlugin(nuxtApp => {     \n  nuxtApp.$pinia.use(createPersistedState());\n});\n```\n\n如果按照示例代码去测试是否成功，可能就碰到下面的问题了。 ![WeChat7b6388ed34f311a9bc64de287d11dc65.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831ed562b7af4d30b01d4a5026e7bec5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 对应的解决方案就是需要在使用到 `store` 数据的模板中用 `ClientOnly` 组件包裹一下，类似于这样。\n\n```\n<ClinetOnly>\n  <!-- .... -->\n</ClientOnly>\n```\n\n`ssr` 持久化：`plugins` 下创建 `persistedstate.ts` 并输入以下内容。[了解更多](https://link.juejin.cn/?target=https%3A%2F%2Fprazdevs.github.io%2Fpinia-plugin-persistedstate%2Fframeworks%2Fnuxt-3.html%23ssr-enabled-persistence \"https://prazdevs.github.io/pinia-plugin-persistedstate/frameworks/nuxt-3.html#ssr-enabled-persistence\")\n\n```\n\nimport { createNuxtPersistedState } from \'pinia-plugin-persistedstate/nuxt\';\n\nexport default defineNuxtPlugin(nuxtApp => {\n  nuxtApp.$pinia.use(createNuxtPersistedState(\n    useCookie, {\n      cookieOptions: {\n        maxAge: 3600,\n        sameSite: \'strict\',\n      }\n    }\n  ));\n});\n```\n\n### 异步数据获取方式\n\n> axios 暂不支持 👋🏻（并不代表不能用）。就目前（当前这个时间节点来看）无论是 `@nuxtjs/axios` 还是 `nuxt3` 自身都推荐使用 `$fetch api` 来获取服务端数据。但无论用哪种方式前端都绕不开一个话题。\n\n#### 解决跨域及官方推荐异步获取方式\n\n跨域问题。网上找了一大堆的示例（说到这我忍不住吐槽一句做笔记之前能不能自测一下，全是教你怎么用代理，你自己试了吗？）代理这条路是行不通滴。这个问题的前世今生就看[这个 `issue`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt%2Fframework%2Fdiscussions%2F1223 \"https://github.com/nuxt/framework/discussions/1223\")，[这个也很有参考价值](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt%2Fframework%2Fissues%2F8303 \"https://github.com/nuxt/framework/issues/8303\")。\n\n-   你用了 `vite.server.proxy` 的代理再使用 `useFetch` 就会出现 **`404` 问题**。\n-   你不设置代理使用 `useFetch` 就会出现 **`CORS` 问题**。\n\n看官网示例中 `useFetch` 去请求 `server/api` 下的接口，这种肯定不会有跨域的情况出现，比如这样。\n\n```\n// server/api/calendar.ts\nexport default defineEventHandler(async () => {\n  const res = await fetch(\'http://v.juhe.cn/calendar/day?date=xxx&key=xxx\');\n  const data = await res.json();\n  return data;\n});\n\n// pages/xxx.vue\nconst getServerData = async () => {\n  const { data } = await useFetch(\'api/calendar\');\n  console.log(data.value);\n}\n```\n\n但是如果你采用了这种方案就意味着你的代码量会增加很多，而且还有很大的优化空间。从 `nuxt rc13` 开始推荐使用 `devProxy`，可以解决开发环境下的跨域问题。\n\n```\nexport default defineNuxtConfig({\n  // https://github.com/nuxt/framework/issues/8303 具体参考\n  // 辅助参考以下 issues\n  // https://github.com/nuxt/framework/discussions/1223\n  // https://github.com/unjs/nitro/issues/113\n  // https://github.com/nuxt/framework/issues/6650\n  nitro: {\n    // 更多选项 https://github.com/http-party/node-http-proxy#options\n    devProxy: {\n      \'/api\': {\n        target: \'http://apis.juhe.cn\',\n        changeOrigin: true\n      }\n    }\n  }\n});\n```\n\n在使用时则可以这样编写请求代码。\n\n```\nconst { data, refresh } = useFetch(\n  \'/api/simpleWeather/query\',\n  { \n    params: { city: \'上海\', key: \'xxx\' }\n  }\n);\n```\n\n关于 `url` 开头中的 `/api/` 暂时不确定能不能通过配置在生产环境去掉（后续做项目时可以试下），目前能够预想到的操作就是通过 `DotENV` 根据不同的环境来读取对应的 `baseURL` 进行异步请求。\n\n现在需要做的其实就是将 `useFetch` 进行二次封装即可应用到生产环境去使用它。比如这样\n\n```\ntype RequestOptions = {\n  method?: string;\n  body?: Record<string, unknown>;\n  pick?: string[];\n  params?: Record<string, unknown>;\n};\n\nfunction getBaseURL() {\n  const config = useRuntimeConfig();\n  return process.dev ? config.API_URL : \'\';\n}\n\nexport const useApi = async <Result = unknown>(endpoint: string, opts?: RequestOptions) => {\n  const baseURL = getBaseURL();\n  const headers = useRequestHeaders([\'cookie\']);\n\n  return useFetch<string, Result>(endpoint, {\n    method: opts?.method,\n    body: opts?.body,\n    baseURL,\n    headers,\n    params: opts?.params\n  });\n};\n```\n\n#### axios 获取数据方式\n\n很无奈 `axios` 并没有像 `nuxt2` 一样拥有官方推荐的包。但是仍然不妨碍你去使用它，只是会相对麻烦一些。\n\n```\n<template>\n  <div class=\"home\">\n    <VanButton type=\"primary\" @click=\"getAxiosData\">axios</VanButton>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport axios from \'axios\';\n\nconst key = \'xxx\';\nconst getAxiosData = async () => {\n  const { data } = await axios.get(\'/api/simpleWeather/query\', { params: { key, city: \'上海\' } });\n  console.log(data);\n};\n</script>\n```\n\n如果你真的喜欢使用 `axios` 用来作为你获取异步数据的主要工具，你应该封装一下。[参考](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjekip%2Fnaive-ui-admin%2Ftree%2Fmain%2Fsrc%2Futils%2Fhttp%2Faxios \"https://github.com/jekip/naive-ui-admin/tree/main/src/utils/http/axios\")\n\n目前来看我心中理想的方式就是这样，在 `utils` 中封装之后在 `composables` 中将它变成 `hook` 最后应用到页面中。（当然思想可能不成熟，欢迎指正）\n\n### 国际化 `i18n` 集成\n\n> 目前社区主要有两种集成的方案 ① [i18n 官网集成](https://link.juejin.cn/?target=https%3A%2F%2Fvue-i18n.intlify.dev%2Fguide%2Fintegrations%2Fnuxt3.html \"https://vue-i18n.intlify.dev/guide/integrations/nuxt3.html\") ② [nuxt 推荐模块集成](https://link.juejin.cn/?target=https%3A%2F%2Fv8.i18n.nuxtjs.org%2Fgetting-started%2Fsetup \"https://v8.i18n.nuxtjs.org/getting-started/setup\") 其中各有千秋。但前者缺少一些特性的支持，目前来看我还是更希望使用后者。\n\n#### 入门示例\n\n安装指定的 `npm` 包\n\n```\npnpm add @nuxtjs/i18n@next --save\n```\n\n`nuxt.config.ts` 中添加如下配置\n\n```\nexport default defineNuxtConfig({\n  modules: [\'@nuxtjs/i18n\'],\n  i18n: {\n    vueI18n: {\n      // 使用 compositionApi\n      legacy: false,\n      // 默认的语言\n      locale: \'zhCN\',\n      // 国际化信息\n      messages: {\n        zhCN: {\n          welcome: \'欢迎\'\n        },\n        enUS: {\n          welcome: \'welcome\'\n        }\n      }\n    }\n  },\n});\n```\n\n结合前面安装的组件库，在模板中去使用它\n\n```\n<template>\n  <div class=\"home\">\n    <VanSwitch v-model=\"locale\" active-value=\"zhCN\" inactive-value=\"enUS\"></VanSwitch>\n    <div style=\"width: 100%; height: 200px; border: 1px dashed red; box-sizing: border-box; margin-top: 10px\">\n      {{ $t(\'welcome\') }}\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useI18n } from \'vue-i18n\';\n\nconst { locale, t } = useI18n();\nwatch(\n  () => locale.value,\n  (val: string) => {\n    console.log(t(\'welcome\'));\n  }\n);\n</script>\n```\n\n使用此种方式表面看没有任何问题，但如果你需要做国际化的 `SEO` 可能会有些困难。如果你确实有这个需求，可以去了解一些更高级的内容，比如 `URL` 路由。\n\n#### 国际化本地化\n\n上面的方式集成后，虽然能够切换语言，但当查看网页源码时并没有除默认语言之外其他语言的内容。`i18n` 可以使用路由的功能使国际化更好的支持 `SEO`；此时其他语言就会以 举例： `/en` 的下展示\n\n`nuxt.config.ts` 中新增如下配置\n\n```\nexport default defineNuxtConfig({\n  locales: [\n    \'zn-CN\', \'en-US\'\n  ],\n  defaultLocale: \'zh-CN\',\n});\n```\n\n切换语言的方式随之也要进行改变。\n\n```\n<template>\n  <div>\n    <NuxtLink :to=\"switchLocalePath(\'zh-CN\')\">中文</NuxtLink>\n    <NuxtLink :to=\"switchLocalePath(\'en-US\')\">英文</NuxtLink>\n    <div>{{ $t(\'welcome\') }}</div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nconst switchLocalePath = useSwitchLocalePath();\n</script>\n```\n\n再次提示：如果你需要深度学习可以去 [官网](https://link.juejin.cn/?target=https%3A%2F%2Fv8.i18n.nuxtjs.org%2Fgetting-started%2Fsetup \"https://v8.i18n.nuxtjs.org/getting-started/setup\")\n\n### 代码及git规范\n\n`git` 提交规范的问题，推荐使用 `commitizen` 和 `husky` 去做这件事情，如果你没有任何头绪可以参考 [基于Vue3 + TS + Vite代码提交及代码风格规范](https://juejin.cn/post/7103172180384415781 \"https://juejin.cn/post/7103172180384415781\")\n\n#### `eslint` 集成\n\n`eslint` 推荐使用官网提供方式。[nuxt eslint 配置](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt%2Feslint-config \"https://github.com/nuxt/eslint-config\") 或者你也可以持续关注这个 [`issue`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt-community%2Feslint-module%2Fissues%2F69 \"https://github.com/nuxt-community/eslint-module/issues/69\") 它可能给你带来不一样的集成方式。\n\n安装相关 `npm` 包\n\n```\npnpm add eslint @nuxtjs/eslint-config-typescript -D\n# 不能下载到 devDependencies 中，不然 eslint 无法工作\npnpm add typescript \n```\n\n项目根目录下新增 `.eslintrc` 文件配置规则。\n\n```\n{\n  \"env\": {\n    \"node\": true,\n    \"browser\": true\n  },\n  \"extends\": [\n    \"@nuxtjs/eslint-config-typescript\"\n  ],\n  // 新的规则可以配置在这里。\n  \"rules\": {}\n}\n```\n\n并修改 `vscode` 的配置，就可以实现保存自动 `format code` 目前来看 `nuxt` 是不推荐使用 `prettier` 对代码进行美化，同样不喜欢的还有另一位大佬 `antfu`，具体原因推荐查看 [antfu博客：为什么我不用Prettier](https://juejin.cn/post/7149564942633402382 \"https://juejin.cn/post/7149564942633402382\")\n\n```\n\"prettier.enable\": false,\n\"editor.formatOnSave\": false,\n  \"editor.codeActionsOnSave\": {\n  \"source.fixAll\": false,\n  \"source.fixAll.eslint\": true\n},\n```\n\n或者我们也可以集成其他预设，[@antfu/eslint-config](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantfu%2Feslint-config \"https://github.com/antfu/eslint-config\") 还是比较友好的，毕竟跟随大佬脚步。修改 `.eslintrc`\n\n```\n{\n  \"env\": {...},\n  \"extends\": [\n    \"@nuxtjs/eslint-config-typescript\",\n    \"@antfu\"\n  ]\n  ...\n}\n```\n\n#### `stylelint` 集成\n\n以 `scss` 为例，假如你使用 `less` 也可以作为参考，不过推荐看 [`vben` 项目](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvbenjs%2Fvue-vben-admin \"https://github.com/vbenjs/vue-vben-admin\")作为参考。\n\n安装相关包\n\n```\npnpm install stylelint postcss-html postcss-scss stylelint-config-recommended-vue stylelint-config-standard-scss stylelint-config-recess-order -D\n```\n\n-   `stylelint-config-standard-scss`：`scss` 版本的基础配置；\n-   `stylelint-config-recommended-vue`：有关 `stylelint-config-recommended-vue` 的配置；\n-   `stylelint-config-recess-order`：`css` 属性排序插件；\n-   `stylelint postcss-html postcss-scss`：基准包及依赖包。\n\n在项目根目录新建 `stylelint.config.js` 输入以下内容；更多配置参考[`stylelint` 中文](https://link.juejin.cn/?target=https%3A%2F%2Fstylelint.bootcss.com%2F \"https://stylelint.bootcss.com/\")\n\n```\nmodule.exports = {\n  root: true,\n  extends: [\n    \'stylelint-config-standard-scss\',\n    \'stylelint-config-recommended-vue\',\n    \'stylelint-config-recess-order\',\n  ],\n  customSyntax: \'postcss-html\',\n  overrides: [\n    {\n      files: [\'**/*.{css,scss,vue}\'],\n      customSyntax: \'postcss-scss\',\n    },\n  ],\n  rules: {\n    \'at-rule-no-unknown\': null,\n    \'scss/at-rule-no-unknown\': [true,\n      {\n        ignoreAtRules: [\n          \'tailwind\',\n          \'apply\',\n          \'variants\',\n          \'responsive\',\n          \'screen\',\n          \'function\',\n          \'if\',\n          \'each\',\n          \'include\',\n          \'mixin\',\n        ],\n      },\n    ],\n    \'selector-pseudo-class-no-unknown\': [true,\n      { ignorePseudoClasses: [\'v-deep\'] },\n    ],\n  },\n  ignoreFiles: [\'**/*.js\', \'**/*.jsx\', \'**/*.tsx\', \'**/*.ts\'],\n}\n```\n\n安装 `vscode` 插件 `stylelint`。然后在项目中 `.vscode/settings.json` 中增加如下配置。配合上面 `eslint` 的相关配置即可实现 `**/*.{css,scss,vue}` 文件中样式的保存格式化。\n\n```\n{\n  \"css.lint.unknownAtRules\": \"ignore\",\n  \"scss.lint.unknownAtRules\": \"ignore\",\n  \"stylelint.validate\": [\"css\",\"scss\",],\n}\n```\n\n当然你也可以把配置直接放在配置文件中，但是为了团队的协同，个人还是推荐放到项目的根目录下，但后面又引发的一个问题，我不确定把 `.vscode/` 放到仓库中是否是比较正确的选择。', 'public/uploads/1694336400575.png', 2, 6, 0, 426, '2023-09-10 09:00:02', 1);
INSERT INTO `article` VALUES (50, 3, '面试官问：kafka为什么如此之快？1', '本文总结了Kafka为什么快的原因，4个关键字，磁盘顺序读写，页缓存技术，零拷贝技术，Kafka本身分区机制和批量操作。我们抓住这4个关键字，有点到面地和面试官娓娓道来。\n\nKafka 在性能上确实是一骑绝尘，但在消息选型过程中，我们不仅仅要参考其性能，还有从功能性上来考虑，例如 RocketMQ 提供了丰富的消息检索功能、事务消息、消息消费重试、定时消息等。\n\n通常在大数据、流式处理场景基本选用 Kafka，业务处理相关选择 RocketMQ更佳。', '', 2, 2, 2, 908, '2023-10-22 09:54:20', 1);
INSERT INTO `article` VALUES (51, 1, 'Vue3.2: Pinia的用法之妙', '**本文正在参加[「金石计划」](https://juejin.cn/post/7207698564641996856/ \"https://juejin.cn/post/7207698564641996856/\")**\n\n## 总结（倒叙写法）\n\n~这里先声明一下，下面的总结都是有具体实例和分析的，有需要的JYM请耐心看完😂~\n\n根据源码，以及文档的总结，Pinia是同时兼容 `Vue2` 和 `Vue3`\n\n**那么我们为什么要使用它呢，或者说什么时候才需要使用它？** 相信这是每一个刚接触到这个Pinia名词的时候，都带着的疑问\n\n官网给出的解释：Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态， 哈哈，概念很明显，这不正是我们在 `Vue2` 所使用的 `Vuex` 的功用一致吗。那就不做过多的解读了。\n\n当然升级版本，就像 Vue2 升级到 Vue3 所带来的诸多好处一样。`Vuex` 换成 `Pinia` ，总有其所备受推崇的理由\n\n这里就说下我所知道的关于 `Pinia` 的优点：\n\n-   兼容 Vue2 和 Vue3\n    \n-   抛弃传统的 `Mutation` ，只有 `state, getter` 和 `action` ，简化状态管理库\n    \n-   不需要嵌套 _modules_ ， 使用 Composition api （Pinia [最初是在 2019 年 11 月左右重新设计使用](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fpinia%2Fcommit%2F06aeef54e2cad66696063c62829dac74e15fd19e \"https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e\") [Composition API](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcomposition-api \"https://github.com/vuejs/composition-api\")）\n    \n-   TypeScript支持 （不需要自个添加TS包装器）\n    \n-   扁平化设计，没有 _命名空间模块_。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，也可以说是所有 Store 都是命名空间的\n    \n-   待JYM的帮补充......\n    \n\n## 回忆Vuex\n\n挪用官网的截图\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba847e84c542460588409f40842e2742~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 从图中可以看出，Action、Mutations、State共同组成了`Vuex`全局单例模式管理系统 简略说下Action、Mutations、State的作用\n\n-   `State`负责存储整个应用的状态数据\n-   `Mutations`的中文意思是“变化”，利用它可以更改状态，本质就是用来处理数据的函数\n-   `Actions`也可以用于改变状态，不过是通过触发mutation实现的，重要的是可以包含异步操作\n\n他们的组合形成了一个store对象，可以把它看作是一个容器，如下面代码的样子\n\n```\nconst mutations = {...};\nconst actions = {...};\nconst state = {...};\nVuex.Store({\n  state,\n  actions,\n  mutation\n});\n```\n\n我们都知道，Vuex的状态，在刷新页面后会清理内存，数据会丢失，后面我们通过了两种方案，解决了这个问题，分别是：\n\n-   一、localStorage存储、监听，回显，刷新页面的时候重新赋值给vuex，类似于初始化的作用\n-   二、利用第三方库进行持久化存储， `vuex-persistedstate`\n\n## 疑问Vue3后Pinia数据丢失?\n\n**那么我想问，使用Pinia，当页面刷新的时候，是否也会丢失数据呢?**\n\n看到这里的JYM可能会想，既然提出了这个问题，应该是跟vuex是有反差的，也就是觉得不会丢失数据/\n\n其实，`pinia` 的状态与vuex一样把数据存在内存中，也就是，会和Vuex遇到同样的问题，而且其解决方案也是异曲同工 在状态改变时将其同步到浏览器的存储中，如 `cookie`、`localStorage`、`sessionStorage`。\n\n可以搭配 `pinia-persistedstate-plugin` 插件来实现持久化，原理也是把数据存入localStorage或其他存储区域中，只是插件会帮助自动存入与取出，不需要自己去操作`localstorage`。 如图：\n\n![QQ20230316-084110-HD.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa0d28000234fdea312cf46a086d439~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n当然这个插件的使用也是得益于Pinia开发式API 由于是底层 API，Pania Store可以完全扩展。 以下是我们可以执行的操作列表：\n\n-   向 Store 添加新属性\n-   定义 Store 时添加新选项\n-   为 Store 添加新方法\n-   包装现有方法\n-   更改甚至取消操作\n-   实现本地存储等副作用\n-   **仅**适用于特定 Store\n\n使用 `pinia.use()` 将插件添加到 pinia 实例中，比如刚才说到的`pinia-persistedstate-plugin`\n\n## Pinia的改进\n\n从总结中，说到Pinia摒弃了mutation\n\n## 为什么Pinia不需要mutation了?\n\n我从开始接触Vuex的时候，就觉得mutation特别繁琐，当时就在想，为啥一定要将同步和异步的方法分开呢？\n\n然后我带着疑问查阅资料和翻看源码，大致是这样子：\n\n### vuex中的Mutation真的没必要吗？\n\n在 vuex 里面 actions 只是一个架构性的概念，这个函数想实现什么同步或者异步看你自己的需求，并不作限制，但是若想改变state的状态，需要通过mutation去触发。`vuex` 真正限制的只有 `mutation` 必须是同步的这一点。其实是为了能用 devtools 追踪状态变化，\n\n同步的意义在于每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 `devtools` 就可以打个 `snapshot` 存下来，然后就可以随便 `time-travel` 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。\n\n这样一分析，在Vuex中使用mutation并不是完全没有必要的。\n\n到了Pinia, 将同步异步，统一合并到了action里面，并区分判断同步异步，看下面的源码\n\n```\n const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n    $subscribe(callback, options = {}) {\n        const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n        const stopWatcher = scope.run(() => vueDemi.watch(() => pinia.state.value[$id], (state) => {\n            if (options.flush === \'sync\' ? isSyncListening : isListening) {\n                callback({\n                    storeId: $id,\n                    type: exports.MutationType.direct,\n                    events: debuggerEvents,\n                }, state);\n            }\n        }, assign({}, $subscribeOptions, options)));\n        return removeSubscription;\n    },\n    $dispose,\n};\n```\n\n## Store的定义方式\n\n## 非composition API定义方式\n\n```\nexport const useCounterVue2Store = defineStore(\'counterVue2\', {\n\n  state: () => ({ count: 0 }),\n  getters: {\n    double: (state) => state.count * 2,\n  },\n  actions: {\n    increment() {\n      this.count++\n    },\n\n    incrementAsync() {\n\n    }\n  },\n  persist: {\n    key: \'counterVue2\',\n    storage: localStorage\n  }\n})\n```\n\n保留了state、action以前的部分方式\n\n## composition API定义方式\n\n```\nexport const useCounterStore = defineStore(\'counter\',\n  () => {\n    const count = ref(0)\n    const doubleCount = computed(() => count.value * 2)\n    function increment() {\n      count.value++\n    }\n\n\n    return { count, doubleCount, increment }\n  },\n  {\n    persist: {\n      key: \'userCounter\',\n      storage: localStorage\n    }\n  }\n)\n```\n\n## Store中使用getter\n\n也许这里有人会有困惑，getter每次调用一次，是不是就要计算一次表达公示，比如下面的代码。\n\n其实不然，跟computed一样，当里面依赖的变量不发生改变的时候，是不会重新计算的，它们有数据缓存机制，可以自行测试一下，将getter写成一个方法，然后从中做个断点或者打印值就知道了。\n\n```\ngetters: {\n    double: (state) => state.count * 2,\n}\n```\n\n## getter中调用其它getter\n\n可以直接在getter方法中调用this，this指向的便是store实例, 这里要注意，就不能使用箭头函数了，关于this指向的问题\n\n```\nexport const useCounterVue2Store = defineStore(\'counterVue2\', {\n  state: () => ({ count: 0 }),\n  getters: {\n    double: (state) => state.count * 2,\n    doubleTwo(): number {\n      return this.double + 22\n    }\n  },\n  actions: {\n    increment() {\n      this.count++\n    },\n    incrementAsync() {\n    }\n  }\n})\n```\n\n## getter中调用其它store的getter\n\n```\n  getters: {\n    double: (state) => state.count * 2,\n    doubleTwo(): number {\n      return this.double + 22\n    },\n    // 调用其他store的getter\n    doubleAddOtherStoreGetter: (state) => {\n      const otherCounter = useCounterStore()\n      return otherCounter.count + state.count + 444\n    }\n  }\n```\n\n## getter传参的实现\n\n按照官网的说法，_Getters_ 只是幕后的 _computed_ 属性，因此无法向它们传递任何参数。\n\n但是，可以从 _getter_ 返回一个函数以接受任何参数：\n\n```\n getters: {\n    double: (state) => state.count * 2,\n    doubleTwo(): number {\n      return this.double + 22\n    },\n    // 调用其他store的getter\n    doubleAddOtherStoreGetter: (state) => {\n      const otherCounter = useCounterStore()\n      return otherCounter.count + state.count + 444\n    },\n\n    getFunctionVoid: (state) => {\n      const otherCounter = useCounterStore()\n      return (val: number) => {\n        return 1100 + otherCounter.count\n      }\n    }\n\n  }\n```\n\n**注意**: 如果这样使用，**getter 不会缓存**，它只会当作一个普通函数使用。一般不推荐这种用法，因为在组件中定义一个函数，可以实现同样的功能，如图\n\n```\n   getFunctionVoid: (state) => {\n      const otherCounter = useCounterStore()\n      console.log(\'getFunctionVoid\')\n      let i = 0;\n      return (val: number) => {\n        console.log(i++)\n        return 1100 + otherCounter.count\n      }\n    }\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ede2b4b4e764577a8d835f9429a9dd8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n使用了三次，就连续打印了三次\n\n## Store中actions\n\nActions 相当于组件中的 [methods](https://link.juejin.cn/?target=https%3A%2F%2Fv3.vuejs.org%2Fguide%2Fdata-methods.html%23methods \"https://v3.vuejs.org/guide/data-methods.html#methods\") 与 `getters` 一样，操作可以通过 `this` 访问 _whole store instance_ 并提供**完整类型（和自动完成✨）支持**。 **与它们不同，`actions` 可以是异步的**，您可以在其中`await` 任何 API 调用甚至其他操作\n\n## 订阅 Actions\n\n具体的使用方法可以看官网的介绍，[订阅Actions](https://link.juejin.cn/?target=https%3A%2F%2Fpinia.web3doc.top%2Fcore-concepts%2Factions.html%23%25E4%25B8%258D%25E4%25BD%25BF%25E7%2594%25A8-setup \"https://pinia.web3doc.top/core-concepts/actions.html#%E4%B8%8D%E4%BD%BF%E7%94%A8-setup\")\n\n一般应用场景需要到的，是消息通知相关\n\n## Store的一些函数\n\n## Store的$patch\n\n$patch(第一个参数支持一个对象/函数)\n\n如下：\n\n**对象**\n\n```\nstore.$patch({\n    count: counter.count + 22, \n});\n```\n\n**函数**\n\n```\nstore.$patch(\n(state) => {\n  state.items.push({ name: \'shoes\', quantity: 1 })\n  state.hasChanged = true\n});\n```\n\n## Store的$subscribe\n\n可以通过 store 的 `$subscribe()` 方法查看状态及其变化，类似于 Vuex 的 [subscribe 方法](https://link.juejin.cn/?target=https%3A%2F%2Fvuex.vuejs.org%2Fapi%2F%23subscribe \"https://vuex.vuejs.org/api/#subscribe\")。 与常规的 `watch()` 相比，使用 `$subscribe()` 的优点是 _subscriptions_ 只会在 _patches_ 之后触发一次，意思就是每次执行$patch的时候，会触发一次。\n\n此订阅默认组建销毁后被自动删除，若想保留可`{ detached: true }` 作为第二个参数传递`$subscribe`\n\n![QQ20230315-152825-HD.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f37f676b3b4ce880bc11dde12017af~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 使用过程遇到的bug\n\n## 使用store.$reset()重置数据\n\nUncaught Error: 🍍: Store \"counter\" is built using the setup syntax and does not implement $reset().\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e7f2aa24afd49c8beded3562139cbde~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 解决方法：\n\n```\nimport { createPinia } from \'pinia\';\nimport { createPersistedState } from \'pinia-plugin-persistedstate\';\nconst store = createPinia();\n\nstore.use(({ store }) => {\n  const initialState = JSON.parse(JSON.stringify(store.$state));\n  store.$reset = () => {\n    store.$state = JSON.parse(JSON.stringify(initialState));\n  }\n});\n```\n\n当然这种使用JSON.Stringify的解决方案会存在一定的问题\n\n-   使用JSON.Stringify 转换的数据中，如果包含 function，undefined，Symbol，这几种类型，不可枚举属性， JSON.Stringify序列化后，这个键值对会消失。\n-   转换的数据中包含 NaN，Infinity 值（含-Infinity），JSON序列化后的结果会是null。\n-   转换的数据中包含Date对象，JSON.Stringify序列化之后，会变成字符串。\n-   转换的数据包含RegExp 引用类型序列化之后会变成空对象。\n-   无法序列化不可枚举属性。\n-   无法序列化对象的循环引用，（例如: obj\\[key\\] = obj)。\n-   无法序列化对象的原型链\n\n## 使用store更新state数据其他子页面没有同步更新\n\n我在网上搜寻的解说是如下：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06a290eb4f64e0aa1ddecb85749c6a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 但实际在使用中，我直接访问存储对象也是可以同步的，上面的解答无疑是无中生有\n\n后面经过检查代码发现在\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de0ff7031c334667ae1128ffbf644195~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 访问state的count的时候，是把this.count写成了state.count才导致的无法更新\n\n注意：`computed(() => userDataStore.getProjects)`;这种使用computed并不是为了对单一属性的监听，而是用于计算属性用法才是恰当的\n\n附带查阅： [Pinia中文文档](https://link.juejin.cn/?target=https%3A%2F%2Fpinia.web3doc.top%2Fintroduction.html%23%25E5%259F%25BA%25E6%259C%25AC%25E7%25A4%25BA%25E4%25BE%258B \"https://pinia.web3doc.top/introduction.html#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B\")\n\n**本文正在参加[「金石计划」](https://juejin.cn/post/7207698564641996856/ \"https://juejin.cn/post/7207698564641996856/\")**', '', 2, 2, 0, 654, '2023-07-30 07:00:52', 1);
INSERT INTO `article` VALUES (52, 1, '听说很少有人将Docker讲懂？我来试试！', '> 更好的阅读体验请移步至：[zhengxiaoping.xyz/fullstack/D…](https://link.juejin.cn/?target=https%3A%2F%2Fzhengxiaoping.xyz%2Ffullstack%2FDocker%25E5%259F%25BA%25E7%25A1%2580.html \"https://zhengxiaoping.xyz/fullstack/Docker%E5%9F%BA%E7%A1%80.html\")\n\n本文适用于第一次入门Docker的新手，如果你开始注意到Docker，恭喜你！你将成为一个幸福的人。因为在学完Docker后，相信你会跟我一样，感叹与Docker的相识简直是 **相见恨晚！**\n\n如果告诉你，可以用 **一行命令将nginx运行起来**，你会不会感到惊讶？\n\n如果告诉你，还是 **一行命令，不仅将nginx运行起来，并且将你的网站运行在其中** ，你是否会感到惊讶？\n\n先不要惊讶。让我们现在就开始动手，将上面不可思议的事情变成现实！\n\n## 安装Docker\n\n在开始学习Docker知识前，先花几分钟的时间安装Docker。推荐以Windows作为入门Docker的平台，因为Windows版的Docker Desktop有很良好的界面，对于新手而言非常友好。\n\n下载链接：[www.docker.com/](https://link.juejin.cn/?target=https%3A%2F%2Fwww.docker.com%2F \"https://www.docker.com/\")\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b47ac875b02437a89f8c13377f38a03~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 其他系统的安装也是非常简单、快速的，参考官网的安装文档即可。\n\n## 开胃菜：在Docker上跑一个服务器\n\n首先，我们在本地D盘的hello-docker目录，新建一个index.html文件，内容如下：\n\n```\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Hello</title>\n</head>\n<body>\n\n  Hello, Docker!\n  \n</body>\n</html>\n```\n\n然后，打开控制台，运行一行命令：\n\n```\ndocker run -d -p 80:80 -v d:/hello-docker:/usr/share/nginx/html nginx:latest\n```\n\n紧接着，我们打开 `http://localhost/` ，奇妙的事情发生了：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ba05e274ff4fb394d0b4abfb2f6be1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n整个过程不到1分钟，我们已经将开发的内容部署到nginx服务器上了！！\n\n是的，这就是Docker。**事实上，使用Docker，你只需要输入一行命令，就可以将一个整合了多个服务器及各种中间件的庞大系统运行起来。更为美妙的是，当你为你的服务更换主机时，仍然只需要一行命令，就搞定所有事情。**\n\n## 理解Docker\n\n前面我们通过一行命令成功把一个静态web网页部署到了nginx上，对于使用者而言会非常好奇，Docker到底是怎么做到这一切的呢？\n\n事实上， **你的软件如何配合运行是确定的** ，例如一个简单的博客系统，至少由以下三个部分构成：\n\n-   数据库（存储数据）\n-   应用服务器（提供应用接口）\n-   web静态服务器（前端应用部署）\n\n为了让你的博客应用跑起来，你可能需要这些步骤：\n\n1.  安装mysql，设置用户名与密码，并运行\n2.  运行一个node服务器（如express或koa），连接mysql，这个步骤需要指定主机名、端口、用户名、密码等信息\n3.  运行一个nginx服务器，将开发的代码部署在其上，此步骤根据需要可能需要修改nginx的配置文件\n\n**你会发现，不管你换多少台主机进行部署，你总是要重复上面的步骤，而这些步骤只是在第一次思考它时具有价值，后续的所有劳作都是冗余的、无意义的。**\n\nDocker就是来 **管理这些步骤** 的，正因为系统需要哪些配件以及各部分怎么配合运行是确定的，因此，可以将这些制作为一个标准的流程，由Docker去管理。\n\n正如它的名字（Dock：船坞），Docker是一个码头工人，负责搬运你的货物（应用），将你的工作中最为枯燥、无意义的一部分彻底接管。\n\n长话短说，你可以认为：\n\n有了Docker，你再也不需要亲力亲为去安装和配置那些复杂的软件，软件供应商会将自己的软件以及它的运行环境打包好，你只要吩咐Docker将它们搬过来，然后按一下开机键，就可以运行了。\n\n## 理解镜像与容器的关系\n\n前面的叙述涉及到Docker最核心的两个概念：软件供应商打包好的可运行的货物，称为 **镜像** ，而你运行的，称为 **容器** 。（注意，镜像与容器并不是一对一的关系，这里的叙述并不准确，详情请继续阅读）\n\n如果你是一个有面向对象开发经验的开发者，理解镜像与容器的关系非常简单，镜像就是类，容器就是对象（或实例）。\n\n如果你不是，那么你可以简单理解这些关系：\n\n-   **镜像 = 菜谱。** 例如nginx镜像就如鱼香茄子的菜谱，详细说明了鱼香茄子的制作过程（调料、原料、锅、火候等）；\n-   **Docker = 厨师。** Docker从码头工人摇身一变成为米其林大厨，它负责按照菜谱的要求准备材料并烹饪你的美食；\n-   **容器 = 菜。** 当Docker这个“大厨”完成烹饪后，你就获得了一份鱼香茄子。\n\n因此，你可以让Docker炒5份鱼香茄子（一个镜像运行多个容器，构造集群环境），同一份菜，可能有多个菜谱，可能有的菜谱做出的鱼香茄子会有一些地方特色，例如广东的鱼香茄子会加入沙茶酱（同一类镜像可能有多个版本，有一些会提供一些已有配置或高级特性，例如nginx的官方镜像和其他厂商实现的镜像）。\n\n同时，不同的菜，菜谱的厚度是不同的，西红柿炒蛋可能1页就够，可是满汉全席可能需要一本书（不同镜像的大小是不一的，可以简单认为镜像要做的事情越多越杂，镜像就越大）。\n\n## 如何将一个容器跑起来？\n\n还是以菜谱、厨师与菜的关系来理解，首先：\n\n**第一步：你得有个厨师（安装Docker）**\n\n**第二步：要根据你的需求，获取你的菜谱，这个过程被称为拉取镜像。**\n\n例如你想获得一个nginx镜像，只需要使用这个命令即可：\n\n```\ndocker pull nginx:latest\n# 或：\n# docker image pull nginx:latest\n```\n\n你可以使用 `docker image ls` 或直接在Docker Desktop中查看刚刚拉取的镜像：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d11716bd9f4a8092f15272b021e56d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**第三步：吩咐厨师，做菜！（运行镜像，容器化/实例化）**\n\n```\ndocker run -d -p 80:80 nginx:latest\n```\n\n最后，打开 `http://localhost` ，就可以食用你的美食了！\n\n## 制作自己的“菜谱”\n\n前面我们说过，镜像是菜谱，Docker是厨师，容器是菜，那我们能不能让Docker在做菜的时候放点其他调料呢？不能。厨师会忠实地按照菜谱做菜，并不会改造菜谱。那如何做一份定制的鱼香茄子呢？你需要执行以下步骤：\n\n1.  按照鱼香茄子的菜谱，制作一份自己的菜谱（例如在出锅前放一勺糖）；\n2.  吩咐厨师，按照自己的菜谱做菜，做出符合自己口味的鱼香茄子。\n\n这个制作定制菜谱的过程就是 **镜像制作** 。\n\n镜像制作需要的核心元素就是 `Dockerfile`，相信你曾经不止一次看到过它，它就是“菜谱”，用来描述你定制的这道菜的制作过程。让我们来看一个简单的例子：\n\n```\nFROM nginx:latest\n\nCOPY . /usr/share/nginx/html\n```\n\n-   `FROM nginx:latest` 基于nginx镜像制作新的镜像，好比基于鱼香茄子的菜谱制作自己的鱼香茄子菜谱\n-   `COPY . /usr/share/nginx/html` 将目录内容拷贝到nginx的入口目录，这样未来运行nginx时，就能跑起自己的项目了\n\n接下来，你需要开始制作镜像：\n\n```\ndocker build -t mynginx:latest .\n```\n\n## 不如？现在就来运行一个博客？\n\n首先，我们需要运行一个数据库来存储我们博客的数据，不如就mysql吧。打开命令行运行命令：\n\n```\ndocker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=blog mysql:latest\n```\n\n命令详解：\n\n-   `-d` 后台运行\n-   `-p 3306:3306` 暴露端口，将内部3306端口映射到本机3306端口（如果本机存在mysql并已运行，则会发生端口占用报错）\n-   `-e MYSQL_ROOT_PASSWORD=root` 设置mysql的root用户密码为 `root`\n-   `-e MYSQL_DATABASE=blog` 设置mysql默认数据库，这里设置为blog，会自动创建\n-   `mysql:latest` 使用mysql的latest版本作为镜像\n\nmysql容器运行后，你可以通过例如Navicat等数据库客户端连接，因为它的端口已经暴露到了本机。\n\n接下来，我们来运行一个node服务器并连接mysql。\n\n我们选择koa作为框架，首先，安装依赖：\n\n```\npnpm i koa mysql2\n# yarn add koa mysql2\n# npm i koa mysql2\n```\n\n`db.js`\n\n```\nconst mysql = require(\'mysql2\')\nconst { MYSQL_HOST } = require(\'./config\')\n\nlet pool\n\nexports.createPool = function() {\n  pool = mysql.createPool({\n    host: MYSQL_HOST,\n    port: \'3306\',\n    user: \'root\',\n    password: \'xpzheng\',\n    database: \'hello\',\n    charset: \'utf8mb4\',\n  })\n  \n  return pool\n}\n\nexports.init = function() {\n  return new Promise((resolve, reject) => {\n    pool.getConnection((err, conn) => {\n      if (err) return console.error(err)\n      conn.execute(\'drop table if exists t_blog;\', (err) => {\n        if (err) return reject(err)\n        conn.execute(`create table t_blog (\n          title varchar(255),\n          text text\n        );`, (err2) => {\n          if (err2) return reject(err2)\n          resolve()\n        })\n      })\n    })\n  })\n}\n\n```\n\n`index.js`\n\n```\nconst Koa = require(\'koa\')\nconst cors = require(\'@koa/cors\')\nconst Router = require(\'@koa/router\')\nconst { createPool, init } = require(\'./db\')\n\nconst app = new Koa()\nconst router = new Router()\nlet db\n\nfunction query(sql) {\n  return new Promise((resolve, reject) => {\n    db.query(sql, (err, results) => {\n      if (err) return reject(err)\n      resolve(results)\n    })\n  })\n}\n\nfunction execute(sql) {\n  return new Promise((resolve, reject) => {\n    db.getConnection((err, conn) => {\n      if (err) return reject(err)\n      conn.execute(sql, err2 => {\n        if (err2) return reject(err2)\n        resolve()\n      })\n    })\n  })\n}\n\nrouter.get(\'/\', ctx => {\n  ctx.redirect(\'hello\')\n})\n\nrouter.get(\'/hello\', ctx => {\n  ctx.body = \'Hello, Koa!\'\n})\n\nrouter.get(\'/blog/add\', async(ctx) => {\n  if (!ctx.query.title || !ctx.query.text) {\n    ctx.body = \'请传入标题与内容\'\n    return\n  }\n  await execute(`\n    insert into t_blog (title, text) values (\'${ctx.query.title}\', \'${ctx.query.text}\')\n  `)\n  ctx.body = true\n})\n\nrouter.get(\'/blog/list\', async(ctx) => {\n  const result = await query(`select * from t_blog`)\n  ctx.body = result\n})\n\napp\n  .use(cors())\n  .use(router.routes())\n  .use(router.allowedMethods())\n  .use(async(ctx, next) => {\n    next()\n  })\n\n;(async function() {\n  try {\n    db = createPool()\n    await init();\n  } catch (err) {\n    console.error(err)\n  }\n  app.listen(3000)\n})()\n\n```\n\n在 `db.js` 中，我们连接了msyql并创建了 `t_blog` 表。`index.js` 文件中，我们提供了一个添加文章与查询文章列表的接口。\n\n接下来，我们再创建一个vite项目，访问这个node服务，添加或获取文章数据。\n\n最后，将该项目部署在nginx中，访问效果如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbbbc2fcbfc74780b25e940c4abc95bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n至此，我们将整个博客应用搭建并部署成功了！\n\n> 具体代码请参考：[github.com/shoppingzh/…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshoppingzh%2Flearn-docker \"https://github.com/shoppingzh/learn-docker\")\n\n## Docker学习路线\n\n以下推荐了一个较为合理的Docker学习路线，不管你选择的路线是什么，还是推荐从官方文档入手。\n\n-   安装Docker\n-   理解镜像与容器的关系\n-   使用官方镜像，在Docker上跑一个服务器\n-   自己制作一个镜像\n-   常用Docker命令\n-   制作自己的镜像，跑一个简单的应用\n-   进一步学习：认识网络与卷\n-   多容器部署面临的困境\n-   认识Docker Compose\n-   Docker知识体系\n-   分布式部署\n-   未完待续...\n\n## 常用命令\n\n### 镜像\n\n**列出所有镜像**\n\n```\ndocker image ls\n```\n\n**删除镜像**\n\n```\ndocker image rm nginx:latest\n```\n\n**制作镜像**\n\n```\ndocker build -t myimage:1.0 . -f /xxx/yyy/Dockerfile\n```\n\n### 容器\n\n**运行容器**\n\n```\ndocker run -d -p 80:80 --mount source=nginx,target=/usr/share/nginx/html nginx:latest\n```\n\n-   `-d` 后台运行\n-   `-p` 暴露端口\n-   `--mount` 挂载卷\n\n**停止运行容器**\n\n```\ndocker stop 5f79d10d97\n```\n\n`5f79d10d97` 表示容器运行的唯一标识。\n\n**列出正在运行的镜像**\n\n```\ndocker container ls\n```\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2042cabb48d44128e730d14cbff0fa9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**删除容器**\n\n```\ndocker container rm 5f79d10d97\n```\n\n### 卷\n\n**创建卷**\n\n```\ndocker volume create nginx\n```\n\n**列出所有卷**\n\n```\ndocker volume ls\n```\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fef64d544364869b4813ed3b5321b67~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**运行时绑定卷**\n\n方法1：指定卷名（需要先创建卷，如果没创建，docker会自动创建）\n\n```\ndocker run -d -p 80:80 --mount source=my-volume,target=/usr/share/nginx/html nginx:latest\n```\n\n方法2：自行指定目录（更灵活）\n\n```\ndocker run -d -p 80:80 --mount type=bind,src=d:/nginx,target=/usr/share/nginx/html nginx:latest\n```\n\n**删除指定卷**\n\n```\ndocker volumn rm nginx\n```\n\n### 网络\n\n**列出所有网络**\n\n```\ndocker network ls\n```', 'public/uploads/1694355658108.png', 3, 1, 1, 838, '2023-09-10 14:21:00', 1);
INSERT INTO `article` VALUES (53, 2, '我写了个提示颜色代码的VS Code插件——中国传统色', '记录一下我自学开发VS Code插件的过程。\n\n## 参考资料\n\n官方文档：[code.visualstudio.com/api](https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2Fapi \"https://code.visualstudio.com/api\")\n\n官方提供的各类插件示例：[github.com/microsoft/v…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fvscode-extension-samples \"https://github.com/microsoft/vscode-extension-samples\")\n\n## 需求\n\n我在写css时，经常会有颜色选择困难症，虽然VS Code内置的插件提供了取色器，但在256^3的颜色中去选取，未必能找到符合期望的颜色。于是我想要是有个颜色提示插件就好了，只要我输入`# + 颜色名`，就能以代码提示的方式，将对应的颜色列出来供我选择。\n\n我在VS Code插件市场搜了一圈，没找到类似的插件，最终决定自己写一个，本着学习的态度，我将学习过程记录下来。\n\n这是最终效果：\n![](http://127.0.0.1:3000/public/uploads/1694249905649.png)\n\n\n演示是使用拼音，直接用汉字也是可行的。\n\n在VS Code插件市场搜索Chinese Colors或者“中国色”即可找到我写的这个插件。\n\n仓库地址：[taiyuuki/chinese-colors](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftaiyuuki%2Fchinese-colors \"https://github.com/taiyuuki/chinese-colors\")\n\n## 获取颜色\n\n首先第一件事就是要有现成的颜色代码，很快我就找到了这个网站：[中国色](https://link.juejin.cn/?target=http%3A%2F%2Fzhongguose.com%2F)\n\n这个网站提供了500多种颜色的rgb值以及hex值，打开浏览器控制台，输入colorsArray就能全部拿到，这就是我想要的。\n\n![colors array.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acd040a651674a79af3747230af86cbb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 从网站底部的信息来看，这个网站是山寨自[日本色](https://link.juejin.cn/?target=http%3A%2F%2Fnipponcolors.com%2F \"http://nipponcolors.com/\")，颜色据称来自中科院科技情报编委会名词室编写、科学出版社1957年出版的《色谱》。\n> \n> 这个颜色来源是否可信我无从考证，随便百度一下“中国传统色”，就可以找到很多版本的所谓中国色，我在github上还找到了另一个接近2k star的中国色项目：[中国传统颜色手册](https://link.juejin.cn/?target=https%3A%2F%2Fcolors.ichuantong.cn%2F \"https://colors.ichuantong.cn/\")，这个网站使用的颜色与前者完全不同，是来自于一篇现在已经无法查看的新浪博客，颜色数量我没有统计，粗略估计在200以内。\n\n## 初始化项目\n\n安装开发工具\n\n```\n npm i -g yo generator-code\n```\n\n新建项目\n\n```\n yo code\n```\n\n各项配置如下：\n\n![003.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab5401d2848e49dcbc223d0bfd966766~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## Hello World\n\n初始项目中有个Hello World，用VS Code打开项目，然后按F5（或者点击“运行-->启动调试”）可以开启调试窗口。\n\n然后在调试窗口下 Ctrl + Shift + P （或者点击“设置-->命令面板”），输入并选择 Hello World 命令，就会在编辑器右下角弹出一个消息提示。\n\n`extension.ts`是插件的入口文件：\n\n```\n import * as vscode from \'vscode\';\n \n // activate方法会在插件被激活时调用\n export function activate(context: vscode.ExtensionContext) {\n     \n     // 注册命令，第一个参数是命令名称，第二参数是回调\n     let disposable = vscode.commands.registerCommand(\'chinese-colors.helloWorld\', () => {\n         // 弹出消息提示\n         vscode.window.showInformationMessage(\'Hello World from Chinese Colors!\');\n     });\n \n     // 添加到插件上下文\n     context.subscriptions.push(disposable);\n }\n \n // deactivate方法会在插件失活时调用\n export function deactivate() {}\n \n```\n\n## package.json\n\n查看`package.json`，其中比较重要的两项：\n\n```\n {\n     \"activationEvents\": [\n         \"onCommand:chinese-colors.helloWorld\"\n     ],\n     \"contributes\": {\n         \"commands\": [\n             {\n                 \"command\": \"chinese-colors.helloWorld\",\n                 \"title\": \"Hello World\"\n             }\n         ]\n     },\n }\n```\n\nactivationEvents是插件的激活配置，它是一个数组，每一项对应一个激活插件的条件，格式为“<类型>:<名称>”，onCommand是调用命令（也就是上面的输入Hello World）。\n\ncontributes：一般翻译为贡献点，配置了一个“chinese-colors.helloWorld”，与activationEvents配置项对应。\n\n其他packege.json配置见下表：\n\n| 名称 | 必要 | 类型 | 说明 |\n| --- | --- | --- | --- |\n| `name` | 是 | `string` | 插件名称，必须为小写且不能有空格。 |\n| `version` | 是 | `string` | 插件版本 |\n| `publisher` | 是 | `string` | 发布者 |\n| `engines` | 是 | `object` | 一个至少包含`vscode`键值对的对象，该键表示的是本插件可兼容的VS Code的版本，其值不能为`*`。比如 `^0.10.5` 表示插件兼容VS Code的最低版本是`0.10.5`。 |\n| `license` | 否 | `string` | 授权。如果有授权文档LICENSE.md，可以把`license`值设为`\"SEE LICENSE IN LICENSE.md\"`。 |\n| `displayName` | 否 | `string` | 插件市场中显示的名字。 |\n| `description` | 否 | `string` | 描述，说明本插件是什么以及做什么。 |\n| `categories` | 否 | `string[]` | 插件类型：`[Languages, Snippets, Linters, Themes, Debuggers, Other]` |\n| `keywords` | 否 | `array` | 一组 **关键字** 或者 **标记**，方便在插件市场中查找。 |\n| `galleryBanner` | 否 | `object` | 插件市场中横幅的样式。 |\n| `preview` | 否 | `boolean` | 在市场中把本插件标记为预览版本。 |\n| `main` | 否 | `string` | 插件的入口文件。 |\n| `contributes` | 否 | `object` | 一个描述插件 贡献点 的对象。 |\n| `activationEvents` | 否 | `array` | 一组用于本插件的激活事件。 |\n| `dependencies` | 否 | `object` | 生产环境Node.js依赖项。 |\n| `devDependencies` | 否 | `object` | 开发环境Node.js依赖项。 |\n| `extensionDependencies` | 否 | `array` | 一组本插件所需的其他插件的ID值。格式 `${publisher}.${name}`。比如：`vscode.csharp`。 |\n| `scripts` | 否 | `object` | 和 npm的 `scripts`一样，但还有一些额外VS Code特定字段。 |\n| `icon` | 否 | `string` | 一个128x128像素图标的路径。 |\n\n### 用户自定配置项\n\n颜色代码有多种表示方式，比较常用的是16进制(#ffffff)和rgb(255,255,255)这两种，因此我需要让用户自己选择采用哪种方式。\n\n在contributes中有个configuration，允许用户对插件进行一些自定义配置。\n\n`package.json`：\n\n```\n {\n     // ...\n     \"contributes\": {\n         \"configuration\": [{\n             \"title\": \"color mode\",// 配置项名称\n             \"properties\": {\n                 // 配置属性\n                 \"RGB\": {\n                     \"type\": \"boolean\",  // 属性值类型\n                     \"default\": false,   // 属性默认值\n                     \"description\": \"控制预设的中国色采用RGB格式\"    // 属性描述\n                 }\n             }\n         }]\n     },\n }\n```\n\n这样就可以在扩展设置中进行一些自定义的设置：\n\n![mode.jpg](https://raw.githubusercontent.com/Anjiu1/JueJin/main/app/src/assets/logo.png)\n\n我们可以通过workspace.getConfiguration()获取用户的配置。\n\n```\n import { workspace } from \"vscode\";\n const configuration = workspace.getConfiguration();\n const isRGB = configuration.RGB;\n```\n\n## 代码补全\n\n### API\n\n代码补全API：\n\n`vscode.languages.registerCompletionItemProvider(selector, provider, …triggerCharacters)`\n\n> 该api的文档：[code.visualstudio.com/api/referen…](https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2Fapi%2Freferences%2Fvscode-api%23languages.registerCompletionItemProvider \"https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider\")\n\n该方法有三个参数：\n\n| 参数 | Description |\n| --- | --- |\n| selector: string/string\\[\\] | 选择编程语言，比如`python` |\n| provider | 供应者配置对象 |\n| triggerCharacters: string/string\\[\\] | 触发字符， 比如 `.` 或 `:` |\n\n> register completion item provider（注册完成件供应者），这个provider也是比较费解的一个词，直译是供应者，我猜：代码补全就相当于插件给我们供应了代码，所以叫provider。\n\nprovider是一个对象，要求必须包含一个叫`provideCompletionItems`的方法，该方法需要返回一个数组，数组的每一项是一个[CompletionItem对象](https://juejin.cn/post/7150265989240717325#CompletionItem%E5%AF%B9%E8%B1%A1 \"#CompletionItem%E5%AF%B9%E8%B1%A1\")，规定了代码提示和补全的规则。\n\n### 官方示例\n\n> 完整示例：[github.com/microsoft/v…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fvscode-extension-samples%2Fblob%2Fmain%2Fcompletions-sample \"https://github.com/microsoft/vscode-extension-samples/blob/main/completions-sample\")\n\n```\n import * as vscode from \'vscode\';\n \n export function activate(context: vscode.ExtensionContext) {\n \n     // 注册供应者：languages.registerCompletionItemProvider\n     const provider2 = vscode.languages.registerCompletionItemProvider(\n         \'plaintext\',// plaintext，表示对txt文档激活该插件\n         {\n             // 实现provideCompletionItems方法\n             // document的内容见下文，position为当前光标的位置\n             provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n \n                 // 获取当前这行代码\n                 const linePrefix = document.lineAt(position).text.substr(0, position.character);\n                 // 如果这行代码不是以console.结尾，返回undefined，表示不会弹出代码提示\n                 if (!linePrefix.endsWith(\'console.\')) {\n                     return undefined;\n                 }\n \n                 // 返回CompletionItem对象组成的数组，补全代码列表：log、warn、error\n                 // CompletionItem对象可以自己创建，也可以像下面这样new vscode.CompletionItem的方式创建\n                 // vscode.CompletionItem()有两个参数： \n                 // 第一个是补全的代码，第二个是代码类型，用于控制显示在每一行提示前的图标\n                 // vscode.CompletionItemKind.Method表示该代码是一个方法\n                 return [\n                     new vscode.CompletionItem(\'log\', vscode.CompletionItemKind.Method),\n                     new vscode.CompletionItem(\'warn\', vscode.CompletionItemKind.Method),\n                     new vscode.CompletionItem(\'error\', vscode.CompletionItemKind.Method),\n                 ];\n             }\n         },\n         \'.\' // 以.作为触发\n     );\n \n     context.subscriptions.push(provider2);\n }\n```\n\n`provideCompletionItems`参数：\n\n`position`：当前光标所处的位置。\n\n`document`：用于获取、控制文档的内容或状态，这里列举几个常用的方法和属性：\n\n-   方法：\n    \n    -   **getWordRangeAtPosition(position): Range**：获取指定位置单词的范围（起始位置）\n    -   **getText(Range):string**：获取指定范围的文本\n    -   **lineAt(position):string**：获取指定位置的文本\n    -   **validatePosition(position):Position**：获取鼠标停留的位置\n-   属性\n    \n    -   **lineCount**：总代码行数\n    -   **languageId**：语言名称\n    -   **isClosed**：当前文件是否关闭\n    -   **isDirty**：当前文件的代码是否更改未保存\n\n### CompletionItem对象\n\nCompletionItem对象可以通过new vscode.CompletionItem()的方式创建，但它默认只能补全代码，不能自定义替换，并不能满足我的需求，因此需要自己创建。\n\nCompletionItem对象包含的属性：\n\n| 属性 | 说明 |\n| --- | --- |\n| detail: string | 语义化描述 |\n| documentation: string | 语义化描述 |\n| filterText: string | 代码过滤。匹配输入的内容，没有设置时，使用label |\n| insertText: string | 插入、补全的代码。没有设置时，使用label |\n| label: string | 默认的匹配代码、补全代码 |\n| kind | 代码类型，控制显示代码提示前的图标 |\n| sortText: string | 排序文本，与sortText匹配的提示代码会排在靠前的位置 |\n| textEdit | 对补全代码进行编辑，如果设置了textEdit，insertText会失效 |\n\n![completion.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fbc11ff0eba4b70932ebf0bf5a7e2f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nkind的取值：\n\n-   Class\n-   Color\n-   Constructor\n-   Enum\n-   Field\n-   File\n-   Function\n-   Interface\n-   Keyword\n-   Method\n-   Module\n-   Property\n-   Reference\n-   Snippet\n-   Text\n-   Unit\n-   Value\n-   Variable\n\n### 简单的示例\n\n```\n import * as vscode from \"vscode\";\n import { CompletionItemKind } from \"vscode\";\n \n export function activate(context: vscode.ExtensionContext) {\n   const cc = vscode.languages.registerCompletionItemProvider(\n     \"css\",\n     {\n       provideCompletionItems() {        \n         return [\n             {\n                 detail: \'#66ccff\',\n                 documentation: \'天依蓝\',\n                 kind: CompletionItemKind.Color,\n                 filterText: `#66ccff天依蓝`,\n                 label: \'天依蓝\',\n                 insertText: \'#66ccff\'\n             },\n             {\n                 detail: \'#39c5bb\',\n                 documentation: \'初音绿\',\n                 kind: CompletionItemKind.Color,\n                 filterText: `#39c5bb初音绿`,\n                 label: \'初音绿\',\n                 insertText: \'#39c5bb\'\n             }\n         ];\n       },\n     },\n     \"#\"\n   );\n   context.subscriptions.push(cc);\n }\n \n export function deactivate() {}\n```\n\n记得要在package.json里配置激活：\n\n```\n\"activationEvents\": [\n    \"onLanguage:css\"\n  ]\n```\n\n### 中国色插件\n\npackage.json关键配置：\n\n```\n {\n     \"activationEvents\": [\n         \"onLanguage:css\",\n         \"onLanguage:scss\",\n         \"onLanguage:sass\",\n         \"onLanguage:less\",\n         \"onLanguage:stylus\",\n         \"onLanguage:html\",\n         \"onLanguage:xml\",\n         \"onLanguage:json\",\n         \"onLanguage:javascript\",\n         \"onLanguage:typescript\",\n         \"onLanguage:javascriptreact\",\n         \"onLanguage:typescriptreact\",\n         \"onLanguage:vue\",\n         \"onLanguage:vue-html\"\n     ],\n     \"contributes\": {\n         \"configuration\": [{\n             \"title\": \"Chinese Colors\",\n             \"properties\": {\n                 \"RGB\": {\n                     \"type\": \"boolean\",\n                     \"default\": false,\n                     \"description\": \"控制预设的中国色采用RGB格式\"\n                 }\n             }\n         }]\n     },\n }\n```\n\n颜色列表`colors.ts`：\n\n```\n // 声明Color类型\n export type Color = {\n   rgb: number[];\n   hex: string;\n   name: string;\n   phonics: string;\n };\n \n // 这里只列两个颜色\n export const colors: Color[] = [\n   {\n     rgb: [92, 34, 35],\n     hex: \"#5c2223\",\n     name: \"暗玉紫\",\n     phonics: \"anyuzi\",\n   },\n   {\n     rgb: [238, 162, 164],\n     hex: \"#eea2a4\",\n     name: \"牡丹粉红\",\n     phonics: \"mudanfenhong\",\n   },\n   // ...\n ]\n```\n\n`extensions.ts`\n\n```\n import * as vscode from \"vscode\";\n import { workspace, CompletionItemKind } from \"vscode\";\n import { colors, Color } from \"./colors\";\n \n const isRgb = workspace.getConfiguration().RGB;\n \n export function activate(context: vscode.ExtensionContext) {\n   const cc = vscode.languages.registerCompletionItemProvider(\n     [\n       \"css\",\n       \"scss\",\n       \"sass\",\n       \"less\",\n       \"stylus\",\n       \"html\",\n       \"xml\",\n       \"json\",\n       \"javascript\",\n       \"typescript\",\n       \"javascriptreact\",\n       \"typescriptreact\",\n       \"vue\",\n       \"vue-html\",\n     ],// activationEvents\n     {\n       provideCompletionItems() {\n         const list = [] as CompletionItemKind[];\n \n         colors.forEach((color: Color) => {\n           list.push({\n             detail: isRgb ? rgb : hex,\n             documentation: color.name,\n             kind: CompletionItemKind.Color,\n             filterText: \"#\" + color.name + color.phonics,\n             label: color.name,\n             insertText: isRgb ? rgb : hex,\n           });\n         });\n         return list;\n       },\n     },\n     \"#\"\n   );\n   context.subscriptions.push(cc);\n }\n \n export function deactivate() {}\n```\n\n如此，代码补全的功能已经基本实现，实际开发时，为了便于维护，需要将这部分逻辑抽离出来。\n\n## 颜色预览\n\n接下来，需要实现颜色的预览，虽然VS Code内置的插件已经实现了这项功能，但我的需求是：不仅能预览颜色，还得显示颜色名称。\n\n![preview_name.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd089e704c14ccd82edaf89397b5523~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### API\n\n实现颜色预览需要用到装饰效果，涉及以下这些API：\n\n`window.createTextEditorDecorationType(options)`：创建装饰效果的类型\n\n`window.activeTextEditor.setDecorations(decorationType, decorations)`：添加装饰效果至文档\n\n`window.onDidChangeActiveTextEditor`：文档内容变化事件\n\n`workspace.onDidChangeTextDocument`：切换文档事件\n\n### 官方示例\n\n首先来看一下官方提供的示例片段\n\n> 完整实例： [github.com/microsoft/v…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fvscode-extension-samples%2Ftree%2Fmain%2Fdecorator-sample \"https://github.com/microsoft/vscode-extension-samples/tree/main/decorator-sample\")\n\n```\nimport * as vscode from \'vscode\';\n\n// 插件激活时调用\nexport function activate(context: vscode.ExtensionContext) {\n\nconsole.log(\'decorator sample is activated\');\n\nlet timeout: NodeJS.Timer | undefined = undefined;\n\n        // 为small numbers创建装饰效果类型\nconst smallNumberDecorationType = vscode.window.createTextEditorDecorationType({\n                // 以下是装饰效果的样式\nborderWidth: \'1px\',\nborderStyle: \'solid\',\noverviewRulerColor: \'blue\',\noverviewRulerLane: vscode.OverviewRulerLane.Right,\nlight: {\n// 亮色主题下的边框颜色\nborderColor: \'darkblue\'\n},\ndark: {\n// 暗色主题下的边框颜色\nborderColor: \'lightblue\'\n}\n});\n\n// 为large numbers创建装饰效果类型\nconst largeNumberDecorationType = vscode.window.createTextEditorDecorationType({\ncursor: \'crosshair\',\n// 设置装饰的背景颜色, 在package.json中可以配置该名称对应的颜色\nbackgroundColor: { id: \'myextension.largeNumberBackground\' }\n});\n\n        // activeEditor是当前活跃（展示）的文档编辑器实例\nlet activeEditor = vscode.window.activeTextEditor;\n\n        // updateDecorations方法，用于更新。\nfunction updateDecorations() {\nif (!activeEditor) {\nreturn;\n}\n                // 匹配数字的正则\nconst regEx = /\\d+/g;\n                // 获取文档的文本\nconst text = activeEditor.document.getText();\n                // 装饰效果数组，用于归集每一个Decoration对象\nconst smallNumbers: vscode.DecorationOptions[] = [];\nconst largeNumbers: vscode.DecorationOptions[] = [];\nlet match;\nwhile ((match = regEx.exec(text))) {\n                        // 获取匹配结果的起始位置\nconst startPos = activeEditor.document.positionAt(match.index);// 开始位置\nconst endPos = activeEditor.document.positionAt(match.index + match[0].length);// 结束位置\n                        // Decoration对象\nconst decoration = {\n                            // 装饰效果的位置\n                            range: new vscode.Range(startPos, endPos), \n                            // 鼠标悬停（hover）的提示信息\n                            hoverMessage: \'Number **\' + match[0] + \'**\' \n                        };\n                        // 将符合的结果归集\nif (match[0].length < 3) {\nsmallNumbers.push(decoration);\n} else {\nlargeNumbers.push(decoration);\n}\n}\n                // 添加装饰效果\nactiveEditor.setDecorations(smallNumberDecorationType, smallNumbers);\nactiveEditor.setDecorations(largeNumberDecorationType, largeNumbers);\n}\n\n        // 给方法节流\nfunction triggerUpdateDecorations(throttle = false) {\nif (timeout) {\nclearTimeout(timeout);\ntimeout = undefined;\n}\nif (throttle) {\ntimeout = setTimeout(updateDecorations, 500);\n} else {\nupdateDecorations();\n}\n}\n\n        // 打开文档时调用一次\nif (activeEditor) {\ntriggerUpdateDecorations();\n}\n    \n// 切换文档时调用\nvscode.window.onDidChangeActiveTextEditor(editor => {\n                // 这一步赋值是必须的，确保activeEditor是当前打开的文档编辑器实例\nactiveEditor = editor;\nif (editor) {\ntriggerUpdateDecorations();\n}\n}, null, context.subscriptions);\n\n        // 文档内容发送改变时调用\nvscode.workspace.onDidChangeTextDocument(event => {\nif (activeEditor && event.document === activeEditor.document) {\ntriggerUpdateDecorations(true);\n}\n}, null, context.subscriptions);\n\n}\n```\n\n效果如下：\n\n![decpreview.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f536a595fe904417855effd89f8be5cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### DecorationType\n\nDecorationType是通过window.createTextEditorDecorationType(options)创建的对象，它主要用来设置装饰效果的样式，其实就是css样式，比如border、color、backgroundColor等等。\n\n如果要在匹配结果之前或之后添加装饰，可以添加before/after字段进行设置，还可以分别给dark、light模式配置不同的样式。\n\n```\nconst decorationType =  window.createTextEditorDecorationType({\n    // 在匹配位置之前添加装饰效果：\n    before: {\n        color: \'#eee\',\n        backgroundColor: \'#fff\',\n        width: \'fit-content\'\n    }\n})\n```\n\n由于该方法支持的样式字段有限，有些样式（比如line-height）无法在options里直接添加，但我们可以在任意字段后添加分号，将这些样式写在后面，比如：\n\n```\nconst decorationType =  window.createTextEditorDecorationType({\n    // 在匹配位置之后添加装饰效果：\n    after: {\n        color: \'#333\',\n        backgroundColor: \'#fff\',\n        width: \'fit-content\',\n        height: \'0.8em\',\n        // fontSize: \'0.6em\', 这么设置是无效的，因为并不支持fontSize字段，\n        // 但我们可以将其添加在任意字段后面\n        fontStyle: \'normal;font-size:0.6em;line-height:0.8em\'\n    }\n})\n```\n\n具体支持哪些字段，可以查看此API的官方文档：\n\n[VS Code API | Visual Studio Code Extension API](https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2Fapi%2Freferences%2Fvscode-api%23DecorationRenderOptions \"https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions\")\n\n### Decoration对象\n\nDecoration对象有三个属性：\n\n-   `range`：装饰效果的位置，range对象可以通过new vscode.Range(start, end)创建\n    \n-   `hoverMessage`：鼠标悬停时的提示信息\n    \n-   `renderOptions`：和decorationType类似，可以单独对每一个装饰效果设置样式。但只支持before、after、dark、light四个字段，也就是说，无法再对匹配的内容本身设置样式。\n    \n\n### 示例\n\n由于实现的代码比较长，和上述官方示例其实差不多，这里就不再贴出来了，感兴趣的可以去文章开头的仓库地址查看。\n\n值得一提的是，为了颜色的名称在不同的颜色背景下都能清晰的显现，我这里用到了一个计算对比色的方法，贴出来供参考：\n\n```\n// 通过hex值计算应该使用的字体颜色\nfunction getContrastColor(hexcolor: string) {\n  const r = parseInt(hexcolor.substring(1, 2), 16)\n  const g = parseInt(hexcolor.substring(3, 4), 16)\n  const b = parseInt(hexcolor.substring(5, 6), 16)\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000\n  return yiq >= 8 ? \'black\' : \'white\'\n}\n```\n\n## 插件打包\n\n打包命令：\n\n```\nvsce package\n```\n\n如果打包失败，可能的原因：\n\n-   packege.json缺少上文表格中必要的配置项\n-   VS Code版本与packege.json里设置的版本不兼容\n-   根目录下缺少README.md文件\n-   根目录下缺少LICENSE.md文件', '', 3, 6, 2, 566, '2023-09-09 09:00:43', 1);
INSERT INTO `article` VALUES (54, 5, 'Mrs.', 'All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration.', '', 2, 3, 0, 235, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (55, 4, '摸鱼神器：打造一款让VS Code成为你私人影院的插件', '## 介绍\n\n编程是一项令人兴奋的工作，然而每天都在代码编写中度过很长时间后，我们也希望能够进行一些娱乐活动来放松身心，例如看电影。那么今天，我想要介绍的是一款能够将VS Code变成你的私人影院的插件！这个插件将可以让你在VS Code的代码编辑区中轻松观看电影，不再需要切换电影应用或浏览器。本篇文章将会给你展示如何在VS Code中开发这款插件，采用的技术包括Node.js、axios、JSdom和VS Code的webview等。\n\n## 准备工作及开发环境搭建\n\n首先，你需要在电脑上安装最新的VS Code和Node.js版本。然后，在VS Code中打开命令行终端，创建一个新的文件夹，用来存储插件代码：\n\n```\nmkdir my-video-plugin\ncd my-video-plugin\ncode .\n```\n\n## 爬取腾讯视频数据：如何使用axios和jsdom发送请求并解析HTML\n\n我们需要爬取腾讯视频的数据来获取电影列表。我们将使用axios和jsdom插件实现该功能。首先，我们需要安装这些插件：\n\n```\nnpm install axios jsdom\n```\n\n接下来，在你的代码中引入它们：\n\n```\nconst axios = require(\'axios\');\nconst jsdom = require(\'jsdom\');\nconst { JSDOM } = jsdom;\n```\n\n使用axios发送一个GET请求，然后使用jsdom解析HTML文档。以下是解析腾讯视频网站上视频标题的示例代码：\n\n```\naxios.get(\'https://v.qq.com/\')\n  .then((response) => {\n    const dom = new JSDOM(response.data);\n    const document = dom.window.document;\n\n    // 从腾讯视频提取视频标题\n    // 注意：class类名可能会被调整修改，掘友们在自己手动做的时候记得自己检查网页源码\n    const videoTitles = document.querySelectorAll(\'.item_title .needsclick\');\n\n    videoTitles.forEach((title) => {\n      console.log(title.textContent);\n    });\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n```\n\n具体的视频链接提取与标题提取原理是一样的，因此这里不多做赘述，免的被掘友们说我水文。\n\n## 可视化搜索：如何在VS Code中为插件提供搜索界面\n\n我们需要让用户能够搜索他们想要看的电影。我们将添加一个搜索框，用户可以在其中输入搜索关键字。当用户按下回车键时，我们将搜索该关键字并显示结果。\n\n在VS Code中使用webview来实现可视化搜索框，我们需要首先创建一个HTML文件并添加一个搜索框和一个结果列表。接下来，我们需要将其加载到webview中。\n\n以下是加载HTML文件到webview的示例代码：\n\n```\nconst panel = vscode.window.createWebviewPanel(\n  \'myVideoPlugin\',\n  \'My Video Plugin\',\n  vscode.ViewColumn.One,\n  {}\n);\n\npanel.webview.html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>My Video Plugin</title>\n</head>\n<body>\n  <input type=\"text\" id=\"search-box\">\n  <ul id=\"results\"></ul>\n</body>\n</html>`;\n```\n\n我们还需要指定webview将在哪些情况下显示和隐藏。以下是在搜索命令被触发时显示webview的示例代码：\n\n```\nconst disposable = vscode.commands.registerCommand(\'myVideoPlugin.search\', () => {\n  panel.reveal();\n});\n```\n\n## 可视化账号配置：如何让用户方便地在VS Code中配置腾讯视频账号\n\n我们将添加一个配置页面，让用户可以配置他们的腾讯视频账号。我们将使用VS Code提供的配置API。在你的代码中添加以下代码来设置一个配置项：\n\n```\nconst configuration = vscode.workspace.getConfiguration(\'myVideoPlugin\');\nconst defaultValue = \'\';\nconst username = configuration.get(\'username\', defaultValue);\nconst password = configuration.get(\'password\', defaultValue);\n```\n\n我们需要为配置页面在webview中创建一个表单，让用户可以输入他们的用户名和密码。以下是创建表单的示例代码：\n\n```\npanel.webview.html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>My Video Plugin</title>\n</head>\n<body>\n  <h1>Configuration</h1>\n  <form>\n    <label for=\"username\">Username:</label>\n    <input type=\"text\" id=\"username\" name=\"username\" value=\"${username}\">\n    <br>\n    <label for=\"password\">Password:</label>\n    <input type=\"password\" id=\"password\" name=\"password\" value=\"${password}\">\n    <br>\n    <button type=\"submit\">Save</button>\n  </form>\n</body>\n</html>`;\n```\n\n我们可以在表单提交时保存用户的配置信息。以下是保存配置信息的示例代码：\n\n```\npanel.webview.onDidReceiveMessage((message) => {\n  switch (message.command) {\n    case \'saveConfig\':\n      configuration.update(\'username\', message.username, true);\n      configuration.update(\'password\', message.password, true);\n      break;\n  }\n});\n```\n\n## 视频播放：如何在VS Code中使用webview播放腾讯视频\n\n我们将为每个视频创建一个webview以播放视频。当用户将鼠标悬停在视频标题上时，我们将显示一个播放按钮。当用户点击该按钮时，我们将创建一个新的webview来播放视频。\n\n以下是创建视频播放窗口并加载视频的示例代码：\n\n```\nvscode.window.createWebviewPanel(\n  \'myVideoPluginPlayback\',\n  title,\n  vscode.ViewColumn.Active,\n  {\n    enableScripts: true,\n    retainContextWhenHidden: true,\n  }\n)\n.webview.html = `\n  <!DOCTYPE html>\n  <html>\n    <head>\n      <meta charset=\"UTF-8\">\n      <style>\n        body {\n          margin: 0;\n          background-color: black;\n        }\n      </style>\n    </head>\n    <body>\n      <video controls autoplay muted>\n        <source src=\"${videoUrl}\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n      </video>\n    </body>\n  </html>\n`;\n```\n\n我们需要在搜索结果中为每个视频创建一个播放按钮。以下是为每个视频添加播放按钮的示例代码：\n\n```\nvideoTitles.forEach((title) => {\n      const listItem = document.createElement(\'li\');\n      const button = document.createElement(\'button\');\n      button.textContent = \'Play\';\n      button.onclick = () => {\n        playVideo(title.textContent);\n      };\n      listItem.appendChild(title);\n      listItem.appendChild(button);\n      resultList.appendChild(listItem);\n});\n```\n\n## 打包和发布：将插件打包并发布到VS Code Marketplace\n\n最后，我们需要将插件打包并发布到VS Code Marketplace。我们可以使用VS Code的命令行接口来完成这项任务。首先，我们需要在你的插件项目的根目录中创建一个package.json文件：\n\n```\n{\n  \"name\": \"my-video-plugin\",\n  \"displayName\": \"My Video Plugin\",\n  \"description\": \"A plugin to turn VS Code into your personal movie theater.\",\n  \"version\": \"0.0.1\",\n  \"publisher\": \"your-publisher-name\",\n  \"engines\": {\n    \"vscode\": \"^1.60.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onCommand:myVideoPlugin.search\",\n    \"onCommand:myVideoPlugin.config\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"myVideoPlugin.search\",\n        \"title\": \"Search videos\"\n      },\n      {\n        \"command\": \"myVideoPlugin.config\",\n        \"title\": \"Configure My Video Plugin\"\n      }\n    ],\n    \"configuration\": {\n      \"type\": \"object\",\n      \"title\": \"My Video Plugin\",\n      \"properties\": {\n        \"username\": {\n          \"type\": \"string\",\n          \"default\": \"\"\n        },\n        \"password\": {\n          \"type\": \"string\",\n          \"default\": \"\"\n        }\n      }\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p .\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^16.7.13\",\n    \"@types/vscode\": \"^1.60.0\",\n    \"typescript\": \"^4.4.4\",\n    \"vsce\": \"^1.123.1\"\n  }\n}\n```\n\n接下来，我们需要在终端中运行以下命令来打包插件并发布到VS Code Marketplace：\n\n```\nvsce package\nvsce publish\n```\n\n## 总结：回顾插件实现过程\n\n通过这篇文章，我们学习了如何开发一个让VS Code成为你私人影院的插件。我们使用了Node.js、axios、JSdom以及VS Code的webview等技术实现了爬取电影列表，可视化搜索，可视化账号配置以及视频播放等多种功能。最后，我们还学习了如何打包并发布插件到VS Code Marketplace。\n\n最终的成果将是一个与其他VS Code插件一样易于使用的插件，使得看电影成为了愉悦的工作体验的一部分。皆大欢喜！\n\n**注意**：本文代码并非完整代码，只是给大家讲解一下开发一个插件的具体步骤以及实现的核心方法和思路，若有需要，可以在评论区留言，如果人数较多的话，我会出一版完整的开源VS code视频播放插件代码，扩展其他功能，供大家开箱即用，让大家打工路上快乐摸鱼。', 'public/uploads/1694330454342.png', 2, 1, 0, 185, '2023-09-10 07:20:55', 1);
INSERT INTO `article` VALUES (56, 3, '面试官您好，这是我写的TodoList ', '前段时间看到掘金上有人二面被面试官要求写一个TodoList，今天趁着上班没啥事情，我也来写一个小Demo玩玩。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6355a132a80340d9b4c22a649540532a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n## 功能\r\n\r\n一个TodoList大致就是长成这个样子，有一个输入框，可以通过输入任务名称进行新增，每个任务可以进行勾选，切换已完成和未完成状态，还可以删除。\r\n\r\n## 组件设计\r\n\r\n## 组件拆分\r\n\r\n接下来，我们可以从功能层次上来拆分组件\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d65fac35fae4d2f9458f50a006eb0d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n1.  最外层容器组件，只做一个统一的汇总(红色)\r\n2.  新增组件，管理任务的输入(绿色)\r\n3.  列表组件，管理任务的展示(紫色)，同时我们也可以将每一个item拆分成为单独的组件(粉色)\r\n\r\n## 数据流\r\n\r\n组件拆分完毕之后，我们来管理一下数据流向，我们的数据应该存放在哪里？\r\n\r\n我们的数据可以放在新增组件里面吗？不可以，我们的数据是要传递到列表组件进行展示的，他们两个是兄弟组件，管理起来非常不方便。同理，数据也不能放在列表组件里面。所以我们把数据放在我们的顶级组件里面去管理。\r\n\r\n我们在最外层容器组件中把数据定义好，并写好删除，新增的逻辑，然后将数据交给列表组件进行展示，列表组件只管数据的展示，不管具体的实现逻辑，我只要把列表id抛出来，调用你传递的删除函数就可以了\r\n\r\n现在，我们引出组件设计时的一些原则\r\n\r\n1.  从功能层次上拆分一些组件\r\n2.  尽量让组件原子化，一个组件只做一个功能就可以了，可以让组件吸收复杂度。每个组件都实现一部分功能，那么整个大复杂度的项目自然就被吸收了\r\n3.  区分容器组件和UI组件。容器组件来管理数据，具体的业务逻辑；UI组件就只管显示视图\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eaba68ae6cb40da83c2bc09b09173d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\r\n\r\n## 数据结构的设计\r\n\r\n一个合理的数据结构应该满足以下几点：\r\n\r\n1.  用数据描述所有的内容\r\n2.  数据要结构化，易于操作遍历和查找\r\n3.  数据要易于扩展，方便增加功能\r\n\r\n```\r\n[\r\n    {\r\n        id:\"1\",\r\n        title:\'标题一\',\r\n        completed:false\r\n    },\r\n    {\r\n        id:\"2\",\r\n        title:\'标题二\',\r\n        completed:false\r\n    }\r\n]\r\n```\r\n\r\n## coding\r\n\r\n[codesandbox.io/s/todolist-…](https://link.juejin.cn/?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Ftodolist-tfmzkv \"https://codesandbox.io/s/todolist-tfmzkv\")\r\n\r\n## 反思\r\n\r\n看了下Antd表单组件的设计，它将一个Form拆分出了Form和Form.item\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf777bac5e6a4cf9b17028ef09a0d234~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e75956a21de24f85a21e375e1c8f70be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\r\n\r\n为什么要这么拆分呢？\r\n\r\n上文说到，我们在设计一个组件的时候，需要从功能上拆分层次，尽量让组件原子化，只干一件事情。还可以让容器组件（只管理数据）和渲染组件（只管理视图）进行分离\r\n\r\n通过Form表单的Api，我们可以发现，Form组件可以控制宏观上的布局，整个表单的样式和数据收集。Form.item控制每个字段的校验等。\r\n\r\n个人拙见，如有不妥，还请指教！！！', '', 3, 3, 0, 552, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (57, 6, 'Mr.', 'If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. It wasn’t raining when Noah built the ark. The reason why a great man is great is that he resolves to be a great man. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. I will greet this day with love in my heart. The reason why a great man is great is that he resolves to be a great man. Optimism is the one quality more associated with success and happiness than any other. A comfort zone is a beautiful place, but nothing ever grows there. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored.', '', 1, 6, 0, 527, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (58, 3, '基于vue3+threejs实现可视化大屏', '前言\r\nThree.js是一款基于原生WebGL封装通用Web 3D引擎，在小游戏、产品展示、物联网、数字孪生、智慧城市园区、机械、建筑、全景看房、GIS等各个领域基本上都有three.js的身影。\r\n\r\n本文需要对 threejs 的一些基本概念和 api 有一定了解。\r\n\r\n如果对 threejs 这部分还不了解的可以看下官方文档和一些中文文档进行学习。\r\n\r\n官方文档地址：threejs.org/\r\n\r\n中文文档地址：www.webgl3d.cn/pages/aac9a…\r\n\r\n本文主要主要讲述对 threejs 的一些 api 进行基本的封装，在 vue3 项目中来实现一个可视化的3d项目。包含了一些常用的功能，场景、灯光、摄像机初始化，模型、天空盒的加载，以及鼠标点击和悬浮的事件交互。\r\n\r\n项目截图：', '', 1, 2, 0, 924, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (59, 1, '又整新活，新版 IntelliJ IDEA 有点东西！', '作为一个经常使用IntelliJ IDEA来写代码的老用户，每次对于JetBrains软件的更新都是非常关注的。\n\n这不最近这段时间，JetBrains连发了多个软件的EAP版本：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b5f65d8828472db262dd14324c99e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n同时JetBrains的官博中也宣布了一个重要的新特性，那就是：\n\n在所有JetBrains IDEs和.NET Tools中都将集成一个名为【AI Assistant】的AI助手。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd0a48baa8e4124846a120fa83c89d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n也就是说，不管是像IDEA、Clion、PyCharm这类JetBrains IDE：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45a87c46e8a4993837a3ac182e13f29~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n还是像ReSharper、Rider、dotPeek等这类.NET工具：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5fd1ff7466e417cb0c2010c0f628167~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n都将会集成【AI Assistant】这个新特性。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9375970fd4aa4fe991a01c25c603de1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n众所周知，最近这段时间以来，生成式AI和大语言模型正在迅速改变软件开发工具的格局，所以JetBrains也表示会理所当然地把这些AI功能集成并融入到自己的产品中。\n\n据官方介绍，这些AI功能将由JetBrains AI服务模块提供支持。\n\n该服务对用户透明，可以将用户连接到不同的大语言模型，并在JetBrains的软件产品中来启用特定的AI功能。同时该服务还支持OpenAI包括托管JetBrains所创建的诸多较小模型。\n\n未来JetBrains也计划与更多AI模型供应商合作，让用户能够根据需要来获得最佳的选项和模型，此外官方也计划在未来支持本地（包括可本地部署）模型，以扩大使用场景和功能。\n\n所以接下来我们就结合官方给出的示例来看看这次新特性所带来的一些变化。\n\n## AI对话\n\n用户可以直接使用AI Assistant工具窗口来进行大模型对话，比如可以直接提问题或者基于当前任务的一些问答对话。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b36f7e3d79cb4d86a9f213d0f335ba0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n这时候IDE就会给出一些基于该项目上下文的结果，如果用户接受，则可以直接将基于AI生成的代码插入到当前内容之中，非常方便。\n\n## 代码理解\n\n除了可以生成内容，这次新加的AI Assistant还支持代码理解和内容建议。\n\n用户可以直接在当前IDE中选中特定代码，然后通过呼出【AI Actions】菜单来调用相关的AI辅助功能，典型的比如：\n\n-   代码段理解\n-   代码重构建议\n-   潜在问题发现\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/263af7728d8848a8bb5b5cad7d4a4168~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n不得不说，这一点对于平时写代码或者阅读代码过程中的效率提升，还是非常有帮助的。\n\n## 文档生成\n\n新加入的AI助手同样支持文档或代码注释的自动生成，不过目前是支持Java, Kotlin和Python代码。\n\n以Java和Kotlin代码为例，可以直接使用标准方式`/**`即可触发代码注释文档的自动生成。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/939a1f0f7e0b4d3ba8a43c9c293149fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 命名建议\n\n当用户需要重命名Java，Kotlin或者Python等代码中的某些变量、函数或者声明时，这个AI助手会根据上下文内容来给出一些对应的内容建议。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16466c3270784b839e5a3856d4d3bb98~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## Commit信息生成\n\n新版本的【代码信息提交】窗口现在也多了一个【Generate Commit Message with AI Assistant】按钮。\n\n单击该功能之后，AI Assistant助手将根据代码更改的内容差异来自动生成Commit信息，可以说非常方便了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9958287f98349da8cdc754f151a4472~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 后记\n\n总而言之，从新版本给出的一些功能特性和示例来看，感觉还是挺不错的。\n\n虽然有些第三方插件也支持类似功能了，可这次毕竟是官方推出的新特性，相信无论在功能性、稳定性以及用户体验等方面应该都会有一个不错的完成度的。\n\n不过JetBrains官方表示，目前这个JetBrains AI服务并不会立即对所有用户开放，而是会先邀请一定数量的用户进行试用，后续才会逐渐铺开。\n\n那对于JetBrains此次推出的这个新特性，大家觉得怎么样，期待吗？\n\n> 注：本文在GitHub开源仓库「编程之路」 [github.com/rd2coding/R…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frd2coding%2FRoad2Coding \"https://github.com/rd2coding/Road2Coding\") 中已经收录，里面有我整理的6大编程方向(岗位)的自学路线+知识点大梳理、面试考点、我的简历、几本硬核pdf笔记，以及程序员生活和感悟，欢迎star。', 'public/uploads/1694355835284.png', 3, 5, 0, 649, '2023-09-10 14:23:56', 1);
INSERT INTO `article` VALUES (60, 2, '11Miss.', '11The reason why a great man is great is that he resolves to be a great man. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. Remember that failure is an event, not a person. To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. You must be the change you wish to see in the world. It wasn’t raining when Noah built the ark. A man is not old until regrets take the place of dreams. Secure SHell (SSH) is a program to log in into another computer over a network, execute commands on a remote server, and move files from one machine to another. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview.', '', 1, 4, 1, 452, '2023-10-17 15:29:23', 0);
INSERT INTO `article` VALUES (61, 1, 'vscode+vite+ts助你高效开发uni-app项目', '## 前言\n\n最近在基于`uni-app`开发小程序，由于公司使用的是 `HBuilder`创建的项目，每次都需要打开HBuilderX当运行工具，开发体验真是难受至极。打算使用`vscode + vite + ts`创建一套模版，脱离 `HBuilder`\n\n**为什么不喜欢`HBuilderX`呢？**\n\n1.  超级难用的`git管理`和`全局搜索`，谁用谁知道\n2.  界面风格，代码样式，格式化，插件生态相比`vscode`都太差了\n3.  习惯了`vscode`开发\n\n![Snipaste_2023-09-05_21-53-02.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2990770dbc949908dd80cd318505014~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1720&h=1512&s=275574&e=png&b=ffffff)\n\n> **[点击查看 npm](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40xkfe%2Funi-vscode-template \"https://www.npmjs.com/package/@xkfe/uni-vscode-template\")**\n> \n> **[点击查看 github](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxkfe%2Funi-vscode-template \"https://github.com/xkfe/uni-vscode-template\")**\n\n## cli创建uni-app 项目\n\n**1、 创建 Vue3/Vite 工程**\n\n```\n# npx degit https://github.com/dcloudio/uni-preset-vue.git#分支名称 自定义项目名称\n\n# 创建以 javascript 开发的工程  \nnpx degit dcloudio/uni-preset-vue#vite my-vue3-project  \n\n# 创建以 typescript 开发的工程  \nnpx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project  \n```\n\n> -   `degit` 可以帮助你从任意 git 仓库中克隆纯净的项目，忽略整个仓库的 git 历史记录。\n> -   可以使用 `npm install -g degit` 命令全局安装\n\n**2、进入工程目录**\n\n```\ncd my-vue3-project\n```\n\n**3、安装依赖**\n\n```\npnpm i 或 yarn\n```\n\n**4、运行**\n\n```\n# 运行到 h5   \nnpm run dev:h5  \n# 运行到 app   \nnpm run dev:app  \n# 运行到 微信小程序  \nnpm run dev:mp-weixin  \n```\n\n**5、打包**\n\n```\n# 打包到 h5   \nnpm run build:h5  \n# 打包到 app   \nnpm run build:app  \n# 打包到 微信小程序  \nnpm run build:mp-weixin  \n```\n\n[`dcloudio` 官方更多模版地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdcloudio%2Funi-preset-vue \"https://github.com/dcloudio/uni-preset-vue\")\n\n## 自动引入\n\n> 使用了自动引入就无需写下面的 import {xx} from @dcloudio/uni-app/vue。\n> \n> **如果不喜欢此方式可忽略**\n\n每个页面使用vue api或者uniapp api都需要引入，个人感觉有些麻烦\n\n```\nimport { shallowRef,computed,watch } from \'vue\';\nimport { onLoad,onShow } from \"@dcloudio/uni-app\";\n```\n\n**1、 下载自动引入插件 `pnpm add unplugin-auto-import -D`**\n\n**2、`vite.config.ts` 配置如下:**\n\n```\nimport { defineConfig } from \"vite\";\nimport uni from \"@dcloudio/vite-plugin-uni\";\n// 引入自动导入插件\nimport AutoImport from \'unplugin-auto-import/vite\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    uni(),\n    // 配置自动导入 vue相关函数, uni-app相关函数。ref, reactive，onLoad等\n    AutoImport({\n      imports: [\'vue\',\'uni-app\'],\n      dts: \'./typings/auto-imports.d.ts\',\n    }),\n  ],\n});\n```\n\n**3、`tsconfig.json include`新增如下类型文件配置**\n\n```\n\"include\": [\n    \"src/**/*.ts\", \n    \"src/**/*.d.ts\", \n    \"src/**/*.tsx\", \n    \"src/**/*.vue\",\n    // unplugin-auto-import/vite自动引入的类型声明文件\n    \"typings/**/*.d.ts\",\n    \"typings/**/*.ts\"\n]\n```\n\n> **注意：** `Option \'importsNotUsedAsValues\' is deprecated and will stop functioning in TypeScript 5.5. Specify compilerOption \'\"ignoreDeprecations\": \"5.0\"\' to silence this error. Use \'verbatimModuleSyntax\' instead`\n> \n> 翻译一下: 选项“importsNotUsedAsValues”已弃用，并将停止在TypeScript 5.5中运行。指定compilerOption“”ignoreDeprecations“：”5.0“”以消除此错误。 请改用“verbatimModuleSyntax”。\n> \n> **如果出现此警告⚠️可添加如下配置**\n\n![Snipaste_2023-08-22_23-20-42.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bca0b67835ee49ae9befcc5c4101b05c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## eslint自动格式化\n\n> 为了使用方便，这里直接使用 **antfu**大佬的插件了，有需要的配置自行再添加到`rules`里面。\n> \n> **注意：** 这个插件可能更适合web端，antfu基本是不写小程序的，如果有特殊需要或者想更适合小程序版本格式化可以自行配置或者网上找一些格式化方案，这类文章还是比较多的。\n\n使用 `eslint` + `@antfu/eslint-config`[点击查看使用](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantfu%2Feslint-config \"https://github.com/antfu/eslint-config\")\n\n**1、 安装插件**\n\n```\npnpm add -D eslint @antfu/eslint-config\n```\n\n**2、新建`.eslintrc.cjs`**\n\n```\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    node: true,\n    es6: true,\n  },\n  // https://github.com/antfu/eslint-config\n  extends: \'@antfu\',\n  rules: {\n    // your custom rules...\n    \'vue/html-self-closing\': [\'error\', {\n      html: { normal: \'never\', void: \'always\' },\n    }],\n    \'no-console\': \'off\', // 禁用对 console 的报错检查\n    // \"@typescript-eslint/quotes\": [\"error\", \"double\"], // 强制使用双引号\n    \'@typescript-eslint/semi\': [\'error\', \'always\'], // 强制使用行位分号\n  },\n};\n\n```\n\n**3、新建`.vscode/settings.json`**\n\n```\n{\n  // 禁用 prettier，使用 eslint 的代码格式化\n  \"prettier.enable\": false,\n  // 保存时自动格式化\n  \"editor.formatOnSave\": false,\n  // 保存时自动修复\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true,\n    \"source.organizeImports\": false\n  },\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    \"typescript\",\n    \"typescriptreact\",\n    \"vue\",\n    \"html\",\n    \"markdown\",\n    \"json\",\n    \"jsonc\",\n    \"yaml\"\n  ]\n}\n```\n\n**4、此时打开`App.vue` 查看已经检查出规范了，只要保存就会自动格式化**\n\n![eslint-format.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4ce7cb8136c46ba8cca72d3a0113d32~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n**5、提交代码时自动对暂存区代码进行格式化操作**\n\n```\npnpm add -D lint-staged simple-git-hooks\n```\n\n```\n// package.json\n\"scripts\": {\n+ \"prepare\": \"pnpx simple-git-hooks\",\n}\n+\"simple-git-hooks\": {\n+  \"pre-commit\": \"pnpm lint-staged\"\n+},\n+\"lint-staged\": {\n+  \"*\": \"eslint --fix\"\n+}\n```\n\n> \"prepare\": \"pnpx simple-git-hooks\": 在执行npm install命令之后执行的脚本，用于初始化simple-git-hooks配置\n\n## editorConfig 规范\n\n> 项目根目录添加`.editorConfig`文件，统一不同编辑器的编码风格和规范。\n> \n> `vscode`需要安装插件[EditorConfig for VS Code](https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DEditorConfig.EditorConfig \"https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig\")获取支持\n\n```\n# @see: http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符编码为 utf-8\nindent_style = space # 缩进风格为 空格(tab | space)\nindent_size = 2 # 缩进大小为 2\nend_of_line = lf # 换行符为 lf (crlf | lf | cr)\ninsert_final_newline = true # 在文件末尾插入一个新行\ntrim_trailing_whitespace = true # 去除行尾空格\n\n[*.md] # 表示所有 .md 文件适用\ninsert_final_newline = false # 在文件末尾不插入一个新行\ntrim_trailing_whitespace = false # 不去除行尾空格\n\n```\n\n## 安装组件库\n\n成套的全端兼容ui库包括：\n\n-   **[uni-ui](https://link.juejin.cn/?target=https%3A%2F%2Funiapp.dcloud.io%2Fcomponent%2Funiui%2Funi-ui \"https://uniapp.dcloud.io/component/uniui/uni-ui\")：官方组件库，兼容性好、组件封装性好、功能强大，而且还有[大佬编写的ts类型](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Funi-helper%2Funi-ui-types \"https://github.com/uni-helper/uni-ui-types\")。目前正在使用的组件库**\n-   [uview-plus](https://link.juejin.cn/?target=https%3A%2F%2Fuiadmin.net%2Fuview-plus%2Fcomponents%2Fintro.html \"https://uiadmin.net/uview-plus/components/intro.html\")：uview-plus3.0是基于uView2.x修改的vue3版本。\n-   [uViewUI](https://link.juejin.cn/?target=http%3A%2F%2Fwww.uviewui.com%2F \"http://www.uviewui.com/\")：组件丰富、文档清晰，支持nvue\n-   [colorUI css库](https://link.juejin.cn/?target=http%3A%2F%2Fext.dcloud.net.cn%2Fplugin%3Fid%3D239 \"http://ext.dcloud.net.cn/plugin?id=239\")：颜值很高，css库而非组件\n-   [图鸟UI](https://link.juejin.cn/?target=https%3A%2F%2Fvue2.tuniaokj.com%2F \"https://vue2.tuniaokj.com/\")：高颜值UI库\n-   [图鸟UI vue3版](https://link.juejin.cn/?target=https%3A%2F%2Fvue3.tuniaokj.com%2Fzh-CN%2F \"https://vue3.tuniaokj.com/zh-CN/\")：高颜值UI库，vue3+ts版组件，值得尝试\n-   [first UI](https://link.juejin.cn/?target=https%3A%2F%2Fext.dcloud.net.cn%2Fplugin%3Fid%3D7646 \"https://ext.dcloud.net.cn/plugin?id=7646\")：分开源版和商业版，虽然组件很全、功能强大，但是大多数组件都是需要购买的商业版才能用\n\n**1、安装组件**\n\n```\npnpm add @dcloudio/uni-ui -S\npnpm add sass -D\n```\n\n**2、[配置`easycom`自动引入组件](https://link.juejin.cn/?target=https%3A%2F%2Funiapp.dcloud.net.cn%2Fcomponent%2Funiui%2Fquickstart.html%23npm%25E5%25AE%2589%25E8%25A3%2585 \"https://uniapp.dcloud.net.cn/component/uniui/quickstart.html#npm%E5%AE%89%E8%A3%85\")**\n\n```\n// pages.json\n{\n    \"easycom\": {\n        \"autoscan\": true,\n        \"custom\": {\n            // uni-ui 规则如下配置\n            \"^uni-(.*)\": \"@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue\"\n        }\n    },\n    // 其他内容\n    pages:[\n        // ...\n    ]\n}\n```\n\n**3、安装`uni-ui`ts类型库**\n\n```\npnpm add -D @uni-helper/uni-ui-types\n```\n\n具体使用方法请查看：[uni-ui-types](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Funi-helper%2Funi-ui-types \"https://github.com/uni-helper/uni-ui-types\")\n\n## 后续\n\n模版更多内置功能(如`网络请求、登录、授权、上传、下载、分享`)等更新中...\n\n参考链接：\n\n-   [uni-app 项目支持 vue 3.0 介绍，及升级指南](https://link.juejin.cn/?target=https%3A%2F%2Fask.dcloud.net.cn%2Farticle%2F37834 \"https://ask.dcloud.net.cn/article/37834\")\n-   [当 uni-app 遇见 vscode](https://link.juejin.cn/?target=https%3A%2F%2Fask.dcloud.net.cn%2Farticle%2F36286 \"https://ask.dcloud.net.cn/article/36286\")\n-   [关于uni-app的ui库、ui框架、ui组件](https://link.juejin.cn/?target=https%3A%2F%2Fask.dcloud.net.cn%2Farticle%2F35489 \"https://ask.dcloud.net.cn/article/35489\")', 'public/uploads/1694356050322.png', 2, 5, 1, 975, '2019-11-06 15:44:04', 1);
INSERT INTO `article` VALUES (62, 7, 'Mrs.', 'SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. A man’s best friends are his ten fingers. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. I destroy my enemies when I make them my friends. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections. The reason why a great man is great is that he resolves to be a great man. Anyone who has ever made anything of importance was disciplined. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. A man is not old until regrets take the place of dreams. There is no way to happiness. Happiness is the way. Genius is an infinite capacity for taking pains. All journeys have secret destinations of which the traveler is unaware. Success consists of going from failure to failure without loss of enthusiasm. Remember that failure is an event, not a person. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. Anyone who has ever made anything of importance was disciplined. To connect to a database or schema, simply double-click it in the pane. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. Anyone who has never made a mistake has never tried anything new. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. A comfort zone is a beautiful place, but nothing ever grows there. Difficult circumstances serve as a textbook of life for people. To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. I may not have gone where I intended to go, but I think I have ended up where I needed to be. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections. All journeys have secret destinations of which the traveler is unaware. You cannot save people, you can just love them. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. All journeys have secret destinations of which the traveler is unaware. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. I will greet this day with love in my heart. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. Instead of wondering when your next vacation is, maybe you should set up a life you don’t need to escape from. Sometimes you win, sometimes you learn. If you wait, all that happens is you get older. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. To connect to a database or schema, simply double-click it in the pane. If the plan doesn’t work, change the plan, but never the goal. The reason why a great man is great is that he resolves to be a great man. Difficult circumstances serve as a textbook of life for people. Instead of wondering when your next vacation is, maybe you should set up a life you don’t need to escape from. Secure SHell (SSH) is a program to log in into another computer over a network, execute commands on a remote server, and move files from one machine to another. The On Startup feature allows you to control what tabs appear when you launch Navicat. I will greet this day with love in my heart. In the Objects tab, you can use the List List, Detail Detail and ER Diagram ER Diagram buttons to change the object view. A man is not old until regrets take the place of dreams. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. Navicat 15 has added support for the system-wide dark mode. Sometimes you win, sometimes you learn. You cannot save people, you can just love them. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. In the middle of winter I at last discovered that there was in me an invincible summer. The On Startup feature allows you to control what tabs appear when you launch Navicat. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. The past has no power over the present moment. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. I destroy my enemies when I make them my friends. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily. The On Startup feature allows you to control what tabs appear when you launch Navicat. You must be the change you wish to see in the world. You will succeed because most people are lazy. If it scares you, it might be a good thing to try. A man is not old until regrets take the place of dreams. In the middle of winter I at last discovered that there was in me an invincible summer. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. A man is not old until regrets take the place of dreams. Difficult circumstances serve as a textbook of life for people. All journeys have secret destinations of which the traveler is unaware. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. To open a query using an external editor, control-click it and select Open with External Editor. You can set the file path of an external editor in Preferences. You cannot save people, you can just love them. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. Sometimes you win, sometimes you learn. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. Creativity is intelligence having fun. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information.', '', 1, 6, 0, 646, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (63, 6, '在本地和CI/CD中支持npm免登录发布', '专栏上篇文章传送门：[函数库Rollup构建优化](https://juejin.cn/post/7176938419392774203 \"https://juejin.cn/post/7176938419392774203\")\n\n本节涉及的内容源码可在[vue-pro-components c8 分支](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcumt-robin%2Fvue-pro-components%2Ftree%2Fc8 \"https://github.com/cumt-robin/vue-pro-components/tree/c8\")找到，欢迎 star 支持！\n\n## 前言\n\n本文是 [基于Vite+AntDesignVue打造业务组件库](https://juejin.cn/column/7140103979697963045 \"https://juejin.cn/column/7140103979697963045\") 专栏第 9 篇文章【在本地和CI/CD中支持npm免登录发布】，专门分享一下如何在 npm 发包时支持免登录发布，并同时支持在本地和CI/CD中操作发布流程。\n\n在[组件库技术选型和开发环境搭建](https://juejin.cn/post/7153432538046791687#heading-16 \"https://juejin.cn/post/7153432538046791687#heading-16\")这篇文章中，我们简单介绍了怎么把一个包发布到 npm 上，但是执行`lerna publish`之前需要先验证登录，因为`lerna publish`它背后执行的还是`npm publish`，所以首先需要通过 npm 的认证流程。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c7fd8b08454a029bee5ffcf51b6301~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n一个流程中如果要执行登录流程，那么它的自动化程度就不会很高。如何解决这个问题呢？答案是 token，只要我们把 token 通过某个配置告诉 npm，就等同于告诉 npm 我是谁，所以只要这个 token 代表的是我的身份，自然就没必要输入账户密码登录了。\n\n## 创建 token\n\n我们先在 [npm 网站](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2F \"https://www.npmjs.com/\") 中登录，在用户下拉菜单这里能找到创建 token 的入口。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0873ccb2745f4dcc8f100613eeed9d96~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\ntoken 有两种，\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dc8959e61e94b59b17d9c30ad7c4839~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n一种是经典的通用 token，就是不限制使用范围，你名下的任何包/组织都能用这个 token 去管理。但是也大概分几种类型。如果要用在自动化流程中，需要避开双因素(2FA)验证，我们就创建 Automation 类型的 token。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec187464c2d344158be9ea042d3e1741~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n还有一种就是更细粒度的 token，可以把权限控制到**过期时间/IP范围/可读可写/包/组织**等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3775c6439d904a7bbfd4a5f0c44367fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 如果你觉得用界面操作很 Low，也可以选择极客风的命令行。npm 提供了创建 token 的命令行，具体见 [npm token](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv9%2Fcommands%2Fnpm-token \"https://docs.npmjs.com/cli/v9/commands/npm-token\")。\n\n## 怎么使用 token？\n\n我们创建 token 主要是为了用于发布 npm 包。这个 token 我们可以配置在`.npmrc`文件中，对应的 key 是`_authToken`。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58598bee9ab647088ca3da8260acbc39~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n```\n//registry.npmjs.org/:always-auth=true\n//registry.npmjs.org/:_authToken=your npm token\n```\n\n但是`.npmrc`文件一般是要提交到仓库中的，而 token 又是一个比较私密的数据，就不适合写死放在 .npmrc 中，此时我们可以使用变量替代，改成这样：\n\n```\n//registry.npmjs.org/:always-auth=true\n//registry.npmjs.org/:_authToken=${NPM_TOKEN}\n```\n\n那么这个变量可以从哪里读来呢？我们可以看看 npm 的一篇文档[Set the token as an environment variable on the CI/CD server](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fusing-private-packages-in-a-ci-cd-workflow%23set-the-token-as-an-environment-variable-on-the-cicd-server \"https://docs.npmjs.com/using-private-packages-in-a-ci-cd-workflow#set-the-token-as-an-environment-variable-on-the-cicd-server\")是怎么说的。\n\n> The npm cli will replace this value with the contents of the NPM\\_TOKEN environment variable.\n\n答案是环境变量。这里要考虑 2 种情况，一个是本地化发布，一个是在 CI/CD 中发布。\n\n首先说后面一种情况，在 CI/CD 中发布 npm 包已经有比较标准的方案了，大部分 CI/CD 平台都支持在 yaml 配置文件中指定环境变量，并且支持加密，没有暴露 token 的风险。上述文档中也有提到，关键配置如下：\n\n```\nsteps:\n  - run: |\n      npm install\n  - env:\n      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n\n那么关键还是在于前面那种情况，有时候需要在本地发布 npm 包，此时应该怎么办呢？\n\n我首先尝试添加系统环境变量，但是没有立即成功；\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8453be0ebfc64be1873ced7b87baef6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我还尝试了`dotenv`，虽然`dotenv`能加载`.env`文件到环境变量中，不过也不太方便。\n\n如果`.npmrc`中存在变量`NPM_TOKEN`，跑任何`npm scripts`，都会去寻找`${NPM_TOKEN}`，如果找不到就会报错，而我们不可能给所有脚本都加上`dotenv`。\n\n所以如果要在本地发布，一个替代方法是临时手动将`.npmrc`的 token 写死，改成：\n\n```\n//registry.npmjs.org/:_authToken=npm_xxxxxxxxxxxxxxxxxx\n```\n\n但是执行 lerna publish 的时候又需要一个干净的 git 状态，如果有 modified files 也不行（因为临时改了 .npmrc 就会导致 git 工作区不干净了）。啊，真难！最理想的办法还是把环境变量给搞定，同时又不能改太多脚本。\n\n最后我发现加系统环境变量其实是有用的，关键是改了后要重新打开 VSCode（之前没有尝试这一步，导致我以为加系统环境变量没有用），否则终端加载不到最新的环境变量，果然还得是重启大法！所以最佳选择是使用变量`${NPM_TOKEN}`。\n\n## 本地验证 token 是否生效\n\n搞定了环境变量后，我们先试试本地 publish 的场景。\n\n考虑到之前用`npm login`或者`npm adduser`登录过，所以我们需要先退出登录再测试，否则无法确定是否 token 是否真的起了作用。\n\n退出登录命令：\n\n```\nnpm logout --registry=https://registry.npmjs.org\n```\n\n接着可以试试`lerna publish`或者`npm publish`，经测试已经不需要登录就能发布 npm 包了。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/957b4364f4134e02abf3e395384e4d7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 集成构建和发布流程\n\n在集成构建和发布流程之前，我们参照`@vue-pro-components/utils`的构建流程把`@vue-pro-components/headless`的构建流程搞定，因为它们本质上都是函数库，打包过程不会有太多差异，抄一抄它不香吗？\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959317ebb367466eb0e8cce90e6f2b65~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n同时根据各个包之间的依赖关系，新增一个统一构建的入口`buildBatch`，这样就能通过`gulp buildBatch`一条命令把所有的构建工作都做了。\n\n继而可以得到一条集成构建和发布流程的命令`release`。\n\n```\n\"release\": \"yarn buildBatch && yarn publish:package\",\n```\n\n所以只要我们把代码修改完毕，版本号确定之后，就可以执行`yarn release`进行发布了。\n\n## CI/CD workflow 搭建\n\nGithub 本身也支持 CI/CD，相关的产品是 Github Actions，所以我们可以直接使用它实现自动化构建和发布流程。\n\n> 现在市面上有很多 CI/CD 工具，它们虽然在配置上有些差异，但是架构和理念都是相似的，学会使用一个，其他的参考着文档也基本能看得懂。\n\n使用 Github Actions 主要就是写配置文件，我们可以基于[官方的一些模板](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcumt-robin%2Fvue-pro-components%2Factions%2Fnew \"https://github.com/cumt-robin/vue-pro-components/actions/new\")来初始化一个配置文件，这个 Publish Node.js Package 模板就比较合适。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c4818f07a75404bbf7d43bda6699343~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n你也可以通过阅读[Github Actions 文档](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.github.com%2Fen%2Factions%2Fquickstart \"https://docs.github.com/en/actions/quickstart\")来了解更多相关知识。\n\n我们按照模板文件改一改：\n\n```\n# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created\n# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages\nname: Build and Publish Node.js Package\n\non:\n  push:\n    branches:\n    - c*\n\nenv:\n  NPM_TOKEN: ${{secrets.NPM_TOKEN}}\n\njobs:\n  publish-npm:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      \n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16\n            \n      - name: Install Dependency\n        run: yarn install --frozen-lockfile\n        \n      - name: Build and Publish\n        run: yarn release\n```\n\n因为这里要用到`NPM_TOKEN`变量，我们先到 Settings -> Secrets 中维护好变量。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/563065e5d659498f967394ae284e1a74~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n修改一个版本号测试一下，一个简单版本的 CI/CD 这不就有了吗？\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13a518d1683414b8dbbd3cb1d546f04~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n然后可以再加个 Cache 优化一下安装依赖的过程，这可以用到[actions/cache@v3](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Factions%2Fcache%2Fblob%2Fmain%2Fexamples.md%23node---yarn \"https://github.com/actions/cache/blob/main/examples.md#node---yarn\")。\n\n## 结语\n\n通过阅读和学习本文内容，我们已经能掌握怎么优雅地发布一个 npm 包，并同时支持了在本地和远程 CI/CD 中进行发布操作。但是我们应该注意到，每次发布都会执行完整的`buildBatch`过程，这个有没有必要呢？我想有时候是没有必要的，因为有可能某一个包根本就没修改过，但是每次发布时都执行打包过程就会浪费资源和时间。这里先留个疑问，后面文章接着讲。如果您对我的专栏感兴趣，欢迎您[订阅关注本专栏](https://juejin.cn/column/7140103979697963045 \"https://juejin.cn/column/7140103979697963045\")，接下来可以一同探讨和交流组件库开发过程中遇到的问题。\n\n> 技术交流&闲聊：[前端司南](https://link.juejin.cn/?target=https%3A%2F%2Fqncdn.wbjiang.cn%2F%25E5%2585%25AC%25E4%25BC%2597%25E5%258F%25B7%2F%25E5%2589%258D%25E7%25AB%25AF%25E5%258F%25B8%25E5%258D%2597%25E5%2588%2586%25E4%25BA%25AB.png \"https://qncdn.wbjiang.cn/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%89%8D%E7%AB%AF%E5%8F%B8%E5%8D%97%E5%88%86%E4%BA%AB.png\")', 'public/uploads/1694336465736.png', 2, 3, 0, 573, '2023-09-10 09:01:07', 1);
INSERT INTO `article` VALUES (64, 5, 'Mr.', 'Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. It collects process metrics such as CPU load, RAM usage, and a variety of other resources over SSH/SNMP. All journeys have secret destinations of which the traveler is unaware. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. The Synchronize to Database function will give you a full picture of all database differences. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. Genius is an infinite capacity for taking pains. It wasn’t raining when Noah built the ark. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. Actually it is just in an idea when feel oneself can achieve and cannot achieve. SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. The reason why a great man is great is that he resolves to be a great man. Navicat provides powerful tools for working with queries: Query Editor for editing the query text directly, and Query Builder, Find Builder or Aggregate Builder for building queries visually. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview. Anyone who has never made a mistake has never tried anything new. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. Instead of wondering when your next vacation is, maybe you should set up a life you don’t need to escape from. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. It is used while your ISPs do not allow direct connections, but allows establishing HTTP connections. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. The On Startup feature allows you to control what tabs appear when you launch Navicat. You cannot save people, you can just love them. The Synchronize to Database function will give you a full picture of all database differences. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. Optimism is the one quality more associated with success and happiness than any other. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. The first step is as good as half over. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. In the middle of winter I at last discovered that there was in me an invincible summer. It collects process metrics such as CPU load, RAM usage, and a variety of other resources over SSH/SNMP. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. Such sessions are also susceptible to session hijacking, where a malicious user takes over your session once you have authenticated. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source.', '', 1, 6, 1, 494, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (65, 6, '如何打造一个webpack的plugin', '## 前言\n\n前几天面试，面试官问打造一个webpack的plugin有思路吗，我愣住了，来写个文章记录一下。\n\n## 正文\n\n不清楚webpack是啥的可以去看看我的上一篇文章，记录的很详细，我们就直接简单铺垫下开始。\n\n## 一、创建目录结构\n\n我们创建一个WEBPACK-PLUGIN的目录，**初始化**后，安装**webpack**和**webpack-cli**。接着创建一些**目录文件**，结构如下：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc7483c6f824a10b037a15c849ef340~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 二、编写index.js\n\n我们在index.js中写一段很简单的代码，如下：\n\n```\nfunction add(a, b) {\n  return a + b\n}\n\nadd(1, 2)\n\nconsole.log(\'hello world\');\n```\n\n如果这个index.js我需要**打包**到index.html中使用，我们就需要在根目录创建一个webpack的配置文件**webpack.config.js**。\n\n## 三、编写webpack.config.js\n\n基本的配置如下：\n\n```\nmodule.exports = {\n  mode: \'development\',\n  entry: {\n    main: path.resolve(__dirname, \'src/index.js\')\n  },\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'main.js\'  \n  }\n```\n\n并且在package.json中**配置**运行命令（直接**yarn build**打包）：\n\n> \"build\": \"webpack --config webpack.config.js\"\n\n运行打包命令后，我们会发现根目录下多出dist文件夹，里面的main.js是对index.js的打包，我们将其引入html。\n\n## 四、编写index.html\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <script src=\"./dist/main.js\"></script>  <!-- 引入main.js -->\n</body>\n\n</html>\n```\n\n我们跑一下这个html，成功打印！\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a84dbd3953842ceb29766434eaaadff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 五、几个问题\n\n`问题一`： 我们如果**修改**html中打印的东西，**重新打包**，那么处于dist文件夹下的文件依然还是**main.js**。这就会有一个问题，**CDN网络分发**的情况下，分布服务器感知总部服务器的变更一般是通过**资源文件名的变更**而变更的。\n\n所以，该想个法子了！可不可以在每次打包后在文件名后拼接一串哈希值呢？  \n我们在webpack配置文件中将 **filename** 改成 **\'main.\\[hash:8\\].js\'**\n\n再去打包，发现dist中新增了一个文件！成功解决这个问题。\n\n`问题二`： 如果我们想让main.js**自动引入**到这个html中来而不需要我们手动引入呢？  \n可以安装**html-webpack-plugin**插件解决这个问题。\n\n配置文件代码如下：\n\n```\nconst path = require(\'path\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\nmodule.exports = {\n  mode: \'development\',\n  entry: {\n    main: path.resolve(__dirname, \'src/index.js\')\n  },\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename:\'main.[hash:8].js\'\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, \'index.html\')\n    })\n  ]\n}\n```\n\n我们把之前我们**手动**在html中引入main.js的代码**删除**，重新打包，会发现dist文件夹下出现index.html，并且**自动**引入了main.js，运行html也能得到相应的打印！\n\n`问题三`： 我们可以瞅一眼，dist文件夹下一坨main.js**混杂**在一起，那么之前**打包过**的文件我们是不是可以**删除**呢？  \n可以安装**clean-webpack-plugin**插件来解决。\n\n配置文件继续添加引入并使用：\n\n```\nconst path = require(\'path\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\nconst { CleanWebpackPlugin } = require(\'clean-webpack-plugin\')\n\nmodule.exports = {\n  mode: \'development\',\n  entry: {\n    main: path.resolve(__dirname, \'src/index.js\')\n  },\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'main.js\'  //\'main.[hash:8].js\'：每次打包的文件名不一样 让分布服务器能感知到主服务器发生变化\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, \'index.html\')\n    }),\n    new CleanWebpackPlugin(),  //把历史打包文件清除掉\n  ]\n}\n```\n\n打包完成后，我们去dist文件夹查看，发现瞬间明朗了!\n\n你以为问题结束了？还没有呢！\n\n`问题四`：CleanWebpackPlugin是怎么把历史的打包文件清除的呢？它怎么知道哪些是历史的包呢？\n\n`思路`：在把**新**的包放进dist文件夹**前**把**历史**的包**清除**掉不就可以了吗？  \n那么这就涉及到**执行时间**的问题了，我们去webpack官方文档发现webpack内置了一系列的[钩子函数](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompiler-hooks%2F%23root \"https://www.webpackjs.com/api/compiler-hooks/#root\")（compiler 钩子），分别会在打包过程中的各个时间节点执行。 （🚩ps:[compilation 钩子](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompilation-hooks%2F \"https://www.webpackjs.com/api/compilation-hooks/\")是编译阶段的钩子函数）\n\n再去看看`官方文档`中对`plugin的介绍`：\n\n> **插件**是webpack的**支柱**功能，插件目的在于解决**loader**无法实现的**其他事**，webpack**插件**是一个具有**apply**方法的JavaScript**对象**。apply方法会被**webpack compiler**调用，并且在**整个**编译生命周期都可以访问**compiler**对象。\n\n好了，到这里，我们基本的铺垫才做好。\n\n## 六、正题：打造一个简单插件\n\n我们需要打造一款可以自动在main.js后拼接一个**时间戳**的插件，并且能**自动引入**到html中。\n\n> `思路`：\n> \n> 1.  拼接**时间戳**应该在**html文件生成**出来**之前**完成\n> 2.  我们的**plugin**应该在html-webpack-plugin**之前**生效\n\n我们在根目录创建**stamp-webpack-plugin.js**来打造插件\n\n```\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\nclass StampPlugin {\n  apply(compiler) {\n    //compilation是在编译这件事被创建之后就会执行（可以保证我们的插件一定会在文件生成之前执行）\n    //注册一个名为StampWebpackPlugin的方法\n    compiler.hooks.compilation.tap(\'StampWebpackPlugin\', (compilation, compilationParams) => {  //tap用来触发钩子函数\n      //参数compilation是模块\n       HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration.tap(\'StampWebpackPlugin\', (data, cb) => {  //使用HtmlWebpackPlugin提供的钩子beforeAssetTagGeneration（静态标签生成之前）\n        let jsSrc = data.assets.js[0]  //拿到\'main.js\'\n        data.assets.js[0] = `${jsSrc}?${new Date().getTime()}`  //拼接时间戳后替换\n      });\n\n    })\n  }\n}\n\nmodule.exports = StampPlugin\n```\n\n最后，我们只需要在**webpack配置文件**中**引入**我们打造的插件就行了：\n\n```\nconst path = require(\'path\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\nconst { CleanWebpackPlugin } = require(\'clean-webpack-plugin\')\nconst StampPlugin=require(\'./stamp-webpack-plugin.js\')\n\nmodule.exports = {\n  mode: \'development\',\n  entry: {\n    main: path.resolve(__dirname, \'src/index.js\')\n  },\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'main.js\' \n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, \'index.html\')\n    }),\n    new CleanWebpackPlugin(),  //把历史打包文件清除掉\n    new StampPlugin()\n  ]\n}\n```\n\n再次打包，会发现html自动引入main.js，并拼接上了时间戳，再也不用手动在output的文件名中添加了！\n\n## 结\n\n这里只打造一个简单的插件，流程并不复杂，看完之后大佬们就可以自己去打造插件了！', 'public/uploads/1694336509643.png', 2, 5, 0, 165, '2023-09-10 09:01:54', 1);
INSERT INTO `article` VALUES (66, 5, 'iOS内购In App Purchase从准备、测试到上架', '**前段时间刚做完内购，然后做了一下整理：**\n\n\n## 内购商品类型\n\n| 类型 | 说明 | 举例 |\n| --- | --- | --- |\n| 消耗型项目 | 消耗性购买项目会随着使用逐渐耗尽，并可以再次购买 | 比如：游戏里的宝石，抖音的抖币，王者的点劵（花了就没有了属于消耗型） |\n| 非消耗型项目 | 永久性的购买项目可一次性购买，并且不会到期，例如照片滤镜或化妆品。 | 比如：永久会员，游戏角色时装，宠物等（买了就不会消失永久拥有的） |\n| 非续期订阅 | 用户可以购买服务或内容的限时访问权限，例如游戏内内容的季票。此类订阅不会自动续期，因此若用户希望保留访问权限，则需要在订阅结束后购买新的订阅。 | 比如：1个月会员，1年会员（有时间期效的，过了这个时间就没有了） |\n| 自动续期订阅 | 订阅是允许用户在固定时间段内购买动态内容的产品。除非用户选择取消，否则此类订阅会自动续期。 | 比如：哔哩哔哩的大会员（会按周期\\[一年，一个月,...\\]自动续费的） |\n| 订阅群组 | 所有订阅必须属于某个群组。用户一次只能订阅一个群组内的一个项目，但可以更改为同一群组内的另一个订阅项目。 |  |\n\n## **一、准备内购**\n\n## 1、银行账户信息\n\n到App Store Connect后台填写银行账户信息，填写报税表等 [appstoreconnect.apple.com/](https://link.juejin.cn/?target=https%3A%2F%2Fappstoreconnect.apple.com%2F \"https://appstoreconnect.apple.com/\")，参考[填写银行卡信息](https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4f5f0b45b083 \"https://www.jianshu.com/p/4f5f0b45b083\")\n\n注意：银行卡信息等需要填写中文的拼音，不能填写中文\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ead342a773c5418db419441d278bed8f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2054fbae6254bb19b58fcf8c29196f6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n需要等待协议两项都是『有效』状态，信息填完大概1天内/1天左右就会更新状态。『有效』状态才能正常测试购买，不然客户端获取的商品都是空，无法进行后续操作。\n\n## 2、内购商品介绍、创建\n\n商品类型主要有：消耗型项目、非消耗型项目、自动续期订阅、非续期订阅\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0806e99accf441e8980858491b168e02~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n注意：创建商品前需要清楚了解商品各个类型，请看【内购商品类型】；\n\n添加内购商品的时候，【参考名称】是可以修改的，【产品ID】是唯一的，创建了之后即使删除这个商品，这个ID也无法重复使用了，推荐使用产品ID命名：包名+类型+商品编号，比如: com.xxx.xxx.Vip.ABC123\n\n### 3.1、消耗型、非消耗型商品创建\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf80e56eac449aa87e7cc6181feb553~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bfca7cc42a84943a48c7648f31019a8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n### 2.2、订阅型商品创建\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a5605ae9ff4a90857577c44b29c8b9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 2.2.1、自动续期订阅\n\n**一个群组内的商品，支持升级降级订阅，同组内同时只会订阅一个商品。**\n\n**比如说，组内有3个商品，1个月会员，6个月会员，1年会员，用户可以在这个组内升降级修改订阅商品，最终扣费以最后一个订阅的扣费。**\n\n**N个组内的商品，可以同时订阅N个商品。**\n\n| 订阅群组 | 组内商品 | 用户订阅的 |\n| --- | --- | --- |\n| 组A | 商品A，商品B，商品C | 订阅A/B/C |\n| 组B | 商品E，商品F，商品G | 订阅E/F/G |\n| 用户总共订阅 |  | A/B/C 和 E/F/G 【同时订阅了两个商品】 |\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9406b8eff2f4b45a8ca3d830a79fe94~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 2.2.2、自动订阅群组商品升降级说明\n\n**在同一群组创建商品的时候，需要注意升降级跨级问题，从提供最高级别服务的选项开始，按降序排列你的订阅。**\n\n| 商品等级升降 | 说明 |\n| --- | --- |\n| 升级 | 从较低等级的订阅切换到较高等级的订阅时，用户先前的 App 内购买项目金额将会按比例退还到原始付款方式。新的 App 内购买项目将收取完整价格并立即生效，用户的续期日期也随之更改为升级日期。 |\n| 降级 | 用户从较高等级的订阅切换到较低等级的订阅时，在下一个续期日期，会以新费率向用户收费。 |\n| 跨级 | 在相同等级的订阅间进行切换时，如果 App 内购买项目的时限相同，那么用户先前的 App 内购买项目金额将会按比例退还到原始付款方式。新的 App 内购买项目将收取完整价格并立即生效，用户的续期日期也随之更改为升级日期。如果 App 内购买项目的时限不同，那么跨级将会在用户的下一个续期日期生效。 |\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1adab4518d409187e233fcf34e3a93~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 2.2.3、非自动续期订阅\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea7268b0801641cfaca6f0599b43379e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 2.2.4、商品详细信息编辑\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0929f3951ad842f2948597764785c550~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 3、配置沙箱测试账号\n\n沙盒环境说明：\n\n1、必须是真实设备才能测试内购，模拟器不行；\n\n2、如果设备安装的是adhoc包，xcode直接run的包，测试时需要登录沙盒测试员账号进行购买，审核人员审核时候的支付也都是使用沙盒环境（此处关系到验签）。\n\n3、TestFlight里安装的包，也是使用沙盒环境，但是使用真实的Apple ID进行购买，不会扣钱。\n\n#### 3.1、增加沙盒人员\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ef87b3cc5644ecda201dfd1250115ba~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 3.2、清除购买历史，删除沙盒人员\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c3b4d2b6414bce86b7e3c299846968~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 3.3、修改自动续期测试时间\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c436bdcc8e243a19546e04547db21d8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5ffde36f00f4a0e80e30fc5f0c43d07~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 4、配置服务器通知地址\n\n**配置好服务端与苹果交互的回调地址，才能实现支付流程服务端与苹果的通讯，比如：购买验单回调，订阅续订回调，退款回调。**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43738d09aef441538d133488d18d3608~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 二、开始购买\n\n## 1、非订阅型购买流程概览\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0816f8a6e9a4106abd24564ee8afd43~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 2、自动续期型购买流程概览\n\n**注意：首次订阅，客户端会上传receipt data给服务端，进行验单；同时Apple也会有一个订阅成功的回调到服务端，成功处理一个即可，不要重复赋予权益。**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4fb385281df4168ae8967807f079977~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 3、订单凭证验签\n\n**订单凭证验签成功与否，决定此次购买的结果。**\n\n**注意：为了保证不影响审核，服务器验签需要使用双重验证。优先验证生产环境，返回错误代码21007后，进行测试环境验签。**\n\n### **3.1、Apple验签地址**\n\n沙盒测试：[sandbox.itunes.apple.com/verifyRecei…](https://link.juejin.cn/?target=https%3A%2F%2Fsandbox.itunes.apple.com%2FverifyReceipt \"https://sandbox.itunes.apple.com/verifyReceipt\")\n\n正式：[buy.itunes.apple.com/verifyRecei…](https://link.juejin.cn/?target=https%3A%2F%2Fbuy.itunes.apple.com%2FverifyReceipt \"https://buy.itunes.apple.com/verifyReceipt\")\n\n### **3.2、凭证receipt data参数预览**\n\n[Apple官方文档的参数解释](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Freleasenotes%2FGeneral%2FValidateAppStoreReceipt%2FChapters%2FReceiptFields.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40010573-CH106-SW12 \"https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW12\")\n\n| 参数 | 说明 | 备注 |\n| --- | --- | --- |\n| environment | 支付环境：沙盒、非沙盒 |  |\n| transaction\\_id | 交易凭证ID |  |\n| original\\_transaction\\_id | 原始交易凭证ID |  |\n| quantity | 购买数量 |  |\n| product\\_id | 商品ID |  |\n| is\\_trial\\_period | 是否享用免费试用 |  |\n| is\\_in\\_intro\\_offer\\_period | 是否享用首单优惠 | 订阅型商品有的 |\n| auto\\_renew\\_status | 订阅状态 1:续订中 0:关闭续期订阅 | auto\\_renew\\_status=1 并且 is\\_in\\_billing\\_retry\\_period=1, 此时用户的状态并不能标记为已关闭, 而应该是扣费失败，仍在尝试订阅 |\n| is\\_in\\_billing\\_retry\\_period | 自动续期订阅状态 1:尝试订阅 0:停止尝试订阅 |  |\n| latest\\_receipt\\_info | 自动续费订阅的所有收据凭证 |  |\n| pending\\_renewal\\_info | 续订订单的状态信息 |  |\n| cancellation\\_date | 退款的订单凭证 | 取消的应用内购买将无限期保留在收据中。仅适用于非消耗性产品、自动续订订阅、非续订订阅或免费订阅的退款。 |\n| cancellation\\_reason | 退款的原因 1:应用程序中的实际或感知问题客户取消了交易 0:交易因其他原因被取消,意外购买等 |  |\n\n### 3.3、验签错误码\n\n| 错误码 | 说明 | 备注 |\n| --- | --- | --- |\n| 21000 | App Store无法读取你提供的JSON数据 |  |\n| 21002 | 收据数据不符合格式 |  |\n| 21003 | 收据无法被验证 |  |\n| 21004 | 你提供的共享密钥和账户的共享密钥不一致 |  |\n| 21005 | 收据服务器当前不可用 |  |\n| 21006 | 收据是有效的，但订阅服务已经过期。当收到这个信息时，解码后的收据信息也包含在返回内容中 |  |\n| 21007 | 收据信息是测试用（sandbox），但却被发送到产品环境中验证 |  |\n| 21008 | 收据信息是产品环境中使用，但却被发送到测试环境中验证 |  |\n| 21010 | 此收据无法授权。 |  |\n| 21100-21199 | 内部数据访问错误 |  |\n\n一个receipt data示例，购买了非续期订阅型和续期订阅型商品：\n\n```\n{\n        environment = Sandbox,\n        receipt = {\n                receipt_type = ProductionSandbox,\n                app_item_id = 0,\n                receipt_creation_date = 2023-02-21 08:36:06 Etc/GMT,\n                bundle_id = bundle_id,\n                original_purchase_date = 2013-08-01 07:00:00 Etc/GMT,\n                in_app = [\n                        {\n                                quantity = 1,\n                                purchase_date_ms = 1670220887000,\n                                transaction_id = 2000000218924423, // 此次交易订单ID\n                                is_trial_period = false,  // 是否享用免费试用\n                                original_transaction_id = 2000000218924423, // 原始交易订单ID\n                                purchase_date = 2022-12-05 06:14:47 Etc/GMT,\n                                product_id = product_id1,  // 商品ID\n                                original_purchase_date_pst = 2022-12-04 22:14:47 America/Los_Angeles,\n                                in_app_ownership_type = PURCHASED,\n                                original_purchase_date_ms = 1670220887000,\n                                purchase_date_pst = 2022-12-04 22:14:47 America/Los_Angeles,\n                                original_purchase_date = 2022-12-05 06:14:47 Etc/GMT\n                        },\n                        {\n                                quantity = 1,\n                                purchase_date_ms = 1671013613000,\n                                transaction_id = 2000000227571624,\n                                is_trial_period = false,\n                                original_transaction_id = 2000000227571624,\n                                purchase_date = 2022-12-14 10:26:53 Etc/GMT,\n                                product_id = product_id2,\n                                original_purchase_date_pst = 2022-12-14 02:26:53 America/Los_Angeles,\n                                in_app_ownership_type = PURCHASED,\n                                original_purchase_date_ms = 1671013613000,\n                                purchase_date_pst = 2022-12-14 02:26:53 America/Los_Angeles,\n                                original_purchase_date = 2022-12-14 10:26:53 Etc/GMT\n                        },\n                        {\n                                quantity = 1,\n                                purchase_date_ms = 1670228982000,\n                                transaction_id = 2000000219098229,\n                                is_trial_period = false,\n                                original_transaction_id = 2000000219098229,\n                                purchase_date = 2022-12-05 08:29:42 Etc/GMT,\n                                product_id = product_id3,\n                                original_purchase_date_pst = 2022-12-05 00:29:42 America/Los_Angeles,\n                                in_app_ownership_type = PURCHASED,\n                                original_purchase_date_ms = 1670228982000,\n                                purchase_date_pst = 2022-12-05 00:29:42 America/Los_Angeles,\n                                original_purchase_date = 2022-12-05 08:29:42 Etc/GMT\n                        },\n                        {\n                                quantity = 1,\n                                purchase_date_ms = 1676968560000,\n                                expires_date = 2023-02-21 08:39:00 Etc/GMT,\n                                expires_date_pst = 2023-02-21 00:39:00 America/Los_Angeles,\n                                is_in_intro_offer_period = false, // 是否享用首单优惠\n                                transaction_id = 2000000282464020,\n                                is_trial_period = false,\n                                original_transaction_id = 2000000282464020,\n                                purchase_date = 2023-02-21 08:36:00 Etc/GMT,\n                                product_id = product_id4,\n                                original_purchase_date_pst = 2023-02-21 00:36:05 America/Los_Angeles,\n                                in_app_ownership_type = PURCHASED,\n                                original_purchase_date_ms = 1676968565000,\n                                web_order_line_item_id = 2000000021347684,\n                                expires_date_ms = 1676968740000,\n                                purchase_date_pst = 2023-02-21 00:36:00 America/Los_Angeles,\n                                original_purchase_date = 2023-02-21 08:36:05 Etc/GMT\n                        }\n                ],\n                adam_id = 0,\n                receipt_creation_date_pst = 2023-02-21 00:36:06 America/Los_Angeles,\n                request_date = 2023-02-21 08:36:10 Etc/GMT,\n                request_date_pst = 2023-02-21 00:36:10 America/Los_Angeles,\n                version_external_identifier = 0,\n                request_date_ms = 1676968570311,\n                original_purchase_date_pst = 2013-08-01 00:00:00 America/Los_Angeles,\n                application_version = 17,\n                original_purchase_date_ms = 1375340400000,\n                receipt_creation_date_ms = 1676968566000,\n                original_application_version = 1.0,\n                download_id = 0\n        },\n        pending_renewal_info = [ // 续订订单的状态信息\n                {\n                        product_id = product_id4, // 续订的商品ID [注意：用户在订阅周期内切换商品,此ID是新一期续订的商品ID]\n                        original_transaction_id = 2000000282464020, // 首次创建续订订单的ID\n                        auto_renew_product_id = product_id4, \n                        auto_renew_status = 1  // 1:续订中 0:关闭续期订阅 [注意：auto_renew_status=1 并且 is_in_billing_retry_period=1, 此时用户的状态并不能标记为已关闭, 而应该是扣费失败]\n                }\n        ],\n        status = 0,\n        latest_receipt_info = [ // 自动续费订阅的所有收据 [注意：退款后会出现cancellation_date和cancellation_reason字段, 未退款则没有这两个字段]\n                {\n                        quantity = 1,\n                        purchase_date_ms = 1670221172000,\n                        transaction_id = 2000000218930621,\n                        is_trial_period = false,\n                        original_transaction_id = 2000000218930621,\n                        purchase_date = 2022-12-05 06:19:32 Etc/GMT,\n                        product_id = product_id1,\n                        original_purchase_date_pst = 2022-12-04 22:19:32 America/Los_Angeles,\n                        in_app_ownership_type = PURCHASED,\n                        original_purchase_date_ms = 1670221172000,\n                        purchase_date_pst = 2022-12-04 22:19:32 America/Los_Angeles,\n                        original_purchase_date = 2022-12-05 06:19:32 Etc/GMT\n                },\n                {\n                        quantity = 1,\n                        purchase_date_ms = 1676968560000,\n                        expires_date = 2023-02-21 08:39:00 Etc/GMT,\n                        expires_date_pst = 2023-02-21 00:39:00 America/Los_Angeles,\n                        is_in_intro_offer_period = false,\n                        transaction_id = 2000000282464020,\n                        is_trial_period = false,\n                        original_transaction_id = 2000000282464020,\n                        purchase_date = 2023-02-21 08:36:00 Etc/GMT,\n                        product_id = product_id4,\n                        original_purchase_date_pst = 2023-02-21 00:36:05 America/Los_Angeles,\n                        in_app_ownership_type = PURCHASED,\n                        subscription_group_identifier = 21218554,\n                        original_purchase_date_ms = 1676968565000,\n                        web_order_line_item_id = 2000000021347684,\n                        expires_date_ms = 1676968740000,\n                        purchase_date_pst = 2023-02-21 00:36:00 America/Los_Angeles,\n                        original_purchase_date = 2023-02-21 08:36:05 Etc/GMT\n                }\n        ],\n        latest_receipt = MII10QYJKoZIhvcNAQcCoII1wjCCNb4CAQExCzAJBgUrDgMCGgUAMIIlDwYJKoZIhvcNAQcBoIIlAASCJPwxgiT4MAoCAQgCAQEEAhYAMAoCARQCAQEEAgwAMAsCAQECAQEEAwIBADALAgELAgEBBAMCAQAwCwIBDwIBAQQDAgEAMAsCARACAQEEAwIBADALAgEZAgEBBAMCAQMwDAIBAwIBAQQEDAIxNzAMAgEKAgEBBAQWAjQrMAwCAQ4CAQEEBAICAOUwDQIBDQIBAQQFAgMCcWQwDQIBEwIBAQQFDAMxLjAwDgIBCQIBAQQGAgRQMjYwMBgCAQQCAQIEEIAblU+60+oFhbfNaIz/RCEwGwIBAAIBAQQTDBFQcm9kdWN0aW9uU2FuZGJveDAcAgEFAgEBBBQD37g1m5vo1xrluKl7nm8M2iSLATAeAgEMAgEBBBYWFDIwMjMtMDItMjFUMDg6MzY6MTBaMB4CARICAQEEFhYUMjAxMy0wOC0wMVQwNzowMDowMFowIgIBAgIBAQQaDBhjb20ucHB3YWxscGVyLmN0c3N1Y2Nlc3MwPAIBBwIBAQQ0LIIWEvsbHOkmk4cZntdbCrsOL8YK7nr5aWFKjYNQcwiUSIDuJUaC/8l+M+nd26/lIEJjwTBMAgEGAgEBBETfDTZK1wX4UNIAon/+H8w6N8BN53cfrIdfeDomh8+bX5PlewMM9b3sxwYpkQMj/eB0hItQtqxWbe+aFSZb1Bzz/M9yWzCCAW8CARECAQEEggFlMYIBYTALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMTg5MjQ0MjMwGwICBqkCAQEEEgwQMjAwMDAwMDIxODkyNDQyMzAfAgIGqAIBAQQWFhQyMDIyLTEyLTA1VDA2OjE0OjQ3WjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA1VDA2OjE0OjQ3WjAnAgIGpgIBAQQeDBxQaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMU1vbnRoMIIBbwIBEQIBAQSCAWUxggFhMAsCAgasAgEBBAIWADALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgECMAwCAgauAgEBBAMCAQAwDAICBq8CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga6AgEBBAMCAQAwGwICBqcCAQEEEgwQMjAwMDAwMDIxODkzMDYyMTAbAgIGqQIBAQQSDBAyMDAwMDAwMjE4OTMwNjIxMB8CAgaoAgEBBBYWFDIwMjItMTItMDVUMDY6MTk6MzJaMB8CAgaqAgEBBBYWFDIwMjItMTItMDVUMDY6MTk6MzJaMCcCAgamAgEBBB4MHFBpUGlXYWxscGFwZXJWaXBOQ3ljbGUxTW9udGgwggFvAgERAgEBBIIBZTGCAWEwCwICBqwCAQEEAhYAMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwDAICBroCAQEEAwIBADAbAgIGpwIBAQQSDBAyMDAwMDAwMjE4OTUxNTQzMBsCAgapAgEBBBIMEDIwMDAwMDAyMTg5NTE1NDMwHwICBqgCAQEEFhYUMjAyMi0xMi0wNVQwNjo0MDoxOVowHwICBqoCAQEEFhYUMjAyMi0xMi0wNVQwNjo0MDoxOVowJwICBqYCAQEEHgwcUGlQaVdhbGxwYXBlclZpcE5DeWNsZTFNb250aDCCAW8CARECAQEEggFlMYIBYTALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMTkxMTk4MTUwGwICBqkCAQEEEgwQMjAwMDAwMDIxOTExOTgxNTAfAgIGqAIBAQQWFhQyMDIyLTEyLTA1VDA4OjQ3OjMwWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA1VDA4OjQ3OjMwWjAnAgIGpgIBAQQeDBxQaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMU1vbnRoMIIBbwIBEQIBAQSCAWUxggFhMAsCAgasAgEBBAIWADALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgECMAwCAgauAgEBBAMCAQAwDAICBq8CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga6AgEBBAMCAQAwGwICBqcCAQEEEgwQMjAwMDAwMDIxOTE0OTExMzAbAgIGqQIBAQQSDBAyMDAwMDAwMjE5MTQ5MTEzMB8CAgaoAgEBBBYWFDIwMjItMTItMDVUMDk6MTA6MzBaMB8CAgaqAgEBBBYWFDIwMjItMTItMDVUMDk6MTA6MzBaMCcCAgamAgEBBB4MHFBpUGlXYWxscGFwZXJWaXBOQ3ljbGUxTW9udGgwggFvAgERAgEBBIIBZTGCAWEwCwICBqwCAQEEAhYAMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwDAICBroCAQEEAwIBADAbAgIGpwIBAQQSDBAyMDAwMDAwMjE5OTY0Mzc4MBsCAgapAgEBBBIMEDIwMDAwMDAyMTk5NjQzNzgwHwICBqgCAQEEFhYUMjAyMi0xMi0wNlQwMzowMDo0NVowHwICBqoCAQEEFhYUMjAyMi0xMi0wNlQwMzowMDo0NVowJwICBqYCAQEEHgwcUGlQaVdhbGxwYXBlclZpcE5DeWNsZTFNb250aDCCAW8CARECAQEEggFlMYIBYTALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjI1MTc2NzgwGwICBqkCAQEEEgwQMjAwMDAwMDIyMjUxNzY3ODAfAgIGqAIBAQQWFhQyMDIyLTEyLTA4VDA3OjAyOjAwWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA4VDA3OjAyOjAwWjAnAgIGpgIBAQQeDBxQaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMU1vbnRoMIIBbwIBEQIBAQSCAWUxggFhMAsCAgasAgEBBAIWADALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgECMAwCAgauAgEBBAMCAQAwDAICBq8CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga6AgEBBAMCAQAwGwICBqcCAQEEEgwQMjAwMDAwMDIyMjUyMzk0MjAbAgIGqQIBAQQSDBAyMDAwMDAwMjIyNTIzOTQyMB8CAgaoAgEBBBYWFDIwMjItMTItMDhUMDc6MDY6MjZaMB8CAgaqAgEBBBYWFDIwMjItMTItMDhUMDc6MDY6MjZaMCcCAgamAgEBBB4MHFBpUGlXYWxscGFwZXJWaXBOQ3ljbGUxTW9udGgwggFvAgERAgEBBIIBZTGCAWEwCwICBqwCAQEEAhYAMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwDAICBroCAQEEAwIBADAbAgIGpwIBAQQSDBAyMDAwMDAwMjIzNDQ5ODM4MBsCAgapAgEBBBIMEDIwMDAwMDAyMjM0NDk4MzgwHwICBqgCAQEEFhYUMjAyMi0xMi0wOVQwNTo0NTozOFowHwICBqoCAQEEFhYUMjAyMi0xMi0wOVQwNTo0NTozOFowJwICBqYCAQEEHgwcUGlQaVdhbGxwYXBlclZpcE5DeWNsZTFNb250aDCCAW8CARECAQEEggFlMYIBYTALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjM4MDE3MDIwGwICBqkCAQEEEgwQMjAwMDAwMDIyMzgwMTcwMjAfAgIGqAIBAQQWFhQyMDIyLTEyLTA5VDEwOjQ5OjQ0WjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA5VDEwOjQ5OjQ0WjAnAgIGpgIBAQQeDBxQaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMU1vbnRoMIIBbwIBEQIBAQSCAWUxggFhMAsCAgasAgEBBAIWADALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgECMAwCAgauAgEBBAMCAQAwDAICBq8CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga6AgEBBAMCAQAwGwICBqcCAQEEEgwQMjAwMDAwMDIyMzgwODA2ODAbAgIGqQIBAQQSDBAyMDAwMDAwMjIzODA4MDY4MB8CAgaoAgEBBBYWFDIwMjItMTItMDlUMTA6NTg6MTVaMB8CAgaqAgEBBBYWFDIwMjItMTItMDlUMTA6NTg6MTVaMCcCAgamAgEBBB4MHFBpUGlXYWxscGFwZXJWaXBOQ3ljbGUxTW9udGgwggFvAgERAgEBBIIBZTGCAWEwCwICBqwCAQEEAhYAMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwDAICBroCAQEEAwIBADAbAgIGpwIBAQQSDBAyMDAwMDAwMjIzODEwMzc1MBsCAgapAgEBBBIMEDIwMDAwMDAyMjM4MTAzNzUwHwICBqgCAQEEFhYUMjAyMi0xMi0wOVQxMTowMDoxNlowHwICBqoCAQEEFhYUMjAyMi0xMi0wOVQxMTowMDoxNlowJwICBqYCAQEEHgwcUGlQaVdhbGxwYXBlclZpcE5DeWNsZTFNb250aDCCAW8CARECAQEEggFlMYIBYTALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc1NzE2MjQwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzU3MTYyNDAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEwOjI2OjUzWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEwOjI2OjUzWjAnAgIGpgIBAQQeDBxQaVBpV2FsbHBhcGVyVmlwTkN5Y2xlM01vbnRoMIIBbwIBEQIBAQSCAWUxggFhMAsCAgasAgEBBAIWADALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgECMAwCAgauAgEBBAMCAQAwDAICBq8CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga6AgEBBAMCAQAwGwICBqcCAQEEEgwQMjAwMDAwMDIyNzU3MjYxMTAbAgIGqQIBAQQSDBAyMDAwMDAwMjI3NTcyNjExMB8CAgaoAgEBBBYWFDIwMjItMTItMTRUMTA6Mjc6NDhaMB8CAgaqAgEBBBYWFDIwMjItMTItMTRUMTA6Mjc6NDhaMCcCAgamAgEBBB4MHFBpUGlXYWxscGFwZXJWaXBOQ3ljbGUzTW9udGgwggFvAgERAgEBBIIBZTGCAWEwCwICBqwCAQEEAhYAMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwDAICBroCAQEEAwIBADAbAgIGpwIBAQQSDBAyMDAwMDAwMjUwMDA2ODg1MBsCAgapAgEBBBIMEDIwMDAwMDAyNTAwMDY4ODUwHwICBqgCAQEEFhYUMjAyMy0wMS0xNFQwODoxMDoxOVowHwICBqoCAQEEFhYUMjAyMy0wMS0xNFQwODoxMDoxOVowJwICBqYCAQEEHgwcUGlQaVdhbGxwYXBlclZpcE5DeWNsZTFNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMTkwOTgyMjkwGwICBqkCAQEEEgwQMjAwMDAwMDIxOTA5ODIyOTAfAgIGqAIBAQQWFhQyMDIyLTEyLTA1VDA4OjI5OjQyWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA1VDA4OjI5OjQyWjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMTkxMjcyNDgwGwICBqkCAQEEEgwQMjAwMDAwMDIxOTEyNzI0ODAfAgIGqAIBAQQWFhQyMDIyLTEyLTA1VDA4OjUzOjMxWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTA1VDA4OjUzOjMxWjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3MjczOTUwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzcyNzM5NTAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEyOjEyOjMzWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEyOjEyOjMzWjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3MjgzNDQwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzcyODM0NDAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEyOjEzOjMwWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEyOjEzOjMwWjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3MzA3NDUwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzczMDc0NTAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEyOjE0OjQ4WjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEyOjE0OjQ4WjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3NDU0NDcwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzc0NTQ0NzAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEyOjI2OjM1WjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEyOjI2OjM1WjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3NzgwMTcwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzc3ODAxNzAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEyOjU1OjUyWjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEyOjU1OjUyWjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAXACARECAQEEggFmMYIBYjALAgIGrAIBAQQCFgAwCwICBq0CAQEEAgwAMAsCAgawAgEBBAIWADALAgIGsgIBAQQCDAAwCwICBrMCAQEEAgwAMAsCAga0AgEBBAIMADALAgIGtQIBAQQCDAAwCwICBrYCAQEEAgwAMAwCAgalAgEBBAMCAQEwDAICBqsCAQEEAwIBAjAMAgIGrgIBAQQDAgEAMAwCAgavAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGugIBAQQDAgEAMBsCAganAgEBBBIMEDIwMDAwMDAyMjc3OTc1MDkwGwICBqkCAQEEEgwQMjAwMDAwMDIyNzc5NzUwOTAfAgIGqAIBAQQWFhQyMDIyLTEyLTE0VDEzOjEyOjE5WjAfAgIGqgIBAQQWFhQyMDIyLTEyLTE0VDEzOjEyOjE5WjAoAgIGpgIBAQQfDB1QaVBpV2FsbHBhcGVyVmlwTkN5Y2xlMTJNb250aDCCAaECARECAQEEggGXMYIBkzALAgIGrQIBAQQCDAAwCwICBrACAQEEAhYAMAsCAgayAgEBBAIMADALAgIGswIBAQQCDAAwCwICBrQCAQEEAgwAMAsCAga1AgEBBAIMADALAgIGtgIBAQQCDAAwDAICBqUCAQEEAwIBATAMAgIGqwIBAQQDAgEDMAwCAgauAgEBBAMCAQAwDAICBrECAQEEAwIBADAMAgIGtwIBAQQDAgEAMAwCAga6AgEBBAMCAQAwEgICBq8CAQEECQIHBxr9StK9ZDAbAgIGpwIBAQQSDBAyMDAwMDAwMjgyNDY0MDIwMBsCAgapAgEBBBIMEDIwMDAwMDAyODI0NjQwMjAwHwICBqgCAQEEFhYUMjAyMy0wMi0yMVQwODozNjowMFowHwICBqoCAQEEFhYUMjAyMy0wMi0yMVQwODozNjowNVowHwICBqwCAQEEFhYUMjAyMy0wMi0yMVQwODozOTowMFowMQICBqYCAQEEKAwmY29tLnBwd2FsbHBlci5jdHNzdWNjZXNzLlJlbmV3YWwuVmlwLkKggg7iMIIFxjCCBK6gAwIBAgIQLasDG73WZXPSByl5PESXxDANBgkqhkiG9w0BAQUFADB1MQswCQYDVQQGEwJVUzETMBEGA1UECgwKQXBwbGUgSW5jLjELMAkGA1UECwwCRzcxRDBCBgNVBAMMO0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTIyMTIwMjIxNDYwNFoXDTIzMTExNzIwNDA1MlowgYkxNzA1BgNVBAMMLk1hYyBBcHAgU3RvcmUgYW5kIGlUdW5lcyBTdG9yZSBSZWNlaXB0IFNpZ25pbmcxLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMDdxq606Lxt68F9tc6YWfZQWLZC3JXjGsX1z2Sqf9LMYUzWFON3gcRZMbcZx01Lq50nphw+VHJQIh49MB1KDkbl2CYpFUvjIJyu1fMlY9CY1HH4bpbzjqAKxQQ16Tj3q/g7lNoH5Vs5hf+deUD0GgqulVmY0xxcimwFfZofNEXBBM3VyZKlRhcGrKSF83dcH4X3o0Hm2xMQb23wIeqsJqZmPV6CFcdcmymWTX6KTo54u1fJNZR7tgDOGAqLdZWb6cMUPsEQNARttzw3M9/NFD5iDMDfL3K77Uq/48hpDX6WbR1PEDdu0/w9GgZ9bAEUyMRfMWpS8TMFyGDjxgPNJoECAwEAAaOCAjswggI3MAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUXUIQbBu7x1KXTkS9Eye5OhJ3gyswcAYIKwYBBQUHAQEEZDBiMC0GCCsGAQUFBzAChiFodHRwOi8vY2VydHMuYXBwbGUuY29tL3d3ZHJnNy5kZXIwMQYIKwYBBQUHMAGGJWh0dHA6Ly9vY3NwLmFwcGxlLmNvbS9vY3NwMDMtd3dkcmc3MDEwggEfBgNVHSAEggEWMIIBEjCCAQ4GCiqGSIb3Y2QFBgEwgf8wNwYIKwYBBQUHAgEWK2h0dHBzOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wgcMGCCsGAQUFBwICMIG2DIGzUmVsaWFuY2Ugb24gdGhpcyBjZXJ0aWZpY2F0ZSBieSBhbnkgcGFydHkgYXNzdW1lcyBhY2NlcHRhbmNlIG9mIHRoZSB0aGVuIGFwcGxpY2FibGUgc3RhbmRhcmQgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdXNlLCBjZXJ0aWZpY2F0ZSBwb2xpY3kgYW5kIGNlcnRpZmljYXRpb24gcHJhY3RpY2Ugc3RhdGVtZW50cy4wMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL2NybC5hcHBsZS5jb20vd3dkcmc3LmNybDAdBgNVHQ4EFgQUskV9w0SKa0xJr25R3hfJUUbv+zQwDgYDVR0PAQH/BAQDAgeAMBAGCiqGSIb3Y2QGCwEEAgUAMA0GCSqGSIb3DQEBBQUAA4IBAQB3igLdpLKQpayfh51+Xbe8aQSjGv9kcdPRyiahi3jzFSk+cMzrVXAkm1MiCbirMSyWePiKzhaLzyg+ErXhenS/QUxZDW+AVilGgY/sFZQPUPeZt5Z/hXOnmew+JqRU7Me+/34kf8bE5lAV8Vkb5PeEBysVlLOW6diehV1EdK5F0ajv+aXuHVYZWm3qKxuiETQNN0AU4Ovxo8d2lWYM281fG2J/5Spg9jldji0uocUBuUdd0cpbpVXpfqN7EPMDpIK/ybRVoYhYIgX6/XlrYWgQ/7jR7l7krMxyhGyzAhUrqjmvsAXmV1sPpCimKaRLh3edoxDfYth5aGDn+k7KyGTLMIIEVTCCAz2gAwIBAgIUNBhY/wH+Bj+O8Z8f6TwBtMFG/8kwDQYJKoZIhvcNAQEFBQAwYjELMAkGA1UEBhMCVVMxEzARBgNVBAoTCkFwcGxlIEluYy4xJjAkBgNVBAsTHUFwcGxlIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRYwFAYDVQQDEw1BcHBsZSBSb290IENBMB4XDTIyMTExNzIwNDA1M1oXDTIzMTExNzIwNDA1MlowdTELMAkGA1UEBhMCVVMxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAsMAkc3MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKyu0dO2irEbKJWt3lFRTD8z4U5cr7P8AtJlTyrUdGiMdRdlzyjkSAmYcVIyLBZOeI6SVmSp3YvN4tTHO6ISRTcCGWJkL39hxtNZIr+r+RSj7baembov8bHcMEJPtrayxnSqYla77UQ2D9HlIHSTVzpdntwB/HhvaRY1w24Bwp5y1HE2sXYJer4NKpfxsF4LGxKtK6sH32Mt9YjpMhKiVVhDdjw9F4AfKduxqZ+rlgWdFdzd204P5xN8WisuAkH27npqtnNg95cZFIuVMziT2gAlNq5VWnyf+fRiBAd06R2nlVcjrCsk2mRPKHLplrAIPIgbFGND14mumMHyLY7jUSUCAwEAAaOB7zCB7DASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFCvQaUeUdgn+9GuNLkCm90dNfwheMEQGCCsGAQUFBwEBBDgwNjA0BggrBgEFBQcwAYYoaHR0cDovL29jc3AuYXBwbGUuY29tL29jc3AwMy1hcHBsZXJvb3RjYTAuBgNVHR8EJzAlMCOgIaAfhh1odHRwOi8vY3JsLmFwcGxlLmNvbS9yb290LmNybDAdBgNVHQ4EFgQUXUIQbBu7x1KXTkS9Eye5OhJ3gyswDgYDVR0PAQH/BAQDAgEGMBAGCiqGSIb3Y2QGAgEEAgUAMA0GCSqGSIb3DQEBBQUAA4IBAQBSowgpE2W3tR/mNAPt9hh3vD3KJ7Vw7OxsM0v2mSWUB54hMwNq9X0KLivfCKmC3kp/4ecLSwW4J5hJ3cEMhteBZK6CnMRF8eqPHCIw46IlYUSJ/oV6VvByknwMRFQkt7WknybwMvlXnWp5bEDtDzQGBkL/2A4xZW3mLgHZBr/Fyg2uR9QFF4g86ZzkGWRtipStEdwB9uV4r63ocNcNXYE+RiosriShx9Lgfb8d9TZrxd6pCpqAsRFesmR+s8FXzMJsWZm39LDdMdpI1mqB7rKLUDUW5udccWJusPJR4qht+CrLaHPGpsQaQ0kBPqmpAIqGbIOI0lxwV3ra+HbMGdWwMIIEuzCCA6OgAwIBAgIBAjANBgkqhkiG9w0BAQUFADBiMQswCQYDVQQGEwJVUzETMBEGA1UEChMKQXBwbGUgSW5jLjEmMCQGA1UECxMdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNVBAMTDUFwcGxlIFJvb3QgQ0EwHhcNMDYwNDI1MjE0MDM2WhcNMzUwMjA5MjE0MDM2WjBiMQswCQYDVQQGEwJVUzETMBEGA1UEChMKQXBwbGUgSW5jLjEmMCQGA1UECxMdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNVBAMTDUFwcGxlIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkkakJH5HbHkdQ6wXtXnmELes2oldMVeyLGYne+Uts9QerIjAC6Bg++FAJ039BqJj50cpmnCRrEdCju+QbKsMflZ56DKRHi1vUFjczy8QPTc4UadHJGXL1XQ7Vf1+b8iUDulWPTV0N8WQ1IxVLFVkds5T39pyez1C6wVhQZ48ItCD3y6wsIG9wtj8BMIy3Q88PnT3zK0koGsj+zrW5DtleHNbLPbU6rfQPDgCSC7EhFi501TwN22IWq6NxkkdTVcGvL0Gz+PvjcM3mo0xFfh9Ma1CWQYnEdGILEINBhzOKgbEwWOxaBDKMaLOPHd5lc/9nXmW8Sdh2nzMUZaF3lMktAgMBAAGjggF6MIIBdjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUK9BpR5R2Cf70a40uQKb3R01/CF4wHwYDVR0jBBgwFoAUK9BpR5R2Cf70a40uQKb3R01/CF4wggERBgNVHSAEggEIMIIBBDCCAQAGCSqGSIb3Y2QFATCB8jAqBggrBgEFBQcCARYeaHR0cHM6Ly93d3cuYXBwbGUuY29tL2FwcGxlY2EvMIHDBggrBgEFBQcCAjCBthqBs1JlbGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMgYWNjZXB0YW5jZSBvZiB0aGUgdGhlbiBhcHBsaWNhYmxlIHN0YW5kYXJkIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHVzZSwgY2VydGlmaWNhdGUgcG9saWN5IGFuZCBjZXJ0aWZpY2F0aW9uIHByYWN0aWNlIHN0YXRlbWVudHMuMA0GCSqGSIb3DQEBBQUAA4IBAQBcNplMLXi37Yyb3PN3m/J20ncwT8EfhYOFG5k9RzfyqZtAjizUsZAS2L70c5vu0mQPy3lPNNiiPvl4/2vIB+x9OYOLUyDTOMSxv5pPCmv/K/xZpwUJfBdAVhEedNO3iyM7R6PVbyTi69G3cN8PReEnyvFteO3ntRcXqNx+IjXKJdXZD9Zr1KIkIxH3oayPc4FgxhtbCS+SsvhESPBgOJ4V9T0mZyCKM2r3DYLP3uujL/lTaltkwGMzd/c6ByxW69oPIQ7aunMZT7XZNn/Bh1XZp5m5MkL72NVxnn6hUrcbvZNCJBIqxw8dtk2cXmPIS4AXUKqK1drk/NAJBzewdXUhMYIBsTCCAa0CAQEwgYkwdTELMAkGA1UEBhMCVVMxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAsMAkc3MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQIQLasDG73WZXPSByl5PESXxDAJBgUrDgMCGgUAMA0GCSqGSIb3DQEBAQUABIIBALLCLSfVOHUp6eGqTpZlbbFZGNzvpF6xaWu1GaPs7MwfGQwJgtyeelioXKum/l8MgxUarEH65pneXBh9bDt9cE3urob1+8yJ4UoxaPdWRerFVlMsuXaUkiosgHvuVpiqqUQNPzjE+4Vcq0BY93eF/Jj17q1Ms7MagPKWTVVNWA0OA76cUeUsxnb5MksWeyT+vYrVSXod7Mj+zNWGEPBF9g00Ip7Xt3DXbx4sMR2M4zLgZClWMMBXagthyex+2HbpzGikIbTk8okYek0HmT0+SMIMtRKcyqFHGtPhTa6W3wSfERrz6PEI/ct9ajbhGWYfxIh4a+D2B/LsxxKC1L77S0A=\n}\n```\n\n## 4、恢复购买\n\n**注意：恢复购买是针对【非消耗型】【自动续期订阅型】商品的。在客户端获取可恢复购买商品列表的时候，会返回该Apple ID购买过的【非消耗型】【自动续期订阅型】商品。其他类型商品，需要自己维护用户新旧设备、多个设备的权益同步。**\n\n**适用场景：假如用户在iPhone A购买了永久会员，然后换了新手机iPhone B，两台设备登录了同一个Apple ID，那么他可以在iPhone B使用恢复购买，把购买过的永久会员同步到新设备使用，即需要实现两个设备都可以使用永久会员功能。**\n\n#### 4.1、有账号体系的App\n\n恢复的购买商品与账号绑定，只要登录这个账号的设备都可以享受购买过的服务。可由App业务决定是否在一端登录账号后，其他端被迫下线，比如某个游戏的账号；也可像一些工具类行产品限制允许在线设备个数。\n\n#### 4.2、无账号体系的App\n\n无账号体系的App，可以在N个登录了购买过商品的Apple ID设备，点击使用恢复购买之后，享用同样的商品。\n\n无账号体系的App，建议创建【自动续期订阅】【非消耗型】商品，使用苹果自己的恢复购买来维护用户购买过的权益。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dfc47c54f8c456ab1c4aeee9254d8b4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 5、商品优惠促销（免费试用）\n\n**优惠促销是只支持续期订阅的商品，每个订阅群组只能享受一个推介促销优惠，推介促销优惠适用于运行 iOS 10、Apple TVOS 10 和 macOS 10.12.6 及更高版本的用户。**\n\n### **5.1、促销优惠类型**\n\n| 类型 | 适用人群 | 公司SDK是否已支持 | 收费方式 | 备注 |\n| --- | --- | --- | --- | --- |\n| 订阅价格 | 现已订阅或之前订阅过该群组商品的用户 | 支持 | 订阅时按订阅价格收费 | 已接收过推介促销优惠的，仍可享受订阅价格优惠兼容版本iOS12.2+ |\n| 推介促销优惠 | 未享受过该订阅群组当前促销的用户 | 支持 | 促销期内，按促销价收费，促销期过后，按原价收费。 | 兼容版本iOS10+ |\n| 优惠代码 | 所有用户 | 不支持 |  |  |\n| 促销优惠 | 所有用户 | 支持 |  |  |\n\n### 5.2、优惠支付类型\n\n| 支付类型 | 说明 | 示例 |\n| --- | --- | --- |\n| 随用随付 | 用户将按选定时限的每个结算周期支付折扣价格 | 例如，订阅的标准价格为9.99美元，折扣价为前3个月每月1.99美元)。可设定以下时限:。1周订阅，1至12周。1个月订阅，1至12个月。2个月订阅，2、4、6、8、10和12个月。3个月订阅，3、6、9和12个月。6个月订阅，6和12个月。1年订阅，1年 |\n| 提前支付 | 用户将一次性支付选定时限的折扣价格 | 例如，订阅的标准价格为9.99美元，折扣价为前2个月199美元)。可设定以下时限:1个月、2个月、3个月、6个月、1年 |\n| 免费 | 顾客在选定的时限内免费 | 例如：免费试用时限可以是3天，1周，2 周、1个月、2个月、3个月、6个月或1年。一个月的免费试用在28到31天不等。 |\n\n### 5.3、增加促销优惠\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d683306c304b05bc555cd5971ca69d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a541080475b845e1bb06ec725c2a2e70~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2b9496fce7445d9b1e2c542ed52132~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62db008d282040deac281afbc5234127~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557e8402722148ff91304ce9e60c182d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n**促销优惠商品购买视图，有免费试用等字样，并注明首次扣费日期；**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16e12b1be9f14be695074ce8918ebe3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n### 5.4、促销优惠测试\n\n**沙盒账号：需要一个没有购买过当前优惠促销商品的沙盒测试账号，或者购买过的账号需要去手机【设置】-【App Store】- 沙盒账号【管理】-【重设优惠资格】**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4db0216c0e49998da3b6b035f41b93~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d405368d40044fc392dcaefefa29182d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 6、退款\n\n[退款申请地址](https://link.juejin.cn/?target=https%3A%2F%2Freportaproblem.apple.com%2F \"https://reportaproblem.apple.com/\")，退款申请可申请半年内的付费订单\n\n**用户可以就已经购买的项目发起退款，我们需要在** **[appstoreconnect.apple.com/](https://link.juejin.cn/?target=https%3A%2F%2Fappstoreconnect.apple.com%2F \"https://appstoreconnect.apple.com/\")** **后台，App信息处，配置退款的回调地址，回调处理逻辑由后端人员接入**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55c1273da60f4fe7babe9353c11e40a1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n**『消耗型』『非消耗型』『非续期订阅型』退款：**\n\n**[Apple官方退款文档\\[后端技术人员接入\\]](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fdocumentation%2Fstorekit%2Fin-app_purchase%2Fhandling_refund_notifications%2F \"https://developer.apple.com/cn/documentation/storekit/in-app_purchase/handling_refund_notifications/\")**\n\n**『订阅型』退款：**\n\n**[Apple官方退款文档\\[后端技术人员接入\\]](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fstorekit%2Fin-app_purchase%2Foriginal_api_for_in-app_purchase%2Fsubscriptions_and_offers%2Fhandling_subscriptions_billing%3Flanguage%3Dobjc \"https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/handling_subscriptions_billing?language=objc\")**\n\n## 三、上架\n\n### 1、首次增加内购上架\n\n首次增加内购产品，内购商品需要勾选和包一同提交审核\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3cc617d03a4b02a61be2f606f34d85~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc86c1bc6c24772a57e381a7a48b4c8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n### 2、非首次增加内购上架\n\n非首次增加内购产品，可以在【订阅】【App内购买项目】中创建完产品，提交审核\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a87f0364a54d3fbb7bf6a78c2ebb16~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n### 3、内购拒审反馈\n\n①、提审包含【非消耗型】商品的，必须在购买页面上展示『恢复购买』按钮，并实现其功能。\n\n#### ②、Guideline 2.1\n\n##### 提审时，只有有非续期订阅型商品（不支持恢复购买，UI界面上没有恢复购买功能的）可增加一段关于这些商品，如何管理、恢复这些用户购买的权益。否则容易收到Apple的审核邮件反馈:\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e2ec042c142444aaa62f0e0e1d49e48~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n③、在Apple商品创建的后台，商品截图上的信息，价格，购买的权益，必须与App内展示的一致。不要后台配置了价格下发，让Apple审核人员看到价格都不一样，不行。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbb9b7cd8674919a5a0083f8b643e40~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n#### ④、Guideline 3.1.2\n\n##### 提审时商品里有订阅型商品、促销优惠：\n\n##### 1、需要标注促销内容，和促销期过后怎么收费，比如：当用户选到某个促销商品时，需要展示文案：前3天免费试用，试用结束后续费订阅99元/年，可随时取消订阅。确保优惠按钮从属文案里必须有优惠结束后自动扣费标准。\n\n比如：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/005513a73b38483a83a133f7baabf2ad~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac9be41931114c90b9c90422283cf27e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n##### 2、在页面上展示隐私协议、会员协议、自动续费协议，协议内和应用描述文案里需要包含（也可以参考腾讯、爱奇艺那些App）：\n\n自动订阅服务说明\n\n（1）订阅服务：xxxxVIP连续包月(1个月)、xxxx VIP连续包年(12个月)\n\n（2）订阅价格：xxxxVIP连续包月(1个月)为每月19.8元，连续包年产品为30元/年，具体价格会根据不同期活动优惠调整，以应用内实际展示为准\n\n（3）付款：用户确认购买并付款后计入iTunes账户\n\n（4）自动续费：苹果iTunes账户会在到期前24小时内扣费，扣费成功后订阅周期顺延一个订阅周期\n\n（5）关闭服务：您可以在苹果手机“设置”-->进入“iTunesStore与AppStore”-->点击“AppleID”选择\"查看AppleID\"，进入\"账户设置\"页面，点击“订阅”，管理自动订阅服务，如需取消，每个计费周期结束前24小时关闭即可，到期前24小时内则不再扣费\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6527ff252f4245fdbb8fc3b0dc650265~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\n\n## 8、资料参考\n\n[苹果官方文档-内购](https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fyuqueyonghumlekys%2Faqphhl%2Fkns21e58luymrd7r%23SSzH4 \"https://www.yuque.com/yuqueyonghumlekys/aqphhl/kns21e58luymrd7r#SSzH4\")\n\n> 希望帮助到有需要的童孩~\n\n![6af89bc8gw1f8qjnvszvmj20b40b4mxc.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa50beecc5354b71bc4ade43f4f6dda6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)', 'public/uploads/1694331196044.png', 5, 6, 1, 622, '2023-09-10 07:40:59', 1);
INSERT INTO `article` VALUES (67, 7, 'Mr.', 'Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. It wasn’t raining when Noah built the ark. The Synchronize to Database function will give you a full picture of all database differences. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. The On Startup feature allows you to control what tabs appear when you launch Navicat. Creativity is intelligence having fun. Typically, it is employed as an encrypted version of Telnet. Secure Sockets Layer(SSL) is a protocol for transmitting private documents via the Internet.', '', 1, 3, 1, 675, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (68, 2, '啥是马甲包？啥又是苹果4.3被拒？', '### 前言\n\n一个合格的iOSer如果你没有听过马甲包，那么证明你不是一个经常上次的老iOSer。当然除非你的公司十分正规，不屑于用这种违背iOS准则的方式。\n\n### 产品型马甲包\n\n**那啥是马甲包呢？**\n\n**高情商：App矩阵**\n\n**低情商：App套壳**\n\n**马甲包**本质对一个主产品A进行克隆，原地再生成一个产品B，自己抄自己作业。再直接点来说，干了一件原地复制、粘贴的Control + C/V 操作。\n\n**那啥图啥呢？**\n\n一般小一点创业公司或者是在公司想降低ASO运营的成本就会采用这种简单粗暴的方式。它虽然不符合苹果机制，但本质上可以快速的帮助公司占领流量风口。\n\n举个例子，在Appstore最火的产品莫过于Chat-GPT。在点点数据上可以轻松查到 **Chat-GPT** 关键词下的产品。那么如果前10名里，其中3个产品都是你所在公司呢？快乐直接 \\* 3。可以轻松的为公司以最快的方式获取到流量。\n\n也就是所谓的**二八法则**，20%的产品掌握着80%的流量密码！与其费尽心机的挤进前三，倒不如苟活于第四第五，依旧可以保持较好的流量来源。说的通俗一点，比如你和别人打架，你一个人对面10个人。但是对面10个人里还有5个是你的人，那胜率岂不是直接拉高？商场如战场，关键词带来流量争夺是必经之路。\n\n![chat gdp.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a86c2346362a4b4c8fd6a4bbbd786c01~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**别的还有啥用呢？**\n\n马甲包还有很多其他的作用，除了对于刚刚提到流量Buffer，还有抗风险性、AB测属性。Appstore的规则是不断更新了尤其是在机审方面，算法不断加强。在人工审核方面也经常出现多样性，比如昨天过审了，今天再次提交反手调查你；又或者相同的名字或者描述，昨天过审了今天给你来一个1.1.6不够精准的元数据。\n\n而对于公司来讲，时间不等人。不可能给开发人员大量的时间花费在苹果审核上。这个时候，就体现B产品的必要性。主打的就是一个 **你行不行啊，细狗？你不行我上** 的节奏。用最快的时间来支持公司运营的工作。\n\n以上所阐述的是相对正规一点的马甲包，我习惯称这种包为子母包。\n\n### 功能型马甲包\n\n如果说刚刚的马甲包出发点存在违背苹果开发者准则的行为，但本质出发点还是可以理解和接受的。另外一种就是功能性马甲包，这种马甲包就是背离开发者准则的行为，意图在于通过**隐藏功能**或者**AB面**的方式通过审核。 通俗的来说：**挂羊头卖狗肉！** 在通过审核后大肆打榜，刷量。如果有些名字奇怪页面简陋，但是突然霸占榜首的产品，那么有一定概率它就是！\n\n这种行为常见于灰色产品，希望各位iOSer开发不要踩线。要做一个遵纪守法的iOSer，对于游走在灰色边缘的产品及时说不！学会拒绝，也是对自己最好的保护。\n\n### 啥又是苹果4.3被拒呢？\n\n先上苹果回复4.3模板原文\n\n```\nHello,\n\nThank you for your resubmission. Upon further review, we identified an additional issue that needs your attention. See below for more information.\nIf you have any questions, we are here to help. Reply to this message in App Store Connect and let us know. \n\nGuideline 4.3 - Design\nWe noticed that your app provides the same feature set as other apps submitted to the App Store; it simply varies in content or language, which is considered a form of spam.\n\nThe next submission of this app may require a longer review time.\n\nNext Steps\n- Review the Design section of the App Store Review Guidelines.\n- Ensure your app is compliant with all sections of the App Store Review Guidelines and the Terms & Conditions of the Apple Developer Program.\n- Once your app is fully compliant, resubmit your app for review.\nWhen creating multiple apps where content is the only varying element, you should offer a single app to deliver differing content to customers. If you would like to offer this content for purchase, it would be appropriate to use the in-app purchase API.\n\nAlternatively, you may consider creating a web app, which looks and behaves similar to a native app when the customer adds it to their Home screen. Refer to the Configuring Web Applications section of the Safari Web Content Guide for more information.\nSubmitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review the Terms & Conditions of the Apple Developer Program to learn more about our policies regarding termination.\n\n```\n\n对于每一个iOSer没有一次提交审核不如同渡劫一般，尤其是看到 **Guideline 4.3 - Design** 直接就是一个痛苦面具。\n\n![痛苦面具.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a08f067dfd0461ea15209a989eec534~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n**复杂来说：** 你的App在Appstore已经足够多了，苹果市场不再需要这类型的产品。这种情况下，基本上无解，要么在创意和设计上具有独特性，要么就可以考虑跑路了。 毕竟在IT行业有一句俗语：**代码和人有一个能跑就行！**\n\n**简单来说：** 你需要推翻了重新来过，无论是在视觉上还是代码层面上。\n\n最后希望iOSer大吉大利，今晚过包！关注公众号：iOS研究院，了解更多过审技巧。', 'public/uploads/1694329805121.png', 3, 4, 0, 10, '2023-09-10 07:10:06', 1);
INSERT INTO `article` VALUES (69, 4, '大专前端，三轮面试，终与阿里无缘', '因为一些缘故，最近一直在找工作，再加上这个互联网寒冬的大环境，从三月找到六月了，一直没有合适的机会\n\n> 先说一下背景，目前三年半年经验，base 杭州，大专学历+自考本科\n\n就在前几天，Boss 上收到了阿里某个团队的投递邀请（具体部门就不透露了），因为学历问题，基本上大厂简历都不会通过初筛，但还是抱着破罐子破摔的心态投递给了对方，出乎意料的是简历评估通过了，可能是因为有两个`开源项目`和一个`协同文档`加分吧。\n\n### 进入到面试环节，首先是两道笔试题，算是前置面试：\n\n#### 第一道题目是算法题：\n\n提供了一个数组结构的 data，要求实现一个 `query` 方法，返回一个新的数组，query 方法内部有 `过滤`、`排序`、`分组` 等操作，并且支持链式调用，调用最终的 `execute` 方法返回结果：\n\n```\nconst result = query(list)\n  .where(item => item.age > 18)\n  .sortBy(\'id\')\n  .groupBy(\'name\')\n  .execute();\n\nconsole.log(result);\n```\n\n具体实现这里就不贴了，过滤用原生的数组 `filter` 方法，排序用原生的数组 `sort` 方法，分组需要手写一下，类似 `lodash/groupBy` 方法。\n\n过滤和排序实现都比较顺利，在实现分组方法的时候不是很顺利，有点忘记思路了，不过最后还是写出来了，关于链式调用，核心是只需要在每一步的操作最后返回 `this` 即可。\n\n#### 第二道题目是场景题：\n\n要求用 vue 或者 react 实现一个倒计时抢券组件，页面加载时从 10s 开始倒计时，倒计时结束之后点击按钮请求接口进行抢券，同时更新文案等等功能。因为我对 react 比较熟悉一点，所以这里就选择了 react。\n\n涉及到的知识点有 hook 中对 `setTimeout` 的封装、`异步请求`处理、`状态更新`、`CSS基本功` 的考察等等……\n\n具体实现这里也不贴了，写了一堆自定义 hook，因为平时也在参与 `ahooks` 的维护工作，`ahooks` 源码背的滚瓜烂熟，所以直接搬过来了，这道题整体感觉没啥难度，算是比较顺利的。\n\n笔试题整个过程中唯一不顺利的是在线编辑器没有类似 vscode 这样的 `自动补全` 功能，不管是变量还是保留字，很多单词想不起来怎么拼写，就很尴尬，英文太差是硬伤 :(\n\n笔试过程最后中出现了一点小插曲，因为笔试有时间限制，需要在规定的时间内完成，但是倒计时还没结束，不知道为什么就自动交卷了，不过那个时候已经写的差不多了，功能全部实现了，还剩下卡片的样式没完成，css 还需要完善一下，于是就在 Boss 上跟对方解释了一下，说明了情况。\n\n过了几分钟，对面直接回复笔试过了，然后约了面试。\n\n### 一面：\n\n-   自我介绍\n    \n    这里大概说了两分钟，介绍了过往工作经历，做过的业务以及技术栈。\n    \n-   七层网络模型、和 DNS 啥的\n    \n    计网这方面属于知识盲区了，听到这个问题两眼一黑，思索了一会儿，直接说回答不上来。\n    \n-   然后问了一些 host 相关的东西\n    \n    -   很遗憾也没回答上来，尴尬。对方问我是不是计算机专业的，我坦诚的告诉对方是建筑工程。\n-   React 代码层的优化可以说一下么？\n    \n    -   大概说了 `class` 组件和 `function` 组件两种情况，核心是通过减少渲染次数达到优化目的，具体的优化手段有 `PureComponent`、`shouldComponentUpdate`、`React.memo`、`React.useMemo`、`React.useCallback`、`React.useRef` 等等。\n-   说一下 `useMemo` 和 `useCallback` 有什么区别\n    \n    -   很基础的问题，这里就不展开说了。\n-   说一下 `useEffect` 和 `useLayoutEffect` 有什么区别\n    \n    -   很基础的问题，这里就不展开说了。\n-   问了一下 `useEffect` 对应在 class 中都生命周期怎么写？\n    \n    -   很基础的问题，这里就不展开说了。\n-   如果在 if 里面写 `useEffect` 会有什么表现？\n    \n    -   开始没听清楚，误解对方的意思了，以为他说的是在 useEffect 里面写 if 语句，所以胡扯了一堆，后面对方纠正了一下，我才意识到对方在问什么，然后回答了在条件语句里面写 useEffect 控制台会出现报错，因为 hook 的规则就是不能在`条件语句`或者`循环语句`里面写，这点在 react 官方文档里面也有提到。\n-   说一下 React 的 `Fiber` 架构是什么\n    \n    -   这里说了一下 `Fiber` 本质上就是一个对象，是 `React 16.8` 出现的东西，主要有三层含义：\n        \n        1.  作为架构来说，在旧的架构中，Reconciler（协调器）采用递归的方式执行，无法中断，节点数据保存在递归的调用栈中，被称为 Stack Reconciler，stack 就是调用栈；在新的架构中，Reconciler（协调器）是基于 fiber 实现的，节点数据保存在 fiber 中，所以被称为 fiber Reconciler。\n            \n        2.  作为静态数据结构来说，每个 fiber 对应一个组件，保存了这个组件的类型对应的 dom 节点信息，这个时候，fiber 节点就是我们所说的虚拟 DOM。\n            \n        3.  作为动态工作单元来说，fiber 节点保存了该节点需要更新的状态，以及需要执行的副作用。\n            \n        \n        （这里可以参考卡颂老师的《自顶向下学 React 源码》课程）\n        \n-   前面提到，在 if 语句里面写 hook 会报错，你可以用 fiber 架构来解释一下吗？\n    \n    -   这里说了一下，因为 fiber 是一个对象，多个 fiber 之间是用链表连接起来的，有一个固定的顺序…… 其实后面还有一些没说完，然后对方听到这里直接打断了，告诉我 OK，这个问题直接过了。\n-   个人方面有什么规划吗？\n    \n    -   主要有两个方面，一个是计算机基础需要补补，前面也提到，我不是科班毕业的，计算机底层这方面比起其他人还是比较欠缺的，尤其是计网，另一方面就是英文水平有待提高，也会在将来持续学习。\n-   对未来的技术上有什么规划呢？\n    \n    -   主要从业务转型工程化，比如做一些工具链什么的，构建、打包、部署、监控几个大的方向，node 相关的，这些都是我感兴趣的方向，未来都可以去探索，当然了现在也慢慢的在做这些事情，这里顺便提了一嘴，antd 的 script 文件夹里面的文件是我迁移到 esm + ts 的，其中一些逻辑也有重构过，比如收集 css token、生成 contributors 列表、预发布前的一些检查等等…… 所以对 node 这块也有一些了解。\n-   能不能从技术的角度讲一下你工作中负责业务的复杂度？\n    \n    -   因为前两份工作中做的是传统的 B 端项目和 C 端项目，并没有什么可以深挖的技术难点，所以这里只说了第三份工作负责的项目，这是一个`协同文档`，既不算 B 端，也不算 C 端，这是一款企业级的多人协作数据平台，竞品有腾讯文档、飞书文档、语雀、WPS、维卡表格等等。\n        \n        协同文档在前端的难点主要有两个方面：\n        \n        1.  实时协同编辑的处理：当两个人同时进入一个单元格编辑内容，如果保证两个人看到的视图是同步的？那么这个时候就要提到`冲突处理`了，冲突处理的解决方案其实已经相对成熟，包括：\n            \n            -   编辑锁：当有人在编辑某个文档时，系统会将这个单元格锁定，避免其他人同时编辑，这种方法实现方式最简单，但也会直接影响用户体验。\n                \n            -   diff-patch：基于 Git 等版本管理类似的思想，对内容进行差异对比、合并等操作，也可以像 Git 那样，在冲突出现时交给用户处理。\n                \n            -   最终一致性实现：包括 Operational Transformation（OT）、 Conflict-free replicated data type（CRDT，称为无冲突可复制数据类型）。\n                \n        2.  性能问题\n            \n            -   众所周知，互联网一线大厂的协同文档工具都是基于 `canvas` 实现，并且有一套自己的 `canvas 渲染引擎`，但是我们没有，毕竟团队规模没法跟大厂比，这个项目前端就 2 个人，所以只能用 `dom` 堆起来（另一个同事已经跑路，现在就剩下我一个人了）。这导致页面卡顿问题非常严重，即使做了`虚拟滚动`，但是也没有达到很好的优化效果。老板的要求是做到十万量级的数据，但是实际上几千行就非常卡了，根本原因是数据量太大（相当于一张很大的 `Excel 表格`，里面的每一个单元格都是一个`富文本编辑器`），渲染任务多，导致内存开销太大。目前没有很好的解决方案，如果需要彻底解决性能问题，那么就需要考虑用 `canvas` 重写，但是这个基本上不太现实。\n                \n            -   因为卡顿的问题，暴露出来另一个问题，状态更新时，视图同步缓慢，所以这时候不得不提到另一个优化策略：`乐观更新`。乐观更新的思想是，当用户进行交互的时候，先更新视图，然后再向服务端发送请求，如果`请求成功`，那么`什么都不用管`，如果`请求失败`，那么就`回滚视图`。这样做的好处是，用户体验会好很多，在一些强交互的场景，不会阻塞用户操作，比如抖音的点赞就是这样做的。但是也会带来一些问题，比如：如果用户在编辑某个单元格时，另一个用户也在编辑这个单元格，那么就会出现冲突，这个时候就需要用到前面提到的冲突处理方案了。\n                \n-   可以讲一下你在工作中技术上的建设吗？\n    \n    -   这里讲了一下对 `hooks` 仓库的建设，封装了 100 多个`功能 hook` 和 `业务 hook`，把`不变的部分`隐藏起来，把`变化的部分`暴露出去，在业务中无脑传参即可，让业务开发更加简单，同时也提高了代码的复用性。然后讲了一下数据流重构之类的 balabala……\n-   你有什么想问我的吗？\n    \n    -   问了一下面试结果大概多久能反馈给我，对方说两三天左右，然后就结束了。\n\n> 结束之后不到 20 分钟，对方就在 Boss 上回复我说面试过了，然后约了二面。\n\n### 二面：\n\n-   自我介绍\n    \n    -   跟上一轮一样，大概说了两分钟，介绍了过往工作经历，做过的业务以及技术栈。\n-   在 js 中原型链是一个很重要的概念，你能介绍一下它吗？\n    \n    -   要介绍原型链，首先要介绍一下原型，原型是什么…… 这块是纯八股，懒得打字了，直接省略吧。\n-   object 的原型指向谁？\n    \n    -   回答了 `null`。（我也不知道对不对，瞎说的）\n-   能说一下原型链的查找过程吗？\n    \n    -   磕磕绊绊背了一段八股文，这里省略吧。\n-   node 的内存管理跟垃圾回收机制有了解过吗？\n    \n    -   暗暗窃喜，这个问题问到点子上了，因为两年前被问到过，所以当时专门写了一篇文章，虽然已经过去两年了，但还是背的滚瓜烂熟：\n        \n    -   首先分两种情况：V8 将内存分成 `新生代空间` 和 `老生代空间`\n        \n        -   新生代空间: 用于存活较短的对象\n            \n            -   又分成两个空间: from 空间 与 to 空间\n                \n            -   Scavenge GC 算法: 当 from 空间被占满时，启动 GC 算法\n                \n                -   存活的对象从 from space 转移到 to space\n                -   清空 from space\n                -   from space 与 to space 互换\n                -   完成一次新生代 GC\n        -   老生代空间: 用于存活时间较长的对象\n            \n            -   从 `新生代空间` 转移到 `老生代空间` 的条件（这个过程称为`对象晋升`）\n                \n                -   经历过一次以上 Scavenge GC 的对象\n                -   当 to space 体积超过 25%\n            -   标记清除算法：标记存活的对象，未被标记的则被释放\n                \n                -   增量标记：小模块标记，在代码执行间隙执，GC 会影响性能\n                -   并发标记：不阻塞 js 执行\n-   js 中的基础类型和对象类型有什么不一样？\n    \n    -   基础类型存储在栈中，对象类型存储在堆中。\n-   看你简历上是用 React，你能简单的介绍一下 hooks 吗？\n    \n    -   本质上就是一个纯函数，大概介绍了一下 hooks 的优点，以及 hooks 的使用规则等等。\n-   简单说一下 `useEffect` 的用法：\n    \n    -   useEffect 可以代替 class 中的一些生命周期，讲了一下大概用法，然后讲了一下 useEffect 的执行时机，以及 deps 的作用。\n-   说一下 `useEffect` 的返回值用来做什么？\n    \n    -   返回一个函数，用来做清除副作用的工作，比如：`清除定时器`，`清除事件监听`等等。\n-   你知道 `useEffect` 第二个参数内部是怎么比较的吗？\n    \n    -   说了一下内部是浅比较，源码中用 `for` 循环配合 `Object.is` 实现。（感觉这个问题就是在考察有没有读过 React 源码）\n-   前端的话可能跟`网络`打交道比较多，网络你了解多少呢？\n    \n    -   这里直接坦诚的说了一下，网络是我的弱项，前面一面也问到了网络七层模型，没回答出来。\n-   那你回去了解过七层模型吗？我现在再问你一遍，你能回答出来吗？\n    \n    -   磕磕绊绊回答出来了。\n-   追问：`http` 是在哪一层实现的？\n    \n    -   应用层。\n-   说一下 `get` 跟 `post` 有什么区别？\n    \n    -   两眼一黑，脑子一片空白，突然不知道说什么了，挤了半天挤出来一句：`get` 大多数情况下用来查询，`post` 大多数情况下用来提交数据。get 的入参拼在 `url` 上，post 请求的入参在 `body` 里面。面试官问我还有其它吗？我说想不起来了……\n-   说一下浏览器输入 url 到页面加载的过程：\n    \n    -   输入网址发生以下步骤：\n        \n        1.  通过 `DNS` 解析域名的实际 `IP 地址`\n        2.  检查浏览器是否有`缓存`，命中则直接取本地磁盘的 `html`，如果没有命中强缓存，则会向服务器发起请求（先进行下一步的 TCP 连接）\n        3.  若`强缓存`和`协商缓存`都没有命中，则返回请求结果\n        4.  然后与 WEB 服务器通过`三次握手`建立 TCP 连接。期间会判断一下，若协议是 `https` 则会做加密，如果不是，则会跳过这一步\n        5.  加密完成之后，浏览器发送请求获取页面 html，服务器响应 html，这里的服务器可能是 `server`、也可能是 `cdn`\n        6.  接下来是浏览器解析 `HTML`，开始渲染页面\n    -   顺便说了渲染页面的过程：\n        \n        1.  浏览器会将 HTML 解析成一个 `DOM 树`，DOM 树的构建过程是一个`深度遍历`过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n        2.  将 CSS 解析成 `CSS Rule Tree`（css 规则树）。\n        3.  解析完成后，浏览器引擎会根据 `DOM 树`和 `CSS 规则树`来构造 `Render Tree`。（注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像 `Header` 或 `display:none` 的东西就没必要放在渲染树中了。）\n        4.  有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的`从属关系`。下一步进行 `layout`，进入布局处理阶段，即计算出每个节点在屏幕中的位置。\n        5.  最后一个步骤就是`绘制`，即遍历 RenderTree，层绘制每个节点。根据计算好的信息绘制整个页面。\n    -   渲染完成之后，开始执行其它任务：\n        \n        1.  dom 操作\n        2.  ajax 发起的 http 网络请求等等……\n        3.  浏览器处理事件循环等异步逻辑等等……\n-   菜单左中右布局，两边定宽，中间自适应，说一下有几种实现方式\n    \n    -   比较经典的面试题，说了 `flex` 和 `float` 两种方式。\n-   项目难点\n    \n    -   和一面一样，说了`协同文档`的两大难点，这里就不重复了。\n-   你有什么想问我的吗？\n    \n    -   和一面一样，问了一下面试结果大概多久能反馈给我，对方说两三天左右，然后就结束了。\n-   最后问了期望薪资什么的，然后就结束了。\n    \n\n二面结束之后，大概过了几个小时，在 Boss 上跟对方说了一声，如果没过的话也麻烦跟我说一下，然后这时候，对方在 Boss 上问我，第一学历是不是专科？我说是的，感觉到不太妙的样子，\n\n然后又过了一会儿，对方说定级应该不会高，他后续看一下面试官的反馈如何……\n\n然后又追问我，换工作的核心诉求是`涨薪`还是`能力的提升`，这里我回答的比较委婉，其实两个都想要 QAQ\n\n**今天已经是第二天了，目前没有下文，看起来二面是过了，但是因为学历不够，中止了三面的流程，基本上是失败了，我也不会报有什么希望了，所以写个面经记录一下。**\n\n### 最后，给自己打个广告！求职求职求职！！！\n\n#### 社交信息：\n\n-   GitHub：[github.com/li-jia-nan](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fli-jia-nan \"https://github.com/li-jia-nan\")\n-   掘金：[juejin.cn/user/782508…](https://juejin.cn/user/782508010775198/posts \"https://juejin.cn/user/782508010775198/posts\")\n\n#### 个人优势：\n\n-   `antd` 团队成员、`ahooks` 团队成员，活跃于 `github` 开源社区，给众多知名大型开源项目提交过 PR，拥有丰富的 `React` + `TS` 实战经验\n-   熟悉前端`性能优化`的实现，例如代码优化、打包优化、资源优化，能结合实际业务场景进行优化\n-   熟悉 `webpack` / `vite` 等打包工具的基本配置， 能够对以上工具进行二次封装、基于以上工具搭建通用的开发环境\n-   熟悉 `prettier` / `eslint` 基本配置，有良好且严格的编码习惯，唯客户论，实用主义者\n-   熟悉代码开发到上线全流程，对`协同开发`，`分支管理`，`项目配置`等都有较深刻的最佳实践\n\n> 可内推的大佬们麻烦联系我！在 `github 主页`有联系方式，或者直接在掘金私聊我也可，谢谢！！', 'public/uploads/1694330374231.png', 2, 3, 0, 273, '2023-09-10 07:19:38', 1);
INSERT INTO `article` VALUES (70, 4, 'TS 入门完全指南', '> 作者：**[xixixiaoyu](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxixixiaoyu \"https://github.com/xixixiaoyu\")**\n\n## TS 类型基本用法\n\n## TS简介\n\n-   TypeScript，简称 TS， 是一种由微软开发的编程语言，它是对 JavaScript 的一个增强\n-   让我们更加方便地进行类型检查和代码重构，提高代码的可靠性和可维护性\n-   同时，TypeScript 还支持 ECMAScript 的最新特性\n\n## 搭建学习环境\n\n进入 Node 官网安装 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69cd963b0d904e89a060130b9ed799c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 安装完成后使用以下命令查看是否安装完成： 安装完成后使用以下命令查看是否安装完成：\n\n-   `node -v`\n-   `npm -v`\n\n继续安装 nrm 管理包源：\n\n-   `npm i nrm -g`\n-   `nrm ls`\n-   `nrm use taobao`\n\n全局安装 typescript：\n\n-   `npm i typescript -g`\n\n全局安装 ts 的编译工具，使用 ts-node 可以将 ts 文件执行\n\n-   `npm i ts-node -g`\n    -   使用：`ts-node index.ts`\n-   安装 ts-node 依赖包：`npm install tslib @types/node -g`\n\n使用 TS 可以有良好的提示，使代码可读性变强，更提前发现问题\n\n___\n\n## TS 类型\n\n-   TS 出现弥补的 JS 的类型缺失\n-   众所周知，代码错误越早发现越好，`代码编写 > 代码编译 > 代码运行` `开发 > 测试 > 上线`\n-   Vue2 使用 `Flow` 进行类型检查，后续 Vue3 也使用 `Typescript` 重写\n-   TS 代码要运行在浏览器，需要进行类型擦除，转换为 JS 代码\n-   TS 类型包含所有 JS 类型 null、undefined、string、number、boolean、bigInt、Symbol、object（数组，对象，函数，日期）\n-   还包含 void、never、enum、unknown、any 以及 自定义的 type 和 interface\n\n### 变量声明\n\n-   `var/let/const 标识符: 数据类型 = 赋值`\n\n手动指定数据的类型（类型注解），不要写成大写的 `String` ，因为这是 JS 的一个内置类 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f8a4b3688c4a9699b68e5bf01ab47c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 变量类型定义的时候已经决定 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a7c39ab9bc42cc915e02d42b394518~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 类型推导\n\n-   如果没有明确指定类型，TS 会隐式的推导出一个类型\n-   这类型根据赋值的类型推断，没有赋值则为 `any` 类型，能自动推导出类型，没必要手动指定\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128a4daea7a2407b936550a309cec9fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50c51e1b7f3f4d3c84631c2f91595fd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 基础类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b535c2dcabf4e9cbc04bd4ae3388069~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 数组和元组\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a6d57a3e7ca4ecdb60147f366c95576~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   tuple可以作为函数返回的值，React 的 useState 就是个元组，类似于\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0461fc55d7d2482f8e4191af5e65975a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 对象类型\n\n-   TS 中的 object 类型泛指所有的的非原始类型，如对象、数组、函数\n-   下面我们使用 object 声明了这个对象，但是这个对象既不能设置新数据，也不能修改老数据\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83f14883970e44c6957370384e994057~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   下面这种对象类型的限制才更为精确\n-   可限制对象每个属性的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a181faeb76b46a8ad12af10e1cf23a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### any、unknown、never\n\n-   无法确定一个变量的类型，可使用 `any`，此时在其身上做任何操作都是合法的，即使访问了一个不存在的属性\n-   如果某些情况处理类型过于繁琐，或者在引入一些第三方库时，缺失了类型注解，这个时候 我们可以使用 any，更多是为了兼容老代码\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dcac69dbfb94845ac7050076d30e477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 如果想要 msg 不标注 any，默认也是 any 类型，但如果我们不想这种隐式的 any，可以新建 `tsconfig.json`，书写以下配置： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33dd921be9f142488cdeef3bffd0dc62~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   `unknown` 类型表示一个值可以是任何类型，它是所有类型的父类型，任何类型都可以赋值给 unknown 类型，但是 unknown 类型只能赋值给 any 类型和 unknown 类型本身\n-   类似 `any`，与 `any` 类型不同的是，`unknown` 类型的变量不能直接赋值给其他类型的变量，也不能调用其上的任何方法或属性，除非先进行类型检查或类型断言，这样确保运行时的类型安全\n-   默认在其操作都是不合法的，主要是在编写通用代码时，例如编写库或框架时，需要处理来自不同来源的数据，但又不确定数据的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd58df10c465450484dd24293bf57dce~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   假如一个函数的返回结果是死循环或者异常，我们可以使用 `never` 类型表示这种永不存在值的类型\n-   它是一个底层类型，不是任何类型的子类型，也没有任何子类型\n-   更多情况是封装工具库时候可以使用，比如下面这段代码，如果单纯在函数参数的类型多加一个参数，而没有对应 `case` 处理，则会报错\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50244db357624ea99d09fb08944aa256~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) `never` 会在联合类型被直接移除 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e254d6504a8d4908a17ffad6d83ea83d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 函数类型\n\n-   声明函数时，可以在每个参数后添加类型注解，声明其参数类型\n-   同样也可以声明返回值的类型，不过也可以不写让 TS 自动推导\n-   函数参数的一般顺序 必传参数 - 有默认值的参数 - 可选参数\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab7763527888430ba07accc8d39c860e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 枚举类型\n\n-   枚举类型将一组可能出现的值，一个个列举，定义在一个类型中，这个类型就是枚举\n\n## ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9cdb08105549069150b4f711ec54ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 这种字符串的枚举可能使用 `type Direction = \'LEFT\' | \'RIGHT\' | \'TOP\' | \'RIGHT\'`可能会更好点 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af4deec087248efa96918ee15eceb05~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## interface 和 type\n\n### 基本使用\n\n-   使用 interface 定义接口，使用 type 定义类型别名\n-   都可以约束对象的结构\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32f5231f9e14aaab198ecfc301aa567~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 区别\n\n1.  interface 只描述对象，type 则可以描述所有数据\n2.  interface 使用 extends 来实现继承，type 使用 & 来实现交叉类型\n3.  interface 会创建新的类型名，type 只是创建类型别名，并没有创建新类型\n4.  interface 可以重复声明扩展，type 则不行（别名是不能重复的）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a1d5edb8c154c5fab2598085c442640~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974533c1d7b246eab7b002df6363f3e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 索引签名（Index Signatures）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c54a4792272422ebece482998d72dde~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 接口继承\n\n-   接口和类继承相同，都是使用 `extends` 关键字\n-   接口是支持多继承的（类不支持多继承）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7dc95a1059942caa7494e5055b842c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 接口实现\n\n-   定义的接口可以被类实现\n-   之后如果需要传入接口的地方，同样也可以将类实例传入\n-   这就是面向接口开发\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7350aa3c165445879a5f3bf63908264b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 函数\n\n### 基本使用\n\n-   我们可以编写**函数类型的表达式（Function Type Expressions）**，来表示函数类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d344d47b2277452cb1bbebe2b71c9136~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n更多细节使用 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92cc469ed95c42ccabd40ef27ce81975~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 调用签名（Call Signatures）\n\n-   函数除了被调用，也可以有自己的属性值\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2575e7cd4ed48b88e1af9c9b684ccfb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 构造签名 （Construct Signatures）\n\n-   函数也可以使用 new 操作符去当作构造函数\n-   使用构造签名，即在调用签名前面加 new 关键词\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f11a6f281fee497c93c271ce261b3cba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### this\n\n-   TS 中默认情况下如果没有指定 this 的类型，this 是 any 类型\n-   我们可以在函数第一个参数声明 this 的类型，函数调用传入的参数从第二个开始接收\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c13e288198649c8b7f9df9c82943855~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   `ThisParameterType` 提取函数类型的 this 参数类型，如果没有 this 参数则返回 unknown\n-   `OmitThisParameter` 移除函数类型 this 参数类型，返回当前函数类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0d69af818a74c44894d12916841ba2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   `ThisType` 指定所在对象的所有方法里面 this 的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a3e6d8cfe6f4d1e95a0c914cbe48b66~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 联合类型、交叉类型、函数重载\n\n### 联合类型（Union Type）和重载\n\n-   TS 允许我们使用多种运算符，从**现有类型中构建新类型**\n-   联合类型就是一种组合类型的方式，**多种类型满足一个即可**，使用 | 符号，其中每个联合的类型被称之为**联合成员（union\'s members）**\n-   函数重载则是我们可以去编写不同的\\*\\*重载签名（overload signatures）\\*\\*表示函数可以不同的方式调用，一般写两个及以上的重载签名，再编写一个通用函数的实现\n\n假如现在有个函数，可以传入字符串或数组，以获取长度 方式一：联合类型 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02366985ddac484b944e59020e826d5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n方式二：函数重载 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90501c727a8549eaa6303aad0e306cb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 开发中，尽量使用联合类型，更易阅读\n\n___\n\n-   交叉类型则是**满足多个类型**的条件，使用 & 符号\n-   例如 `type MyType = number & string`，满足一个既要是 number 类型，也要是 string 类型的值，显然没有值满足，则会交叉成 never 类型\n-   进行交叉时，通常是使用**对象类型交叉**\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82982b6afa1d43aa85ee31abf59c96bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类型、非空、常量断言\n\n-   类型断言 `as`，当 TS 无法获取到具体的类型信息，就需要使用**类型断言（Type Assertions）**\n-   它可以允许我们断言成更具体或者不太具体的（比如any）的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb2284bed3eb429e80567eada54cd675~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   非空类型断言 `!`，当我们确定参数有值，需要跳过 TS 对它的检测的时候可以使用\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f6b28f2c284e2385cb0e3709b0faab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   常量断言 `as const`，将类型尽量收窄到字面量类型，如果用在对象后面，相当于给对象里面每个成员加上 `readonly`并收窄\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06bd75347a77488982cbbbb5a8bb7e9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 字面量类型\n\n-   其实使用 JS 定义的值不仅可以做值，还可以当做 TS 的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb4639f6c18945f6978cca71c355d2ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 字面量推理\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5374618c7d11465d9f13306832705422~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类型收窄（Type Narrowing）\n\n-   由一个更宽泛的类型变为更小的类型，缩小声明时的类型路径（Type Narrowing），比如 `number | string -> number`\n-   而我们可以通过\\*\\*类型保护（type guards）\\*\\*来收窄类型\n-   常见的类型保护有\n    -   `typeof`\n    -   `Switch` 或者一些相等运算符（`=== 、 !==`）来表达相等性\n    -   `instanceof`\n    -   `in`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1766533a934049bfe3b47ace864335~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8479822db2f448a9bcf05ddc6ff20d97~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e87ba2ac87be4afa90511cd98e14acbb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类型兼容\n\n-   TS 的类型兼容性是指当一个类型的值可以被另一个类型的变量所接受时，这两种类型就是兼容的\n-   比如当一个类型 A 可以被赋值给另一个类型 B 时，我们就说类型 A 兼容于类型 B，，那么类型 A 就是类型 B 的子类型，类型 B 就是类型 A 的父类型\n\n## 基本类型和普通对象\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/382c2cedfb504be7989fb7ec07fd8e18~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 接口兼容\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ba410d3f9941d8ba16570af19592ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 函数兼容\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa98040bf70141aca418fbf046f1a7c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类的兼容\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a2bc3b8c4f4477fb3fd6179a0d2dc20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类\n\n-   ES6 之前使用函数实现类，ES6可以使用 class 关键字声明一个类\n-   在默认的 `strictPropertyInitialization` 模式下面我们的属性是必须在`constructor` 初始化的，如果没有初始化，那么编译时就会报错，如希望此模式下不报错，可以使用 `name!: string` 的语法\n-   类拥有自己的构造器 `constructor` ，当我们通过 `new` 关键字创建一个实例时会被调用，类中定义的函数叫方法\n\n## 基本使用\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7d39ea560134c8b822d66dffb129a9c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类的继承\n\n-   使用 `extends` 关键字来实现继承，子类中使用 `super` 来访问父类\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f144e118f124c788ba7032207837fd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类的成员修饰符\n\n-   在 TS 中，类的属性和方法支持三种修饰符： `public`、`private`、`protected`\n-   **public**：类外可见，默认编写的属性就是 public 的\n-   **protected**：类和子类中可见\n-   **private**：仅自身类可见\n-   **#属性**：实现私有属性，并且类型擦除之后还有效\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c0a485975444a5ba055998cf86da8cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 只读属性\n\n-   如果一个值不希望外界随意修改，可以使用 readonly 变得只读\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bfcea49735b45d3a14b5c6481d18f7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 访问器 getters/setters\n\n-   之前有一些私有属性我们不能直接访问，我们就可以使用存取器监听他的获取（getter）和设置（setter）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e50996bd7f48109dc18d7ae858ce7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 静态成员\n\n-   通过 static 可以定义类级别的成员和方法，通过 `类.属性或方法` 就可访问\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4842e34430204ed7b532113f6ebe859d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 抽象类\n\n-   抽象方法，必须存在于抽象类（使用 `abstract` 声明）中\n-   抽象类不能被 new 实例化，且内部抽象方法和属性必须被子类实现\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/449b894d470b45c0a7cbe6b3342f456f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类的类型\n\n-   类本身也可以当做一种类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d227b980af54db5967599719d5bb719~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d19da6adca4582ad87da40e304b625~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 参数属性（Parameter Properties）\n\n-   参数属性将 `constructor` 参数转换为同名同值的实例属性，相当于帮我们做 `this.name = name` 的操作\n-   我们可以在其 `constructor` 参数前面添加可见修饰符（public private protected 或者 readonly）创建参数属性\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b1d1ad4aeb4ccf8bd45fc6b7b50aa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 泛型编程\n\n函数的本质个人认为是\n\n-   推后部分待定的代码\n\n想象一下 JS 没有函数会怎么样，其实 TS 的泛型就类似于 JS 函数，不过它是**推后执行部分待定的类型**\n\n## 泛型实现类型参数化\n\n-   定义函数的时候不决定参数的类型\n-   而是让调用者使用尖括号形式传入对应函数\n\n比如我们实现一个函数，传入一个参数并返回它，保证这个参数和返回值类型一致 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca33171acf342bea46c9f1a150174a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 此函数我们使用的话\n\n1.  通过\\*\\* <类型> \\*\\*的方式将类型传递给函数；\n2.  通过类型推导，自动推导出传入参数的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5a896dbadc4f5da3acce96079fa19c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n当然我们可以传入多个类型 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a4da33a8d642288f129db31215280c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 其中，T，E 这些都是我们可以自定义的，它们代表的意义是\n\n-   T（Type）：类型\n-   K（key）、V（value）：，键值对\n-   E（Element）：元素\n-   O（Object）：对象\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41834e44692d4dad84ef896213ca4f66~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 泛型接口\n\n泛型接口是一种具有泛型类型参数的接口，它可以在接口的定义中使用这些类型参数，从而使得接口的属性和方法能够适用于多种类型\n\n-   定义接口的时候使用泛型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39162323d7e94f768ff7e7b0b837e2a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   指定类型默认值\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fdb667cdbe494aa0eff69148f9edb8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 泛型类\n\n-   泛型类是一种具有泛型类型参数的类，它可以在类的定义中使用这些类型参数，从而使得类的属性和方法能够适用于多种类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ad9c2d80e44e699820bd725917c4f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c43b9d6e959454b9c913ec985039d22~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 泛型约束（Generic Constraints）\n\n### 泛型中使用 extends\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5037d9d0c65d49fe99ebfb95f95245d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23701ad356cd46a38a28d997cf9b8afc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eefe6b51f68b40b7b43f20b517e219bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 泛型中使用 keyof\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0e25a1731e3414f9eea16693a0d0944~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 泛型中使用 extends 和 keyof\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df3166ec94049f1a12e15f59e6da90f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 映射类型（Mapped Types）\n\n-   映射类型是 TS 中的一种高级类型，它可以用来从一个现有类型中生成一个新的类型\n-   TS 大部分的内置工具和类型体操都是基于映射类型实现\n-   映射类型的语法形式是 `{ [K in keyof T]: U }`\n-   其中 `K` 是 `T` 的所有属性名的联合类型，`keyof` 是一个索引类型查询操作符，用来获取一个类型的所有属性名的联合类型。\n-   `U` 是一个类型变换函数，它用来将 `T` 中的每个属性类型变成另一个类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6213513f02224dfa987435839f0279e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n在使用映射类型时，有两个额外的修饰符\n\n-   `readonly`，用于设置属性只读\n-   `?` ，用于设置属性可选\n\n`-?` 去掉可选，如果变成 `+?` 则都变可选 `-readonly` 代表去除 `readonly` ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9e783eae35542d9ba8d02c8aaf13382~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n更高级的一些用法 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7971a364c14b81bd8fdbb9d7f2e92b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac1f30c51c945af830445b19eae6790~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71343145882b4b7f91ba563626fe2656~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 内置工具和类型体操\n\n-   TS 的类型系统增加了很多功能以适配 JS 的灵活性，导致 TS 是一门**支持类型编程的类型系统**\n-   通常我们为代码加上类型约束，不太需要过多类型编程的能力\n-   但是在开发一些通用框架，库的时候，考虑各种适配就需要更多考虑类型编程\n\n### 条件类型（Conditional Types）\n\n-   条件类型可以根据某个特定的条件，从两个类型中选择一个作为最终类型\n-   写法类似于 JS 三元 ：`SomeType extends OtherType ? TrueType : FalseType`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb4d978063840069ae217fa3957c6e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 条件类型中推断（infer）和 ReturnType\n\n-   条件类型提供了 `infer` 关键词，可以从正在比较的类型中推断类型，然后在 true 分支里引用该推断结果\n-   比如目前有一个数组类型，想要获取函数参数和返回值类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b48455176cdc40d1987f156587730e23~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f058707559d9459eb3775253e81116a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202fb0da98764888bce68bae815f0259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### 分发条件类型（Distributive Conditional Types）\n\n-   泛型中使用条件类型，如果传入联合类型，就会变成 分发的（`distributive`）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca0f2bbec243cdb6ce6c768be83d4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 如果我们希望是 `(string | number)[]` 这种类型，给 T 加个方括号就行 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a879d7ac3bc40b1b5e3fb2aff4f93a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 注意：若传入 `never` ，则返回的类型始终为 `never`\n\n___\n\n### Partial<Type>\n\n-   所有属性变为可选的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2ccd38e5c345ccb74923bcb96ee5ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Required<Type>\n\n-   所有属性变为必填的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cdaf07008154bf58e237867388740e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Readonly<Type>\n\n-   所有属性变为只读的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e319a698ba14c549ace14b7ab6d0410~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Record<Keys, Type>\n\n-   构造一个对象类型，所有key(键)都是 keys 类型， 所有 value(值)都是 Type 类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e7b838b46448658c27a607d9e5892c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Pick<Type, Keys>\n\n-   构造一个类型，从 Type 类型里面挑选一些类型 Keys\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c7a61c5f2f04e61bf3850218d822cd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Omit<Type, Keys>\n\n-   构造一个类型，从 Type 类型里面过滤掉一些类型 Keys\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b085be988e254e078614221f1274dd85~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Exclude<UnionType, ExcludeMembers>\n\n-   构造一个类型，它是从 UnionType 联合类型里面排除了所有可以赋给 ExcludedMembers 的类型\n-   可以使用它帮助实现 Omit\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb05630f95547e2b6f8cf9155f2d20a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### Extract<Type, Union>\n\n-   构造一个类型，从 Type 类型里面提取了所有可以赋给 Union 的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e6e47563e047bda693edc672e92156~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### NonNullable<Type>\n\n-   构造一个类型，这个类型从 Type 中排除了所有的 null、undefined 的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a29bb2ff30054485aa7be1429a64e713~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### InstanceType<Type>\n\n-   构造一个由所有 Type 的构造函数的实例类型组成的类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7beb968bfcc844bda84a6326009c6c02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n下面通过泛型结合工厂函数，更灵活获取实例的类型 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a36da39121b453db1c092d7e3b3fb06~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 扩展知识\n\n## TS 模块化和 .d.ts\n\n-   TS 支持两种方式来控制我们的作用域\n-   模块化：每个文件可以是一个独立的模块，支持 `ESModule`，也支持 `CommonJS`\n\n如果文件内没有任何 `export` 或 `import` ，而你又希望将它作为模块使用，即使它没有导出任何内容，添加下面这行代码 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50868a35c3f54238a95bef73d0dc8f89~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   内置类型导入（Inline type imports），使用 type 前缀 ，下面两种方式都表示导入一个类型\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82f5b200dd344904800e5db4f1a0ea6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccb1be340eaf4f43879f934b0b5f3732~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n-   命名空间：通过 `namespace` 来声明一个命名空间，主要是在早期将模块内部，再进行作用域的划分，防止命名冲突\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a3e9c72d27641d1929cdc16ffe61842~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## 类型声明和查找\n\n-   之前我们写的 `const imageEl = document.getElementById (\"image\") as HTMLImageElement`，这个 HTMLImageElement 类型来自于哪里呢？\n-   这就涉及到对类型的管理和查找规则了，除了我们写的 .ts 的代码文件，其实还有个 .d.ts 文件，它是用来做\\*\\*类型声明（declare）\\*\\*或者 \\*\\*类型定义（Type Definition）\\*\\*文件\n-   当我们写一个类型时候，会在**内置类型声明、外部定义类型声明、自己定义类型声明**里查找\n\n### 内置类型声明\n\n-   TS 帮我们内置了一些运行时标准化 API 的声明文件\n-   比如 `Function`、`String`、`Math`、`Date`、`RegExp`、`Error` 等内置类型\n-   也包含运行环境中的 DOM 、BOM API，比如 `Window`、`Document`、`HTMLElement`、`Event`、`NodeList`等\n-   很多常用方法其实 TS 已经帮你声明好了，具体地址：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fb83d6f0334e95b986db37b2513245~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n### 内置声明的环境\n\n-   我们可以通过 `target` 和 `lib` 决定哪些内置类型声明可以使用\n-   例如，`startsWith` 字符串方法 ECMAScript 6 版本才开始使用，我们就可以修改选项以获取新 API 的类型\n\n### 外部定义类型声明（第三方库）\n\n-   第三方库使用的时候也需要类型声明\n-   方式一：库自带 d.ts 的类型声明文件，比如 axios\n-   方式二：通过社区公有库 `DefinitelyTyped` 存放类型声明文件，比如我们安装 react 类型声明 `npm i @types/react --save-dev`\n    -   GitHub地址：\n\n### 外部定义类型声明（自定义声明）\n\n-   情况一：纯 JS 第三方库，比如 lodash，如果也没有类型声明库安装，我们就需要手动为其添加类型声明\n-   情况二：自己项目声明一些公共的类型，方便复用\n\n### 声明文件 d.ts\n\n-   .d.ts 文件是声明文件（Declaration File），用于描述 JavaScript 模块、类、函数、变量等的类型信息\n-   如果需要为第三方库或者自己库编写全局通用的声明，就可以创建 .d.ts\n\n```\ndeclare var 声明全局变量\ndeclare const 声明全局常量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare namespace 声明（含有子属性的）全局对象\ninterface 和 type 声明全局类型\n```\n\n`xxx.d.ts` ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dcf2222e28c4c3db1cec9f31791a113~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 使用的地方就可以放心使用，因为 .d.ts 结尾的文件声明都是全局 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600fe83d87aa41eebcbe3138244a350c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n___\n\n## tsconfig.json\n\n-   通过 `tsc --init` 命令可以生成 `tsconfig.json`\n-   它是 TS 的配置文件，用于配置 TS 编译器的行为\n\n```\n\"compilerOptions\": {\n  \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n  \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n  \"diagnostics\": true, // 打印诊断信息 \n  \"target\": \"ES5\", // 编译后的 JavaScript 代码的目标版本。例如：\"es5\"、\"es6\" 等\n  \"module\": \"CommonJS\", // 编译后的 JavaScript 代码的模块化方案。例如：\"commonjs\"、\"es6\" 等\n  \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n  \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // 编译器需要引入的库文件。例如：\"es5\"、\"es6\"、\"dom\" 等\n  \"allowJS\": true, // 允许编译器编译JS，JSX文件\n  \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n  \"outDir\": \"./dist\", // 编译后的 JavaScript 文件输出目录\n  \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n  \"declaration\": true, // 是否生成声明文件\n  \"declarationDir\": \"./file\", // 声明文件的输出目录\n  \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n  \"sourceMap\": true, // 是否生成源代码与编译后代码的映射文件\n  \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n  \"declarationMap\": true, // 为声明文件生成sourceMap\n  \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n  \"types\": [], // 加载的声明文件包\n  \"removeComments\":true, // 删除注释 \n  \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n  \"noEmitOnError\": true, // 发送错误时不输出任何文件\n  \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n  \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n  \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n  \"strict\": true, // 是否启用严格模式\n  \"alwaysStrict\": true, // 在代码中注入\'use strict\'\n  \"noImplicitAny\": true, // 不允许隐式的any类型\n  \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n  \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n  \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n  \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n  \"noImplicitThis\": true, // 不允许 this 有隐式的 any 类型\n  \"noImplicitAny\": true, 是否禁止隐式的 any 类型。\n  \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n  \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n  \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n  \"noImplicitReturns\": true, //每个分支都会有返回值\n  \"esModuleInterop\": true, // 允许 esmoudle 和 commonjs 相互调用\n  \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n  \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n  \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n  \"paths\": { // 路径映射，相对于baseUrl\n    // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n    \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n  },\n  \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n  \"listEmittedFiles\": true, // 打印输出文件\n  \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n}\n \n//  指定需要编译的文件或目录。可以使用通配符 * 匹配多个文件或目录（属于自动指定该路径下的所有ts相关文件）\n\"include\": [\n   \"src/**/*\"\n],\n//  指定不需要编译的文件或目录。可以使用通配符 * 匹配多个文件或目录（include的反向操作）\n \"exclude\": [\n   \"demo.ts\"\n],\n// 指定需要编译的文件列表（属于手动一个个指定文件）\n \"files\": [\n   \"demo.ts\"\n]\n```\n\n选项过多，讲几个常用点的：\n\n-   target: 编译后的 JavaScript 代码的目标版本。例如：\"es5\"、\"es6\" 等\n-   module: 编译后的 JavaScript 代码的模块化方案。例如：\"commonjs\"、\"es6\" 等\n-   lib: 编译器需要引入的库文件。例如：\"es5\"、\"es6\"、\"dom\" 等\n-   allowJs: 允许编译器编译 JS，JSX 文件\n-   strict: 启用所有严格类型检查选项。\n-   esModuleInterop: 允许 esmoudle 和 commonjs 相互调用\n-   include: 要编译的文件路径，可以是文件或文件夹的相对路径或绝对路径。\n-   exclude: 不需要编译的文件路径，可以是文件或文件夹的相对路径或绝对路径\n-   extends: 继承其他的 tsconfig.json 文件\n-   skipLibCheck：跳过对引入的库文件的类型检查\n-   sourceMap：是否生成源代码与编译后代码的映射文件\n-   \"removeComments\"：编译文件后删除所有注释\n\n___\n\n## 实战\n\n## 封装 axios\n\n-   支持请求和响应拦截器\n-   支持取消请求和取消全部请求的功能\n-   提供了 GET、POST、PUT、DELETE 四种请求方法\n\n```\nimport axios from \'axios\'\nimport type { AxiosInstance, AxiosResponse, InternalAxiosRequestConfig, AxiosRequestConfig } from \'axios\'\n\nclass Request {\n// Axios 实例\ninstance: AxiosInstance\n// 存放取消请求控制器\nabortControllerMap: Map<string, AbortController>\n\nconstructor(config: AxiosRequestConfig) {\n// 创建 Axios 实例\nthis.instance = axios.create(config)\n// 存储取消请求的控制器\nthis.abortControllerMap = new Map()\n// 添加请求拦截器\nthis.instance.interceptors.request.use(\n(res: InternalAxiosRequestConfig) => {\n// 创建取消请求的控制器\nconst controller = new AbortController()\n// 获取请求的 url\nconst url = res.url || \'\'\n// 将控制器存储到 Map 中\nres.signal = controller.signal\nthis.abortControllerMap.set(url, controller)\nreturn res\n},\n(err: any) => err\n)\n\n// 添加响应拦截器\nthis.instance.interceptors.response.use(\n(res: AxiosResponse) => {\n// 获取响应的 url\nconst url = res.config.url || \'\'\n// 从 Map 中删除对应的控制器\nthis.abortControllerMap.delete(url)\nreturn res.data\n},\n(err: any) => err // 响应拦截器错误处理函数\n)\n}\n\n// 发送请求的方法，返回 Promise 对象\nrequest<T>(config: AxiosRequestConfig<T>): Promise<T> {\nreturn new Promise((resolve, reject) => {\nthis.instance\n.request(config)\n.then(res => {\nresolve(res as T)\n})\n.catch((err: any) => {\nreject(err)\n})\n})\n}\n\n// 取消全部请求\ncancelAllRequest() {\nfor (const controller of this.abortControllerMap.values()) {\ncontroller.abort()\n}\n// 清空 Map\nthis.abortControllerMap.clear()\n}\n\n// 取消指定的请求\ncancelRequest(url: string | string[]) {\n// 将参数转换为数组\nconst urlList = Array.isArray(url) ? url : [url]\nurlList.forEach(_url => {\n// 根据 url 获取对应的控制器并取消请求\nthis.abortControllerMap.get(_url)?.abort()\n// 从 Map 中删除对应的控制器\nthis.abortControllerMap.delete(_url)\n})\n}\n\n// 发送 GET 请求的方法，返回 Promise 对象\nasync get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\nreturn this.request<T>({ ...config, method: \'get\', url })\n}\n\n// 发送 POST 请求的方法，返回 Promise 对象\nasync post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\nreturn this.request<T>({ ...config, method: \'post\', url, data })\n}\n\n// 发送 PUT 请求的方法，返回 Promise 对象\nasync put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\nreturn this.request<T>({ ...config, method: \'put\', url, data })\n}\n// 发送 DELETE 请求的方法，返回 Promise 对象\nasync delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\nreturn this.request<T>({ ...config, method: \'delete\', url })\n}\n}\n\nconst myRequest = new Request({\nbaseURL: \'https://www.fastmock.site/mock/13089f924ad68903046c5a61371475c4\',\ntimeout: 10000,\n})\n\nexport default myRequest\n```\n\n使用：\n\n```\n<script setup lang=\"ts\">\nimport Axios from \"./axios\"\nimport { onMounted } from \"vue\"\n\nconst myRequest = new Axios({\n  baseURL: \"https://www.fastmock.site/mock/13089f924ad68903046c5a61371475c4\",\n  timeout: 10000\n})\n\ninterface Req {\n  name: string\n}\ninterface Res {\n  code: string\n  data: {\n    userName: string\n  }\n}\n\nconst getData = (data: Req) => {\n  return myRequest.request<Res>({\n    url: \"/api/user/login\",\n    method: \"POST\",\n    data\n  })\n}\n\nonMounted(async () => {\n  const res = await getData({\n    name: \"云牧\"\n  })\n  console.log(res)\n})\n</script>\n```\n\n___\n\n## 封装 LocalStorage\n\n```\ninterface LocalStorageItem<T> {\n  value: T // 存储的值\n  expire: number | null // 过期时间，如果为 null 则表示永不过期\n}\n\nclass LocalStorage {\n  private static instance: LocalStorage // 单例模式，保证只有一个实例\n  private storage: Storage // localStorage 对象\n\n  private constructor() {\n    this.storage = window.localStorage // 获取 localStorage 对象\n  }\n\n  public static getInstance(): LocalStorage {\n    if (!LocalStorage.instance) {\n      // 如果实例不存在，则创建一个新实例\n      LocalStorage.instance = new LocalStorage()\n    }\n    return LocalStorage.instance // 返回实例\n  }\n\n  public setItem<T>(key: string, value: T, expire?: number): void {\n    const item: LocalStorageItem<T> = {\n      value: value, // 存储的值\n      expire: expire ? new Date().getTime() + expire : null, // 过期时间\n    }\n    this.storage.setItem(key, JSON.stringify(item)) // 将对象序列化为字符串并存储到 localStorage 中\n  }\n\n  public getItem<T>(key: string): T | null {\n    const itemStr = this.storage.getItem(key) // 获取存储的字符串\n    if (itemStr) {\n      // 如果字符串存在\n      const item: LocalStorageItem<T> = JSON.parse(itemStr) // 将字符串反序列化为对象\n      if (!item.expire || new Date().getTime() < item.expire) {\n        // 如果没有过期或者还没有过期\n        return item.value // 返回存储的值\n      } else {\n        this.storage.removeItem(key) // 如果已经过期，则删除该项\n      }\n    }\n    return null // 如果不存在或者已经过期，则返回 null\n  }\n\n  public removeItem(key: string): void {\n    this.storage.removeItem(key) // 删除指定的项\n  }\n\n  public clear(): void {\n    this.storage.clear() // 清空 localStorage\n  }\n}\n\nexport default LocalStorage.getInstance() // 导出 LocalStorage 实例\n```\n\n使用：\n\n```\n<script lang=\"ts\" setup>\nimport storage from \"./storage\"\n\n// 存储数据\nstorage.setItem(\"name\", \"黛玉\", 60 * 60 * 1000) // 存储一个过期时间为 1 小时的数据\nstorage.setItem(\"person\", { name: \"云牧\" }, 60 * 60 * 1000) // 存储一个过期时间为 1 小时的数据\n\ninterface Person {\n  name: string\n}\n\n// 获取数据\nconst name = storage.getItem<string>(\"name\")\nconst person = storage.getItem<Person>(\"person\")\nconsole.log(name) // 黛玉\nconsole.log(person.name) // 云牧\n\n// 删除数据\nstorage.removeItem(\"name\")\n\n// 清空所有数据\nstorage.clear()\n</script>\n```', '', 2, 1, 1, 501, '2023-09-10 07:18:56', 1);
INSERT INTO `article` VALUES (71, 3, '如何建设一个用于编译 iOS App 的 macOS 云服务器集群？', 'To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. There is no way to happiness. Happiness is the way. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. Anyone who has never made a mistake has never tried anything new. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. It collects process metrics such as CPU load, RAM usage, and a variety of other resources over SSH/SNMP. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. The first step is as good as half over. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. How we spend our days is, of course, how we spend our lives. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. I destroy my enemies when I make them my friends. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. The past has no power over the present moment. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. You will succeed because most people are lazy. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab.!', '', 4, 4, 5, 1148, '2020-09-10 02:28:22', 1);
INSERT INTO `article` VALUES (72, 5, 'iOS时钟翻转动画', '_我正在参加「掘金·启航计划」_\n\n最近项目有个时间倒计时的功能，网上也有很多优秀的第三方。这个功能应用还是比较广泛的，就稍微研究了一下。有好几种方法实现，笔者选取较简单一种。\n\n原理其实很简单，就是一个的绕X轴的翻转动画，只是在翻转过程中针对特殊情况做 特殊处理就行，下面也会讲到。\n\n## 效果图\n\n![fold.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a591fc90aaa1469fbc72819ba6e6c41f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 思路\n\n以一次完整动画为例，分步骤解析：\n\n### 第一步：\n\n新建3个`UILable`，分别是正在显示(`currentLabel`)、下一个显示(`nextLabel`)、做动画的(`animationLabel`)。\n\n### 第二步：\n\n首先在每次动画前给`nextLabel`设置默认的X轴起始角度翻转，这样处理是为了能够只显示上半部分，下半部分被隐藏（zPosition不改动的情况下），如下图，红色的是`nextLabel`，绿色的是`currentLabel`，灰色的是`animationLabel`。\n\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70fb52f8c12749ae8e8df437f9c00ed1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n代码：\n\n```\n// 设置默认的X轴起始角度翻转，为了能够只显示上半部分，下半部分被隐藏（zPosition不改动的情况下）\nfunc setupStartRotate() -> CATransform3D {\n    var transform = CATransform3DIdentity\n    transform.m34 = CGFLOAT_MIN\n    transform = CATransform3DRotate(transform, .pi*kStartRotate, -1, 0, 0)\n    return transform\n}\n```\n\n### 第三步：\n\n使用`CADisplayLink`做动画，笔者这里设置固定的刷新帧率为60（因为存在不同的刷新帧率设备），且动画执行时间0.5s，即每次刷新帧率时动画执行了`2/60`进度。\n\n接下来使用`CATransform3DRotate`将`animationLabel`沿着X轴进行翻转动画，这时候我们会发现动画的进度超过一半时，会存在如下问题：\n\n![WechatIMG10.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4723b6a73e38441b8354fc927e4c7323~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n上图这个是倒计时 2 变为 1 的过程，且动画进度超过一半时的显示画面。我们换个角度看看：\n\n![WechatIMG11.jpeg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc2214e270814aacbedde0ff462ea10e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n可知在当前情况下，灰色的标签显示的是 2 的上部分的背面，但是应该显示的是 1 的下部分，这显示是有问题的。这么说有点拗口，简单来说就是一个物体在3D空间中沿X轴翻转大于90度时，我们看到的实际是物体的上下和前后均颠倒的二维平面，所以才会出现如此的不和谐。\n\n所以解决这个问题，使动画更和谐流畅，我们需要物体翻转的动画在临界点翻转到90度时，即与屏幕垂直的时候，为了正确显示，即需要将动画的`animationLabel`同时沿着Y和Z轴翻转，并切换文字，将2切换成1。即：\n\n```\nif animateProgress >= 0.5 {\n   t = CATransform3DRotate(t, .pi, 0, 0, 1);\n   t = CATransform3DRotate(t, .pi, 0, 1, 0);\n   animationLabel.text = nextLabel.text\n }else{\n   animationLabel.text = currentLabel.text\n }\n```\n\n此时的过程就是 2 在翻转超过90时，将之沿着Y和Z轴翻转，并切换为1，看到的就是动图显示的过程了。\n\n到这里一个完整的翻转动画就结束了，后面使用`CADisplayLink`定时重复上述动画就可以了。\n\n后续也使用这个动画写了一个时间显示的和倒计时的demo，具体的代码在下面的链接，感兴趣的可以查阅指导下。\n\n#### [RCFoldAnimation](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FRchTime%2FiOS_FoldAnimation.git \"https://github.com/RchTime/iOS_FoldAnimation.git\")\n\n若存在什么不对的地方，欢迎指正！', '', 5, 3, 1, 558, '2023-09-10 07:34:29', 1);
INSERT INTO `article` VALUES (73, 4, '末日终极坐标安卓辅助工具', '## 前言\n\n**本工具完全免费，无需联网**\n\n本文档只介绍工具的使用方法，有时间再写一篇介绍一下实现细节。  \n**总的来讲本工具可以帮助你时刻知道自己的坐标并知道和宝箱的位置关系，减少资源浪费。**  \n**5分钟即可完成100汽油的使用，大大节省时间。**\n\n**阅读本文档前提是大家是《末日血战》等同款游戏的玩家。**\n\n## 工具下载安装\n\n链接: [pan.baidu.com/s/14GE-713c…](https://link.juejin.cn/?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F14GE-713cBtx3MxLvBleOQg \"https://pan.baidu.com/s/14GE-713cBtx3MxLvBleOQg\") 提取码: 29c5\n\n## 安装工具\n\n工具安装后，桌面会有这个图标。  \n在打开工具前需进入应用设置页打开这个应用的`显示悬浮窗权限`。 ![图片说明](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aa97952c7544306b8caeee3981016e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 填入初始坐标\n\n打开工具大致显示是这个样子，坐标初始都是0，那么填入相应的坐标`保存`就会是这个样子。 ![14ae0a88098b04a18b0a0c36b400e3c.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2d714c2236a40adbbc1c1cfb805ed65~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 可以看到左上角有个小图，这是一个直角坐标系的缩略图，左上角位置是（0,0）右下角位置（301,301），拖拽可以移动位置。 小图中会显示3个红点，一个绿点。绿点表示当前坐标，红点表示终极坐标。`绿点的坐标数值是固定显示在左上角的，不随绿点移动`\n\n**此时可以按返回键退出app，但是不要杀掉应用。**\n\n## 建立坐标系\n\n初次使用，建议可以打开小程序截一张生存之路的全屏图，然后我们打开这张图并横屏显示图片开始操作。当已经熟悉工具如何使用后可以在游戏中进行操作了\n\n**建立坐标系**  \n打开图片或者游戏，进入到这个界面，点击左上角悬浮窗上的`开始`按钮，会看到这样一个界面（没有中间两条直线） ![47b446b703476c931a27667de16d706.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a1716f47a144c982c3ea7c98658877~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 我们的目标就是为了建立中间两条直线。\n\n严格按图片指示的顺序操作。`尽可能点击在轴线的中心位置`。 ![d6bdd46daf0a94960c54bf8918af5f5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b6501f7d064500872f0582d638f52f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) `以上操作只需要执行一次，后续就不需要操作了。` 完成以上操作，就得到有两条线的图了。这个时候就完成了建立坐标系。  \n如果坐标系建立的不太好（比较斜，良好的坐标系有助于减少误差。），可以重新再来直到满意为止。\n\n## 开始寻找终极坐标\n\n注意观察小地图，找一个我们没有到达的离的近的终极坐标为目标。可以看到x和y的差距。  \n举个例子，我们当前坐标`49,52`,刚刚已经在`48,52`这里取得了一个宝箱，那么下一个目的地选`237,29`。因为是x坐标相差较大，我们x太小，而y坐标我们的大一点。所以主要的方向是加x，少量的减y。 ![05c5394993b5a8877db3d81c8ce6425.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb5f751d493b49d5b3fc6a96c1486b19~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 所以我们应该按x轴正方向和y轴负方向这里走，因为x相差较大，所以如果可以的话（有障碍物就走不了）就直接沿着x轴正方向走就好了。\n\n我想游戏玩家应该还是知道要往哪走的，但是容易算错坐标或者根本懒得记，凭运气。那么我们指定往哪走之后，接下来怎么使用这个工具。\n\n-   1、点击一个位置（我们要让小车开到的位置），这个时候小车不会走，因为我们工具盖住了游戏\n-   2、app回退一下（不是杀掉应用），这时可以发现小车在抖动了，其实就是小车可以走了，再点一下刚才那个位置，小车就会走到那个位置。这样我们就完成了一次移动和坐标记录。小地图当前坐标就会变化。绿点也会移动。\n-   3、小车走完之后，我们再点`开始`，然后重复1，2 步骤。\n\n## 补充\n\n-   1、本工具存在误差，一般每次执行在小车x,y <=|2| 基本100%准确。x,y <= |3| 100个汽油可能会有|2|以内坐标的误差（仅本人测试数据）\n-   2、点击位置尽可能点在地图块的中间，这样可以减少误差。遇到坐标点在路径上，可以进入其中对当前坐标进行校准，当然一般是不需要的。\n-   3、如果遇到了事件，我们就处理完事件后再点`开始`按钮\n-   4、`回退`怎么用：右下角回退用途是当我们不想走这一步，可以点`回退`按钮撤销这一步，然后重新再点一个点。如果还是后悔不想走这一步(**这个回退是指回退我们的记录，游戏中的步骤我们肯定是做不到回退的**)可以再次回退，但要注意只能回退一步。\n-   5、在工具操作界面（即点击`开始`后显示坐标线和按钮的那种情况），`GETXY`按钮下的白色坐标数字是表示当前这一步的行进地图坐标，例如`3,2`表示向x轴正方向移动3格，y轴正方向移动2格。可以通过这个坐标判断工具计算的坐标是否准确。\n-   6、本次汽油用完后，就可以杀掉辅助工具app了。下次有汽油可以继续直接使用,**记住使用过程中的退出都是回退而不是杀掉app**\n-   7、如果已经在工具上操作坐标了，但是发现汽油不够了，这个时候最好是买几个汽油仍然走到刚才记录的位置。当然也可以使用回退功能，再重新操作工具点击到你汽油够的位置。\n\n## 最后\n\n希望大家先熟悉工具流程，可以截一张图去操作，参考上文补充5的说明，通过这个坐标数值可以知道工具记录是否准确。然后再在游戏中操作避免浪费资源。如果通过截图去熟悉工具使用，在正式使用前要核对一下当前坐标是否准确。坐标可以随时矫正。  \n希望大家游戏愉快，也希望本工具对大家有所帮助。  \n如有建议或问题可在文章评论中反馈或者发邮件给我我。 邮箱：[oddshou@sina.com](https://link.juejin.cn/?target=mailto%3Aoddshou%40sina.com \"mailto:oddshou@sina.com\")', '', 4, 2, 0, 213, '2023-09-10 07:17:26', 1);
INSERT INTO `article` VALUES (74, 1, '回调函数与promise与async/await', '仅个人回忆向,初学不是很懂写下来加深印象,也欢迎大佬进行讲解和补充\n\n首先在JavaScript中，有两种常见的方法来实现异步函数：\n\n### 1.使用回调函数（Callback）：这是一种传统的方法，在异步操作完成后，通过调用一个回调函数来处理结果。\n\n**(个人理解：回调函数就是执行异步函数的东西，异步执行完了就调用“回调函数”来处理)**\n\n例如：\n\n```\nfunction fetchData(callback) {  \n   setTimeout(function() {    \n        const data = \'Async data\';    \n        callback(data);  \n    }, 1000);\n}\nfunction handleData(data) {\n    console.log(data);\n}\n\nfetchData(handleData);\n```\n\n在上面的例子中，`fetchData`函数模拟了一个异步操作，通过`setTimeout`函数模拟1秒后返回数据。`handleData`函数作为回调函数传递给`fetchData`函数，在异步操作完成后被调用来处理返回的数据。\n\n### 2.使用Promise对象：Promise是ES6中引入的一种处理异步操作的机制。它可以更方便地处理异步操作的结果，并且可以链式调用多个异步操作。\n\n**（个人理解：promise用来解决回调地狱，链式调用（.then）错误处理(.catch)和更好的可读性）**\n\n-   `Promise`(承诺)，给予调用者一个承诺，过一会返回数据给你，就可以创建一个promise对象\n-   当我们`new`一个`promise`，此时我们需要传递一个回调函数，这个函数为立即执行的，称之为（executor）\n-   这个回调函数，我们需要传入两个参数回调函数，`reslove`,`reject`(函数可以进行传参)\n    -   **当执行了**`**reslove**`**函数，会回调promise对象的.then函数**\n        \n    -   **当执行了**`**reject**`**函数，会回调promise对象的.catche函数**\n        \n\n作者：一只ice  \n链接：[juejin.cn/post/714430…](https://juejin.cn/post/7144308012952322084 \"https://juejin.cn/post/7144308012952322084\")  \n来源：稀土掘金  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n例如：\n\n```\nfunction fetchData() {  \n    return new Promise(function(resolve, reject) {    \n        setTimeout(function() {      \n            const data = \'Async data\';      \n            resolve(data);    \n         }, 1000);  \n     });\n}\nfetchData().then(function(data) {  \nconsole.log(data);\n}).catch(function(error) {  \nconsole.log(error);\n});\n```\n\n在上面的例子中，`fetchData`函数返回一个Promise对象。在异步操作完成后，调用`resolve`方法来传递结果。通过调用`then`方法来处理成功的情况，调用`catch`方法来处理失败的情况。\n\n这两种方法都可以实现异步函数，选择使用哪种方法取决于具体的需求和项目的要求。\n\n### 3.async和await\n\n使用 `async/await` 可以将上述代码重写为以下形式：\n\n```\nfunction fetchData() {  \n    return new Promise(function(resolve, reject) {    \n        setTimeout(function() {      \n            const data = \'Async data\';      \n            resolve(data);    }, 1000);  \n        });\n}\nasync function main() {  \n    try {    \n        const data = await fetchData();    \n        console.log(data);  \n    } catch (error) {    \n        console.log(error);  \n    }\n}\nmain();\n```\n\n在上述代码中，`fetchData` 函数返回一个 Promise 对象，并使用 `setTimeout` 模拟一个异步操作。在 `main` 函数中，我们使用 `await` 关键字来等待 `fetchData` 函数返回的 Promise 对象。当异步操作完成时，我们可以访问解决值并打印到控制台。如果异步操作失败，我们可以使用 `try-catch` 块来捕获错误并打印到控制台。\n\n## 个人提问环节\n\n### 1.使用await关键字可以使异步操作看起来更像同步操作，但它并不会阻塞整个程序的执行,举个例子.\n\n当使用await关键字等待一个异步操作完成时，JavaScript引擎会继续执行其他可以执行的代码。下面是一个简单的例子来说明这一点：\n\n```\nasync function fetchData() { \n    console.log(\"Start fetching data\"); \n\n    // 模拟一个异步操作，例如发送HTTP请求 \n    await new Promise(resolve => setTimeout(resolve, 2000)); \n    console.log(\"Data fetched\"); \n} \nconsole.log(\"Before calling fetchData\"); \nfetchData(); \nconsole.log(\"After calling fetchData\");\n```\n\n在这个例子中，我们定义了一个名为fetchData的异步函数。在函数内部，我们使用await关键字等待一个模拟的异步操作，即一个2秒钟的延迟。在异步操作完成之前，我们在控制台输出\"Start fetching data\"。然后，我们在控制台输出\"After calling fetchData\"。 当我们运行这段代码时，输出将会是： \n\n```\nBefore calling fetchData\nStart fetching data \nAfter calling fetchData \nData fetched\n```\n\n 从输出结果可以看出，在调用fetchData函数之后，控制台会立即输出\"After calling fetchData\"，而不会等待异步操作完成。然后，在异步操作完成后，控制台输出\"Data fetched\"。 这个例子说明了使用await关键字时，虽然函数的执行被暂停等待异步操作完成，但整个程序的执行并没有被阻塞，它可以继续执行其他可以执行的代码。\n\n### 2.promise相对于用回调函数的区别\n\nPromise 是一种用于处理异步操作的编程模式，相对于使用回调函数，它具有以下几个区别：\n\n 1. 可链式调用：Promise 提供了 \\`.then()\\` 方法，使得可以链式调用多个异步操作。这样可以避免回调地狱（callback hell）的问题，使得代码更加清晰易读。 \n\n 2. 错误处理：Promise 提供了 \\`.catch()\\` 方法，用于捕获和处理异步操作中的错误。这样可以集中处理错误，而不需要在每个回调函数中进行错误检查和处理。 \n\n 3. 更好的可读性：Promise 使用 \\`.then()\\` 和 \\`.catch()\\` 方法来处理异步操作的结果，使得代码的逻辑更加清晰和易于理解。\n\n4\\. 更好的错误追踪：Promise 可以捕获和跟踪异步操作中的错误，并将错误信息传递给 \\`.catch()\\` 方法。这样可以更容易地追踪错误的来源和调试代码。 \n\n 5. 更好的组合和复用性：Promise 可以通过 \\`.then()\\` 方法将多个异步操作链接在一起，形成一个操作序列。这样可以更方便地组合和复用异步操作。 \n\n 总的来说，Promise 提供了一种更优雅和可读性更高的方式来处理异步操作。它能够减少回调地狱的问题，提供更好的错误处理和追踪机制，并提供更好的组合和复用性。\n\n### 3.async/await也没比promise好啊,用async还要用trycatch获取错误,感觉比promise更麻烦\n\n使用 `async/await` 和 `try-catch` 的主要优势在于代码的可读性和可维护性。它们使异步代码看起来更像是同步代码，使得逻辑更加清晰和直观。\n\n使用 `async/await` 可以避免回调地狱（callback hell）的问题，使异步代码更易于编写和理解。通过在异步操作前使用 `await` 关键字，代码可以暂停执行，直到异步操作完成并返回结果。这使得异步操作的处理更加直观和线性。\n\n使用 `try-catch` 可以更容易地捕获和处理异步操作中的错误。在 `try` 块中执行异步操作，如果操作失败，则会抛出一个错误。然后可以在 `catch` 块中捕获该错误，并执行相应的错误处理逻辑。\n\n尽管在某些情况下使用 `async/await` 和 `try-catch` 可能会增加一些额外的代码，但它们提供了更好的代码结构和错误处理机制，使得代码更加健壮和可维护。\n\n当然，选择使用 `async/await` 还是 `Promise` 取决于个人偏好和项目需求。有些情况下，使用 `Promise` 可能更适合简单的异步操作。但对于复杂的异步操作和更清晰的代码结构，`async/await` 和 `try-catch` 是更好的选择。\n\n### 4.用async/await时都要用到trycatch吗\n\n在使用 `async/await` 时，并不是每个异步操作都需要使用 `try-catch` 块来捕获错误。`try-catch` 主要用于捕获可能发生的异常并进行错误处理。\n\n在使用 `async/await` 时，可以根据需要决定是否使用 `try-catch` 块来捕获错误。以下是一些常见的情况：\n\n1.  如果您希望在发生错误时执行特定的错误处理逻辑，可以使用 `try-catch` 块来捕获错误并在 `catch` 块中处理它们。\n    \n    async function main() {  \n    try {  \n    const data = await fetchData();  \n    console.log(data);  \n    } catch (error) {  \n    console.log(\'An error occurred:\', error);  \n    // 执行错误处理逻辑  \n    } }\n    \n\n2\\. 如果您希望让错误向上传递到调用 `main` 函数的地方进行处理，可以在调用 `main` 函数的地方使用 `try-catch` 块来捕获错误。\n\n```\nasync function main() {  \n    const data = await fetchData();  \n    console.log(data);\n}\ntry {  \n    main();\n} catch (error) {  \n    console.log(\'An error occurred:\', error);  \n    // 执行错误处理逻辑\n}\n```\n\n3.如果您不需要特定的错误处理逻辑，并且希望让错误向上传递到调用 `main` 函数的地方进行处理，可以省略 `try-catch` 块。\n\n```\nasync function main() {  \n    const data = await fetchData();  \n    console.log(data);\n}\nmain().catch(error => {  \n    console.log(\'An error occurred:\', error);  \n    // 执行错误处理逻辑\n});\n```\n\n总之，使用 `try-catch` 块来捕获错误取决于您的需求和代码结构。在某些情况下，您可能希望在异步操作的特定位置进行错误处理，而在其他情况下，您可能希望将错误向上传递到调用函数的地方进行处理。\n\n## 结语\n\n暂时先写到这么多,一时接收这么多昏昏沉沉的,大概是理解了,但是用还不好说哈哈. you can use the List List, Detail Detail and ER Diagram ER Diagram buttons to change the object view. Remember that failure is an event, not a person. Creativity is intelligence having fun. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. The Main Window consists of several toolbars and panes for you to work on connections, database objects and advanced tools. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. The Synchronize to Database function will give you a full picture of all database differences. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. To open a query using an external editor, control-click it and select Open with External Editor. You can set the file path of an external editor in Preferences. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. Navicat provides powerful tools for working with queries: Query Editor for editing the query text directly, and Query Builder, Find Builder or Aggregate Builder for building queries visually. I destroy my enemies when I make them my friends. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. There is no way to happiness. Happiness is the way. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. Typically, it is employed as an encrypted version of Telnet. Difficult circumstances serve as a textbook of life for people. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. A comfort zone is a beautiful place, but nothing ever grows there. Typically, it is employed as an encrypted version of Telnet. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. To connect to a database or schema, simply double-click it in the pane.', 'public/uploads/1694355728448.png', 2, 2, 0, 903, '2023-01-10 14:22:33', 1);
INSERT INTO `article` VALUES (75, 1, '订单系统就该这么设计，稳的一批！', '> 订单功能作为电商系统的核心功能，由于它同时涉及到前台商城和后台管理系统，它的设计可谓是非常重要的。就算不是电商系统中，只要是涉及到需要交易的项目，订单功能都具有很好的参考价值，说它是通用业务功能也不为过。今天就以mall项目中的订单功能为例，来聊聊订单功能的设计与实现。\n\n## mall项目简介\n\n这里还是简单介绍下mall项目吧，mall项目是一套基于 SpringBoot + Vue + uni-app 的电商系统，目前在Github已有`60K的Star`，包括前台商城项目和后台管理系统，能支持完整的订单流程！涵盖商品、订单、购物车、权限、优惠券、会员等功能，功能很强大！\n\n-   项目地址：[github.com/macrozheng/…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmacrozheng%2Fmall \"https://github.com/macrozheng/mall\")\n-   学习文档：[www.macrozheng.com](https://link.juejin.cn/?target=https%3A%2F%2Fwww.macrozheng.com \"https://www.macrozheng.com\")\n\n## 功能设计\n\n> 首先我们来看下mall项目中订单功能的设计，由于订单功能同时涉及到前台商城和后台管理系统，这里将分别讲解。\n\n### 后台管理系统\n\n> 后台管理系统的订单模块主要包括订单管理、订单设置、退货原因设置、退货申请设置功能。\n\n#### 订单管理\n\n后台管理员在订单列表中可以实现查看订单、删除订单、订单发货、订单跟踪等操作。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0eb8691f1f4384a4d989002da8780c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n针对不同状态下的订单，后台管理员在订单详情页还可以实现修改收货人信息、修改费用信息、关闭订单、备注订单等操作\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c5c447df914705ac5b26e8aec04093~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 订单设置\n\n后台管理员可以对订单实现一些基础设置，例如订单超过多少时间自动关闭等等。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398aeddebe134a58910d65a0f119756f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 退货申请处理\n\n后台管理员可以对退货申请进行处理，比如说确认退货或拒绝退货。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3040f871d1b44bcdbd11ff35040bd924~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 退货原因设置\n\n后台管理员还可以对退货的原因进行设置，以便前台用户退货是进行选择。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81651d99070a469aae69c086033d443f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### 前台商城系统\n\n> 我们将以mall项目的核心订单流程为例，来介绍下前台商城系统中的订单功能。\n\n#### 流程示意图\n\n前台商城系统从加入购物车到完成订单的整个流程可以参考下图。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a6f071592504293884cb745f4ef9586~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 订单流程\n\n-   前台会员可以在前台商城中查看商品；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6d642fc06b247099c7907843586a75f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   前台会员点击加入购物车后查看购物车；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc78898112ec4eee8c27033d3bee83aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   前台会员点击去结算后创建订单；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be7d5db879b49ffa956d5a19e0c1589~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   前台会员点击去结算后跳转到支付界面；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/901df87c132f4dee9907504a283372be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   前台会员确认支付后跳转到我的订单界面；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3a140eeb1d8492ab24076c28adad42a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   后台管理系统收到订单；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d9f08cc037425098aca877ae4b4131~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   后台管理员点击订单发货进行发货操作；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfadc88795f1423bb5b4894c89da34d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   确认发货后，前台商城订单状态变为待收货；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e19e2f6b084643b81f29fe72714391~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   前台会员确认收货后，订单状态变为交易完成；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac8aee7d5a540839b1314aa1f208c93~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n-   后台管理系统可查看订单详情。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/965dd443185f4d82a592ab224c0e55ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 功能整理\n\n对于订单模块的功能，我这里整理了一张思维导图方便大家查看，主要是整理了下有哪些功能以及功能需要涉及哪些字段。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c33d617cbc5e4c6394e6b57b27c15cba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 数据库设计\n\n根据我们的功能设计和整理好的思维导图，就可以进行数据库设计了，这里是mall项目订单模块的数据库设计图。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a03a5a953d744ecbaa1c59109dd8e66c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 接口设计\n\n对于mall项目中订单模块的接口设计，大家可以参考项目的Swagger接口文档，以`Oms`开头的接口就是订单模块对应的接口。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0cb54ff705643159cac41df26aac343~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 总结\n\n今天介绍了下mall项目中订单模块的功能设计、数据库设计和接口设计，由于很多项目中都会涉及到订单功能，掌握订单功能的设计还是非常有必要的！\n\n## 项目源码地址\n\n[github.com/macrozheng/…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmacrozheng%2Fmall \"https://github.com/macrozheng/mall\")', 'public/uploads/1694329415645.png', 3, 5, 1, 527, '2023-09-10 07:03:51', 1);
INSERT INTO `article` VALUES (76, 3, 'uni-app 全局消息通知弹窗（App端）', 'Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication.', '', 1, 1, 1, 957, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (77, 7, '【从0-1 千万级直播项目实战】设计活动平台 | 5分钟上线一个活动', '     \n\n## 背景\n\n在项目整体上线运营之后，直播的基础框架底层基本已经搭建完毕，在运营期间需要不断的创造营收和刺激打赏，这就需要通过迭代大量的活动和玩法来完成。\n\n![5dc2ac73391fe.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82e8bfc793394c1881418ca376ed2f8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 目标导向\n\n在创造营收这期间如果活动、玩法等一开始没有进行抽象处理和设计，势必会让技术债务越来越重，当然在产品/运营看来，前期MVP版本的迭代是他们的期望，在最短的时间撸出MVP版本去验证才是他们的目标导向，而对于技术而言，制造工具让他们用最短的时间完成MVP版本验证且保证高质量交付才是目标导向\n\n## 设计思路\n\n### 1.可视化的界面配置\n\n**思路**\n\n-   在运营后台植入活动模块\n-   可以自由CRUD活动的配置、类型、日、周、月榜单等\n-   可以自由上传更新活动的设计图、活动位配图等\n-   可以自由生成静态页面的配置，比如配置玩法说明页、规则页等，配置后生成链接，链接即刻生效\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8595df33edc6408697cb90d9d694792f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 2.人性化的校验机制\n\n**思路**\n\n-   用户输入的校验提示\n-   配置正确与否的校验\n-   目标奖励正确与否的校验\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b356bec0304f7db60ca6b826ff0497~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 3.多地区并行的适配\n\n**思路**\n\n-   支持不同地区运营同一活动\n-   多时区下同一活动的处理\n-   多语言的配置\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/264d650809fa49868ad5bc88b73331f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 4.长期可扩展的接口设计\n\n**思路**\n\n-   引入版本号机制的兼容接口设计\n-   SDK模块化设计\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdfff868e6144a70952b14d33691d7b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 5.高性能抽象化的榜单统计\n\n**思路**\n\n-   工厂、策略模式抽象化榜单\n-   巧妙运用redis实现高性能榜单统计\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab335f21f15b4f689f32d14a488a3a98~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 6.高可用严谨的发奖模式\n\n**思路**\n\n-   发奖任务集群\n-   发奖一致性保证\n-   发奖并发处理\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c26b0fc06dd4dcda386ca67cb6e1393~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 7.可观测的数据大盘\n\n**思路**\n\n-   活动数据埋点服务\n-   投放平台上报\n-   冷热数据存储与查询方案\n-   BI数据聚合统计\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f56d46aa7f44976848c54cbe7ba3164~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 总结\n\n1.  活动平台适用于需要多次重复举办的活动，比如每周一次/每月一次/长期的活动\n2.  可视化的配置能提高运营人员的生产力，提升配置体验\n3.  人性化校验机制能及时洞悉配置正确与否，这显得极为重要，尤其突出在奖励方面，特别是一些大活动，设计的奖励类型，数量非常之多，如果单纯靠填写ID方式不做校验，可能会造成严重后果\n4.  多地区的设配能有效拉动营收，在活动预热期间可以一个活动多个地区一起预热上线，直接提高了运营效果。\n5.  扩展接口设计能兼容不同版本的活动、客户端正常运行。\n6.  高性能榜单统计利用了Redis zSet数据结构的优势，优雅轻松实现榜单数据的实时统计，对于大Key也可以进行冷热Key处理和分Key统计\n7.  高可用严谨发奖模型利用了XXL-JOB集群高可用的优势触发发奖任务，利用状态位设计结合分布式锁、乐观锁等实现发奖的一致、准确性。\n8.  可观察的数据大盘提供了实时数据聚合查询、冷数据统计收集统计，整个数据分析对运营/产品显得极为重要，是用来衡量活动效果、期望值的绝佳杀器。\n\n![avatar](https://p26-passport.byteacctimg.com/img/user-avatar/ae6e6e3469a6ade4f2bfa8b4248355e8~40x40.awebp)', 'public/uploads/1694354744189.png', 3, 3, 2, 245, '2023-09-10 14:05:46', 1);
INSERT INTO `article` VALUES (78, 6, '啥,要我前端去对接外部?我也不会呀', '我正在参加「掘金·启航计划」\n\n> 一般来说，现在公司的业务都是后端去对接外部官方接口。但是现在加个紧急需求，往我这丢了几个对接文档，让前端去对接，我内心也是打咩。\n\n### 一、梳理开发对接流程\n\n1.  大概预览一遍对接文档，发现是需要引入外部提供给的js文件，然后再调用特定方法名通过jsonp的形式与外部联调。\n2.  因为调用特定方法需要提供域名给对方备案，这样才能权限调起接口。业务这边上报了几个域名给对方，但是问题来了，本地要这么联调呢？ 我%x#！@#&\\*，我也没做过哇，只能查资料开始准备工作。\n\n### 二、准备工作\n\n#### 1\\. 首先需要将本地的访问都修改伪装成报备的域名。那要怎么做呢？了解修改hots文件就可以实现，那么开始动手。\n\n1.1 首先找到hots文件，windows它路径一般是在C:\\\\Windows\\\\System32\\\\drivers\\\\etc，如下图 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a55176dbde48748cae959e781eb0c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n1.2 打开hots文件，添加解析。把本地访问指向后面报备的域名。（域名可以不用加协议，我这里报备的是https的域名）\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848d197a1f53419ca648fb811b3172f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 2\\. 运行项目。\n\n2.1 一开始只在vue.config.js配置了端口，在通过命令跑起项目\n\n```\nmodule.exports = {\n  devServer: {\n    port: 9012,\n  },\n}\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d38899fb94a347389019a569d674218f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n2.2 复制ip链接，浏览器打开，会出现资源加载不到的问题\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdfcd8a99924deb9b293d06b10e8a0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 2.3 替换成配置hots里面的域名，会发现项目无法运行\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f990c3fc02974acc8aa47e4d50853548~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 想起来报备配置的域名是https，所以vue.config.js里面随便写的port端号号是不行的，因为https默认端口号是443。 2.4 修改端口号为443，并且开启https服务，重跑项目\n\n```\nmodule.exports = {\n  devServer: {\n    https: true,\n    port: 443,\n  },\n}\n```\n\n出现以下提示，点击立即前往就行\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455985a96a0f4779b809e601be4bdfa7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 2.5 进入页面却又会提示以下错误，搜索发现可以配置vue.config.js解决\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33314fa1e7ac404d83e2b59981b7f958~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 添加配置\n\n```\nmodule.exports = {\n  devServer: {\n    https: true,\n    port: 443,\n    disableHostCheck: true,\n  },\n}\n```\n\n> 如果上面这种方案不行可以替换成下面这种： 在webpack 5 中disableHostCheck应该被遗弃了 查看文档了解到需将 disableHostCheck:true 替换为 historyApiFallback: true, allowedHosts: “all”,\n\n```\nmodule.exports = {\n  devServer: {\n    https: true,\n    port: 443,\n    historyApiFallback: true,\n    allowedHosts: \"all\",\n  },\n}\n```\n\n2.6 重跑项目,发现已经是可以进入页面了 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d2f42579dd43ae9940614c3da8b968~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 3.开始对接\n\n3.1 在idnex.html引入文档提供的外部js\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694b2c651d5a46569d8ad3ee5b0e2dd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 3.2 打开控制台发现以下错误\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1274922b8fbe47079416ebf29bb137b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 搜索了解到:https地址中，如果加载了http资源，浏览器将认为这是不安全的资源，将会默认阻止，这就会给你带来资源不全的问题了，比如：图片显示不了，样式加载不了，JS加载不了。\n\n**解决**:. 在index.html页面中加入（meta）头中添加upgrade-insecure-requests\n\n```\n<meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">\n```\n\n3.3 刷新页面,会发现调用特定方法成功\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd0441273d04a749bd2f28964fa208b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 4\\. 到此就可以开始写页面对接其他接口了。', 'public/uploads/1694336684939.gif', 2, 2, 1, 470, '2021-12-10 09:04:57', 1);
INSERT INTO `article` VALUES (79, 2, 'WWDC23 - 使用 Swift-DocC 构建丰富的文档', '## Session 10244 - 使用 Swift-DocC 构建丰富的文档\n\n> 本文首发于老司机技术周报 [xiaozhuanlan.com/topic/59760…](https://link.juejin.cn/?target=https%3A%2F%2Fxiaozhuanlan.com%2Ftopic%2F5976024813 \"https://xiaozhuanlan.com/topic/5976024813\")\n> \n> 作者：叶絮雷，Swift Documentation Workgroup 成员，目前就职于字节西瓜视频团队\n> \n> 审核：\n> \n> -   SeaHub：目前任职于腾讯 TEG 计费平台部，负责搭建服务于腾讯系业务的支付系统，主导国内 IAP 前后端相关内容，对 IAP 整体设计有一定的经验；\n>     \n> -   黄骋志：老司机技术轮值主编，目前就职于字节跳动，参与西瓜视频质量与稳定性工作。对 OOM/Watchdog 较为了解并长期投入\n>     \n\n本文是根据 WWDC23 中的 [Create rich documentation with Swift-DocC](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2023%2F10244%2F \"https://developer.apple.com/videos/play/wwdc2023/10244/\") 撰写，主要是引导如何利用 DocC 的新功能构建更丰富的框架文档。\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0589545b8754936b67443ce4567fd00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 前言\n\nSwift-DocC 是一个直接集成到 Xcode 中的文档编译器，允许我们在源代码中为项目编写和发布丰富的文档。\n\n我们可以通过在源代码中编写文档或者通过单独的 Markdown 文件来为代码编写详细的技术文档。\n\n![image](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c4efb21d014681adc8dac68f88cf17~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nDocC 也可以导出为静态网络托管解决方案，允许直接发布到 GitHub Pages 和 Netlify 等服务。同时生成的文档也将通过 Index 系统会出现在 Xcode 的内置文档窗口中，并集成到了 Xcode 的源代码编辑器中。\n\n这意味着以 DocC 格式编写的文档将自动提供给任何有权访问源代码的人，而无需任何额外的工作。\n\n![image](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6bf5536d594362adcc12b7b790640d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n自 Swift-DocC 随着 Xcode 13 一起发布以来，DocC 项目一直是通过 Github 开源库的方式进行的公开开发。社区的支持也给 DocC 提供了大量的新功能和改进，如自定义主题、导航、搜索、视频支持等等。\n\n目标方面，目前 DocC 除了支持 Swift Package 级别的文档也提供了应用程序级别的文档支持。\n\n语言方面，目前无论使用 Swift、Objective-C 还是两者混合编写的代码都能提供文档支持。\n\n同时在 Xcode 15 中通过和 DocC 的紧密结合，提供了文档预览编辑器。可以和 SwiftUI 类似，在编写文档的过程中提供实时的渲染视图。\n\n![image](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bf9cf0b32a04caf946b1873eeb34d39~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 该Feature在去年8月的 SDWG 会议上进行了讨论，想法是提供一个和 SwiftUI Preview 类似的能力\n> \n> 最终在今年的 Xcode 15 上完成了实现，但是其他 IDE 如 VSCode 也是可以通过目前的接口支持 Live Preview 的\n> \n> -   [Documentation Workgroup meeting notes: August 1st 2022](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fdocumentation-workgroup-meeting-notes-august-1st-2022%2F59432 \"https://forums.swift.org/t/documentation-workgroup-meeting-notes-august-1st-2022/59432\")\n>     \n> -   [Add Swift Documentation Preview Support](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fswift-server%2Fvscode-swift%2Fissues%2F562 \"https://github.com/swift-server/vscode-swift/issues/562\")\n>     \n\n除此之外，借助全新的 DocC 指令支持，如基于网格的布局、视频支持、自定义页面图标等，甚至完全自定义的主题配置，我们可以制作真正体现框架特色的定制文档。\n\n> 本文将重点讨论 Swift-DocC 的一些高级的功能，如果此前对 DocC 不太了解，建议可以看往期内参专题和相关 WWDC 视频：\n> \n> -   WWDC21内参: [DocC: 未曾设想的苹果文档](https://link.juejin.cn/?target=https%3A%2F%2Fxiaozhuanlan.com%2Ftopic%2F0483621759 \"https://xiaozhuanlan.com/topic/0483621759\")\n>     \n> -   WWDC22内参: [Swift-DocC 新特性](https://link.juejin.cn/?target=https%3A%2F%2Fxiaozhuanlan.com%2Ftopic%2F3658492071 \"https://xiaozhuanlan.com/topic/3658492071\")\n>     \n> -   WWDC21: [Meet DocC documentation in Xcode](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10166%2F \"https://developer.apple.com/videos/play/wwdc2021/10166/\")\n>     \n\n## 文档编写\n\n这里以 SlothCreator 这个在前几年的 Session 中出现的示例项目为例，演示如何利用 DocC 编写更加丰富的文档。\n\nSlothCreator 是一个并用于创建管理树懒的软件包。这里首先使用 Xcode 15 中打开该软件包，通过 Build for Documentation 选项我们可以对当前的文档状态进行一个初步评估。\n\nSwift-DocC 会自动为项目中的相关 API 创建页面，同时也包括前面提到的代码注释，在没有进行过多手动适配的情况下，DocC 是开箱即用的，会提供一个基本的文档页面。\n\n![image](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78cba06e2cb42369c03b1b9db968904~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6f65c14a164e17b38073daf9bd0f5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n上图为 SlothCreator 的顶级文档页面，通过一句话的摘要开始，然后在 Overview 中概述框架的全部内容。\n\n再往下则是主题部分，主题用于将文档的不同页面组织成逻辑组。\n\n首先，我们有 Essentials 主题，其中包含针对框架新手的介绍性文档。然后是树懒的创建、树懒的喂养和树懒视图小组。组织良好的主题组是为框架创建可发现和可访问文档的关键。\n\n### 扩展文档支持\n\n在页面的最下面是在 Swift 5.8 工具链中 DocC 中引入的扩展模块文档支持，这里可以看到 SlothCreator 为 SwiftUI/Image 提供了一个 init 方法并添加了注释。\n\n![image](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6aa70f2b03a4d22aeedf4561ba83466~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 相关的社区提案原文 [Document Extensions to External Types Using DocC](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fdocument-extensions-to-external-types-using-docc%2F56060 \"https://forums.swift.org/t/document-extensions-to-external-types-using-docc/56060\")\n> \n> 该功能完全由社区贡献驱动，并涉及 Swift-DocC 和 Swift 编译器的协调更改。\n\n### **文档预览编辑器**\n\n我们可以看到该扩展有一些基本的文档注释，但是和之前的文档相比，它的质量要差一些。\n\n使用 Xcode 15 的文档预览编辑器，我们将对它添加一些额外的文档。\n\n打开对应的 Swift 文件并开启文档预览（编辑器右上角开启 Assistance 模式，并选择 Documentation Preview）\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e18d727711ee4bd4bd5e35e3bcb14cf6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f0ad11d5dc42f6ba8f83bdac04ebe1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n现在，当我们在 Swift 源文件、Objective-C 头文件和 Markdown 文件之间移动时，文档预览将保持活动状态。\n\n在原来简单文档的基础上，我们进行以下迭代\n\n1.  在摘要后换行添加一段讨论内容\n    \n2.  继续添加一些代码示例，并标记语言为 Swift\n    \n3.  将准备好的图片放入文档目录中，并在文档注释中引用\n    \n\n> DocC 会在文档目录中寻找到最合适的图片变种，比如 2x 和 3x 图片、浅色模式图片和深色模式图片等\n> \n> 我们只需要按照对应的格式命名（eg. iceSloth~dark@2x）并在文档注释中使用原名称引用即可\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf32cdf2a73f45ebb381c8adff4d32f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### **Swift-DocC Directive**\n\nSwift-DocC 的语法基于 Github Flavored Markdown，但是也提供了一些额外的指令来支持更多的功能\n\n> 如 Image 和 Video 指令分别提供了对图片和视频的支持。\n\n在最初版本的 DocC 中指令只支持在 Tutorial 格式中使用，随着社区的反馈，文档工作组最终扩展了它的使用，目前我们可以在任何地方使用 DocC 指令。\n\n> 社区 Pitch [Supporting more dynamic content in Swift-DocC reference documentation](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fsupporting-more-dynamic-content-in-swift-docc-reference-documentation%2F59527 \"https://forums.swift.org/t/supporting-more-dynamic-content-in-swift-docc-reference-documentation/59527\")\n> \n> 相关 PR [Add @Image and @Video directives to reference documentation with caption support](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-docc%2Fpull%2F381 \"https://github.com/apple/swift-docc/pull/381\")\n\nDocC 指令主要用于额外进行文档的创造性定制，没有一种强制规范约定必须使用。\n\n比如插入图片既可以使用 Image 指令 - @Image(source: String, alt: String?)\n\n也可以使用传统的 GFM 语法(!\\[Alt Text\\](Image Link))\n\n我们将通过发现问题并选择使用一些合适指令来润色 SlothyCreator 的示例代码文章。\n\n在原始的 Sloth Creator 文章中，我们发现了以下四个问题：\n\n1.  尽管此页面有示例代码，它和任何其他文章看起来是一样\n    \n2.  示例代码链接很难识别和发现\n    \n3.  正文内容是围绕两个图像段落对构建的，图像与它们的段落没有明确关联且图片占用了太多的空间\n    \n4.  页面底部用 3 张截图展示了不同语言的示例，但是它们之间没有关联且占用了太多空间。\n    \n\n![image](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea1f9dc70b2468595f0385e890671cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n___\n\n对于问题 1 和问题 2，我们使用 Metadata 指令来自定义该页面的元数据，其中包括页面的类型、页面行动和页面图片。\n\n```\n@Metadata {\n    @CallToAction(\n        purpose: link,\n        url: \"https://example.com/slothy-repository\")\n    @PageKind(sampleCode)\n    @PageImage(\n        purpose: card, \n        source: \"slothy-card\", \n        alt: \"Two screenshots showing the Slothy app. The first screenshot shows a sloth map and the second screenshot shows a sloth power picker.\")\n}\n```\n\n![image](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c21850446d54dc68b65f7451982a5be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> 目前 PageKind 只支持两种类型，article 和 sampleCode，如果有其他更多的需求，可以在 Swift 论坛中进行反馈。\n\n___\n\n对于问题 3，我们使用 Row 和 Column 指令来重新组织页面内容，可以通过 size 参数来覆盖默认大小，让我们更好地控制页面布局。\n\n```\n@Row {\n    @Column(size: 2) {\n        First, you customize your sloth by picking its \n        ``Sloth/power-swift.property``.\n        The power of your sloth influences its abilities and how well\n        they cope in their environment. The app displays a picker view\n        that showcases the available powers and previews your sloth\n        for the selected power.\n    }\n    \n    @Column {\n        ![A screenshot of the power picker user interface with four powers displayed – ice, fire, wind, and lightning](slothy-powerPicker)\n    }\n}\n```\n\n![image](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70fb77024edd44468b002b370c28261d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n___\n\n对于问题 4，我们使用 TabNavigator 指令来重新组织页面内容\n\nTabNavigator 指令包含任意数量的子 Tab 指令，每个 Tab 指令都有一个标题和内容。\n\n```\n@TabNavigator {\n    @Tab(\"English\") { ... }\n    @Tab(\"Chinese\") { ... }\n    @Tab(\"Spanish\") { ... }\n}\n```\n\n![image](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/937e626bf9c9494b9272d492bf341845~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n___\n\n最后我们希望使用该文档的受众能够更容易地发现它，所以我们回到 SlothCreator 文档的顶级页面，通过 Links 指令并定义视觉参数来指向它们。\n\n```\n@Links(visualStyle: detailedGrid) {\n    - <doc:GettingStarted>\n    - <doc:SlothySample>\n}\n```\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8cdd4f8478e488891a7b7fdf83bd5ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nSlothCreator 文档在短时间内通过各种 Dirctive 指令得到了很大的改善，关于各个指令的使用方式可以在以下文档中查询\n\n-   [Open Source Swift-DocC Documentation](https://link.juejin.cn/?target=https%3A%2F%2Fwww.swift.org%2Fdocumentation%2Fdocc \"https://www.swift.org/documentation/docc\")\n    \n-   [Apple Swift-DocC Documentation](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fdocc \"https://developer.apple.com/documentation/docc\")\n    \n\n> Tips:\n> \n> 二者目前并无差别，前者通过 Github Action 部署在 Swift 开源项目上\n> \n> 后者为 Apple 的私有部署并配置使用了 Xcode 风格的主题\n\n![image](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/119e16971b7a4f90a20319da9d9df245~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 主题配置\n\n在 Xcode 中查看的文档默认使用了 Apple 风格的主题，而通过 [Swift-DocC-Render](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-docc-render \"https://github.com/apple/swift-docc-render\") 转化得到的 Web 版文档则会使用我们配置的主题，如果没有进行配置则会使用默认主题。\n\n但是自定义主题不一定是我们需要定制文档的正确方式，请在使用主题配置前知晓以下事项\n\n1.  主题配置是一个全局网页配置，会影响所有的文档。\n\n如果您想要为单个文档定制，可以使用 Metadata 指令。\n\n2.  Swift-DocC 主题是针对网页部署的，在 Xcode 中会被忽略生效。\n\n如果确实希望自定义同时出现在 Xcode 和 Web 中，最好使用指令来完成。\n\nSwift-DocC 中的主题由具有特定名称 \"theme-settings.json\" 文件定义，我们可以将其放入文档目录中来生效。\n\n![image](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0338905c1e174aeeb6f612bb5b731752~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n对于 SlothCreator，我们会自定义它的颜色和字体来匹配对应整体网站的设计。这些定制只是 Swift-DocC 主题的开始，如果有兴趣更进一步，可以阅读 Swift-DocC 的相关文档了解。\n\n![image](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830d2e70b7ef432c8432bc46791154d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5132d1cfa8b144e2b0bd71fa0558b7e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 文档导航\n\nSwift 5.8 工具链中的 DocC 还提供了全新的快速导航功能，使在页面之间进行导航变得更加容易。\n\n与 Xcode 的 Quick Open 功能类似，它允许我们通过键盘快捷键并键入其名称进行搜索并直接跳转到页面。\n\n![image](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96fca3a2dfa54bb19b0a880c82b2470f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n> Swift-DocC Quick Navigation 也是一个完全社区驱动的成果\n> \n> 感兴趣的同学可以在这里了解更多的上下文 [Quick navigation in DocC Render](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fquick-navigation-in-docc-render%2F55942 \"https://forums.swift.org/t/quick-navigation-in-docc-render/55942\")\n\n借助新的快速导航弹出窗口和现有的导航边栏，Swift-DocC 为浏览在线文档提供了和 Xcode 中浏览文档一样的优秀体验。\n\n## 总结\n\n本文介绍了 Swift-DocC 的进阶使用方式，以及如何通过指令来定制文档的内容和外观。\n\n从 21 年的开源但是只能基本只能在 Xcode + Swift Package 上使用，到逐渐丰富功能和对 Web 更友好的部署，以及 [DocC Plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-docc-plugin \"https://github.com/apple/swift-docc-plugin\") 的一键集成接入，相信 DocC 会成为未来 Swift 生态中非常重要的一部分。\n\n> DocC Plugin 目前对 C 系语言的支持还在持续跟进中 [Swift-DocC-Plugin-Mix-Demo](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FKyle-Ye%2Fswift-docc-plugin-mix-demo \"https://github.com/Kyle-Ye/swift-docc-plugin-mix-demo\")\n\n总的来说，我对于今年 DocC 的更新还是非常满意的。同时不少大厂（如字节）内部的部分新框架也已经开始迁移到使用 DocC 进行文档的维护和迭代。\n\n## 尾声\n\n目前 DocC 的所有重大功能都会在 [Swift Forums](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Fc%2Fswift-documentation%2F92 \"https://forums.swift.org/c/swift-documentation/92\") 上进行公开讨论，并通过双周维度的 Workgroup 会议进行决策。\n\n如果你也希望为 DocC 进行贡献，欢迎提交 PR 或者参与到 Swift Forums 的讨论中来。\n\n> 一些可以参考的优秀的 DocC 文档\n> \n> -   [The Swift Programming Language](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.swift.org%2Fswift-book%2Fdocumentation%2Fthe-swift-programming-language \"https://docs.swift.org/swift-book/documentation/the-swift-programming-language\")\n>     \n> -   [Swift-DocC](https://link.juejin.cn/?target=https%3A%2F%2Fwww.swift.org%2Fdocumentation%2Fdocc \"https://www.swift.org/documentation/docc\")\n>     \n> -   [SwiftUI Tutorial](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Ftutorials%2Fswiftui \"https://developer.apple.com/tutorials/swiftui\")\n>     \n> -   [ChimeKit](https://link.juejin.cn/?target=https%3A%2F%2Fswiftpackageindex.com%2FChimeHQ%2FChimeKit%2Fmain%2Fdocumentation%2Fchimekit \"https://swiftpackageindex.com/ChimeHQ/ChimeKit/main/documentation/chimekit\")\n>', 'public/uploads/1694329754558.png', 5, 7, 1, 257, '2023-09-10 07:09:23', 1);
INSERT INTO `article` VALUES (80, 4, 'TypeScript小状况之interface与type的对比', '持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第7天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \"https://juejin.cn/post/7147654075599978532\")\n\n> 在日常使用typescript的过程中，很容易发现`interface`和`type`在一些情况下都能使用，那究竟它们之间有什么区别？什么时候该用`interface`，什么时候该用`type`呢？\n\n先说结论：\n\n| 比较项 | interface | type |\n| --- | --- | --- |\n| 写法 | 跟class类似 | 变量赋值 |\n| 拓展已有类型 | 使用extends关键字 | 使用交集(intersections)的形式 |\n| 可声明类型 | 对象、函数 | 所有类型皆可 |\n| 重复声明 | 合并字段 | 报错 |\n| 重命名类型 | 只能以extends的形式重名对象或函数 | 可以重命名任意类型 |\n\n## 写法\n\n### `interface`\n\n跟其他编程语言类似，`interface`本身是对`class`的抽象，所以写法上也和`class`一样。\n\n```\ninterface IObj {\n    a: string\n    b: number\n    c: boolean\n}\n```\n\n### `type`\n\n`type`根据官方的定义，叫做类型别名(type aliases)，直观的理解就是给一个已有类型创建别名。这个已有类型可以是另一个类型别名，也可以是类型的字面量。看到这里，可以发现这个就和JS的变量的定义很类似；所以，它的写法就和变量赋值是一样的。\n\n```\ntype TObj = {\n    a: string\n    b: number\n    c: boolean\n}\n```\n\n## 拓展已有类型\n\n### `interface`\n\n需要注意的是，拓展的子接口不能把父接口已有的字段重新声明为**其他类型**，否则TSLint会报错。\n\n```\ninterface IObj {\n    a: string\n    b: number\n    c: boolean\n}\ninterface ISubObj extends IObj {\n    d: string\n}\n\n// Interface \'ISubObj2\' incorrectly extends interface \'IObj\'. \n    // Types of property \'c\' are incompatible. \n        // Type \'string\' is not assignable to type \'boolean\'.\ninterface ISubObj2 extends IObj {\n    c: string\n    d: string\n}\n```\n\n### `type`\n\n同样需要注意的重新声明为**其他类型**的情况，在`type`的使用下，类型声明是不会报错，因为TS解析为这是一个never（交集为空），所以报错的是在变量赋值的时候。\n\n```\ntype TObj = {\n    a: string\n    b: number\n    c: boolean\n}\n// 正确的拓展写法\ntype TSubObj = TObj & {\n    d: string\n}\n\n// 不正确的拓展写法\ntype TSubObj2 = TObj & {\n    c: string\n    d: string\n}\n\nconst obj2: TSubObj2 = {\n    // Type \'string\' is not assignable to type \'never\'.\n    a: \'abc\',\n    // Type \'number\' is not assignable to type \'never\'.\n    b: 1,\n    // Type \'string\' is not assignable to type \'never\'.\n    c: \'abc\',\n    // Type \'string\' is not assignable to type \'never\'.\n    d: \'xyz\'\n}\n```\n\n## 可声明类型\n\n### `interface`\n\n`interface`只能声明对象(数组)和函数\n\n```\ninterface IObj {\n    a: string\n    b: number\n    c: boolean\n}\ninterface IFunc {\n    (a: number): boolean\n}\ninterface IArr {\n    [k: number]: string\n}\n\nconst obj: IObj = {\n    a: \'abc\',\n    b: 1,\n    c: true,\n}\nconst fn: IFunc = a => {\n    return a >= 0\n}\nconst arr: IArr = [\'a\', \'b\', \'c\']\n```\n\n### `type`\n\n`type`不仅能声明对象(数组)和函数，还可以对其他类型甚至原始类型重命名。\n\n但要注意一点，当某个类型是联合类型(union type)时，是不能被类(class) 进行`implements`\n\n```\ntype TMyStr = string\ntype TMyNum = number\ntype TSomeChar = \'a\' | \'b\' | \'c\'\ntype TObj = {\n    a: TMyStr\n    b: number\n    c: boolean\n}\ntype TFunc = (a: number, b: number) => boolean\ntype TArr = {\n    [k: number]: string\n}\n\nconst str: TMyStr = \'hhhhh\'\nconst num: TMyNum = 2333\nconst somechar: TSomeChar = \'a\'\n// Type \'\"x\"\' is not assignable to type \'TSomeChar\'.\nconst somechar2: TSomeChar = \'x\'\nconst obj: TObj = {\n    a: \'abc\',\n    b: 1,\n    c: true,\n}\nconst fn: TFunc = (a, b) => {\n    return a >= b\n}\nconst arr: TArr = [\'a\', \'b\', \'c\']\n```\n\n```\ntype TObj = {\n    a: TMyStr\n    b: number\n    c: boolean\n}\ntype TObj2 = TObj | {\n    d: boolean\n}\n\n// A class can only implement an object type or intersection of object types with statically known members.\nclass myClass implements TObj2 {\n    a = \'xyz\'\n    b = 666\n    c = false\n}\n```\n\n另外，`type`还能使用`typeof`关键字把变量/字面量转化为类型，TS编译器会根据变量/字面量的值进行分析，判定这些值对应的类型。\n\n```\nconst foo = {\n    name: \'Jack\',\n    age: 18\n}\ntype Tfoo = typeof foo\n```\n\n![typeof.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597e527086dc467280633fb7b99a525a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 重复声明\n\n### `interface`\n\n重复声明同名`interface`，会把声明的字段合并，类似于上面[拓展](https://juejin.cn/post/7160644033792966669#heading-4 \"#heading-4\")，已有的字段重新声明为**其他类型**也是会导致报错的。\n\n```\ninterface IObj {\n    a: string\n    b: number\n    c: boolean\n}\ninterface IObj {\n    d: string\n}\n\nconst obj: IObj = {\n    a: \'abc\',\n    b: 1,\n    c: true,\n    d: \'xyz\'\n}\n```\n\n### `type`\n\n`type`则是直接报错有重复的标识符。\n\n```\n// Duplicate identifier \'TObj\'.\ntype TObj = {\n    a: string\n    b: number\n    c: boolean\n}\n// Duplicate identifier \'TObj\'.\ntype TObj= {\n    d: string\n}\n```\n\n## 重命名类型\n\n### `interface`\n\n本身`interface`不支持重命名类型，但是可以使用`extends`的形式去重命名，然而在实际开发中我个人并**不推荐这种做法**。因为本质上没有拓展任何的字段，只是利用了语法上的特点，但会造成语义上和逻辑上的误解，降低代码可读性和理解的成本。\n\n```\ninterface IObj {\n    a: string\n    b: number\n    c: boolean\n}\ninterface IObj2 extends IObj {\n}\n\nconst obj: IObj2 = {\n    a: \'abc\',\n    b: 1,\n    c: true,\n}\n```\n\n### `type`\n\n`type`正如它的定义所示，是类型别名，它不仅可以重命名自己声明的类型，还能对其他类型甚至原始类型重命名。\n\n```\ntype TMyStr = string\ntype TObj = {\n    a: TMyStr\n    b: number\n    c: boolean\n}\ntype TObj2 = TObj\n\nconst obj: TObj2 = {\n    a: \'abc\',\n    b: 1,\n    c: true\n}\n```\n\n```\ntype TMyStr = string\ninterface IObj {\n    a: TMyStr\n    b: number\n    c: boolean\n}\ntype TObj = IObj\n\nconst obj2: TObj = {\n    a: \'abc\',\n    b: 1,\n    c: true\n}\n```\n\n## 总结\n\n综上所述，`interface`和`type`有不少相似之处，特别是在对象(数组)和函数的类型声明上，都可以相互替换使用。\n\n`interface`更专注于对象(数组)和函数的抽象定义；`type`则更接近是typescript的一个包罗万象的兜底方案，而且能玩出很多花活和骚操作。具体可以看之前写的其他关于typescript的文章，例如我最近写的这两篇：[TypeScript小状况之用数组元素组装数据类型](https://juejin.cn/post/7150589726339268622 \"https://juejin.cn/post/7150589726339268622\") 和 [TypeScript小状况之选且只选一个](https://juejin.cn/post/7150316226009382919 \"https://juejin.cn/post/7150316226009382919\")。\n\n我自己的简单宗旨是，在两者皆适用的场景下，尽可能优先使用`interface`，其他情况则用`type`。', 'public/uploads/1694355503304.png', 2, 4, 0, 997, '2023-09-10 14:18:30', 1);
INSERT INTO `article` VALUES (81, 2, '1Ms.', '1Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. Such sessions are also susceptible to session hijacking, where a malicious user takes over your session once you have authenticated. If it scares you, it might be a good thing to try. Actually it is just in an idea when feel oneself can achieve and cannot achieve. If you wait, all that happens is you get older. There is no way to happiness. Happiness is the way. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. If you wait, all that happens is you get older. A query is used to extract data from the database in a readable format according to the user\'s request. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview. The first step is as good as half over. Anyone who has ever made anything of importance was disciplined. Actually it is just in an idea when feel oneself can achieve and cannot achieve. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. In the middle of winter I at last discovered that there was in me an invincible summer.', '', 1, 2, 0, 610, '2023-10-17 15:29:42', 0);
INSERT INTO `article` VALUES (82, 7, 'MongoDB 学习干货分享', '![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/450b987877724be5a443e6cfa2a70c3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## MongoDB学习笔记\n\n## 简介\n\nMongoDB 是一个开源的文档数据库，以其灵活性、可伸缩性和性能而闻名。在本文中，我们将为您提供一些关于 MongoDB 的干货分享，包括安装和配置、基本操作、高级查询和性能优化等方面的内容。我们将通过具体的代码示例来帮助您更好地理解和掌握 MongoDB。\n\n## 目录\n\n1.  安装和配置 MongoDB\n2.  连接到 MongoDB\n3.  基本操作 3.1 创建数据库和集合 3.2 插入文档 3.3 查询文档 3.4 更新文档 3.5 删除文档\n4.  高级查询 4.1 查询条件 4.2 投影查询 4.3 排序和限制 4.4 聚合查询 4.5 索引\n5.  性能优化 5.1 查询性能优化 5.2 写入性能优化 5.3 索引性能优化 2\n\n## [](https://link.juejin.cn/?target=)安装MongoDB\n\n#### [](https://link.juejin.cn/?target=)软件下载地址\n\n官网提供的软件下载地址：[www.mongodb.com/try/downloa…](https://link.juejin.cn/?target=https%3A%2F%2Fwww.mongodb.com%2Ftry%2Fdownload%2Fcommunity \"https://www.mongodb.com/try/download/community\")\n\n在网页 “On-premises” 中，分别提供企业版和社区版。\n\n-   MongoDB-Enterprise-Server：收费的企业版\n-   MongoDB-Community-Server：免费的社区版\n\n> MongoDB 近期强行修改了免费开源政策(主要针对云厂商)，企业版目前为收费版(所有云服务商提供的MongoDB产品都需要给他们交钱)，社区版为免费版。MongoDB企业版收费之后，会对MongoDB流行度会有一定的影响。\n\n根据操作系统，选择适合的版本和文件格式，并开始下载。\n\n> 点击下载之后网页会跳转到输入个人信息的页面，无需理会。  \n> 大约3秒后，会自动开始下载刚才选择的软件安装包。  \n> 目前最新稳定版本为 MongoDB 4.2.7\n\n#### [](https://link.juejin.cn/?target=)Linux下安装MongoDB\n\n本人的服务器为腾讯云 CentOS 7.6，所以下载时，Platform 这一项选择：RedHat/CentOS 7.0\n\n#### [](https://link.juejin.cn/?target=)第一种安装方式：yum 安装\n\n咨询过腾讯技术人员，腾讯云 yum 默认安装的 MongDB 版本为2.6.12，由于版本过低，所以需要我们手工创建 yum源文件，以便自定义安装MongoDB的版本。\n\n**第1步：使用 vim 命令创建 yum源文件**\n\n文件保存路径为 /etc/yum.repos.d/mongodb-org-4.2.repo，文件内容为：\n\n```\n[mongodb-org-4.2]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/7Server/mongodb-org/4.2/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc\n```\n\n> 注意：  \n> 上面代码baseurl中 “redhat/7Server/”，“7Server”对应本人的系统版本，你需要根据你的系统版本来修该值。\n\n> 建议：\n> \n> 1.  不建议将 mongodb-org-4.2.repo 放到别的目录中，虽然没问题但也没什么意义。\n> 2.  本人根本不建议使用 yum安装，因为 yum 安装虽然简单，但也伴随着其他一些问题，例如我不希望yum自动升级该软件，或者我希望自定义 MongoDB 的安装目录等。\n\n**第2步：执行安装命令**\n\n```\nyum install -y mongodb-org\n```\n\n耐心等待，执行完成后即安装成功。\n\n#### [](https://link.juejin.cn/?target=)第二种安装方式：.tgz 安装\n\n**第1步：在指定的目录中，下载 MongoDB对应的 .tgz 安装包**\n\n目前最新版本文件安装包地址：[fastdl.mongodb.org/linux/mongo…](https://link.juejin.cn/?target=https%3A%2F%2Ffastdl.mongodb.org%2Flinux%2Fmongodb-linux-x86_64-rhel70-4.2.7.tgz \"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.7.tgz\")\n\n假设我希望将来 MongoDB 安装目录为系统根目录下的 /software/mongodb/，那么我可以先将 .tgz 文件下载到 software目录中。\n\n-   下载方法1：先下载该文件，然后通过 xftp 软件上传到服务器指定的目录中(例如根目录下的 software)\n-   下载方法2：直接在服务器中，执行下面命令：\n\n```\nwget -P /software/ https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.7.tgz\n```\n\n> 注意：  \n> 如果你不确定服务器上是否安装 wget，可执行 rpm -qa|grep wget，若已安装会显示wget版本号。若未安装则执行 yum install -y wget 即可安装。\n\n**第2步：解压 .tgz 安装包**\n\ncd 到 .tgz 下载目录(例如 /software/)，然后执行：\n\n```\ntar -zxvf mongodb-linux-x86_64-rhel70-4.2.7.tgz  \n```\n\n解压即安装成功，MongoDB主程序就在 /software/mongodb-linux-x86\\_64-rhel70-4.2.7/bin/ 中。\n\n**第3步：重命名**\n\n默认MongoDB目录名字有点长，我们可以将其重命名，改为\"mongodb\"，进入 software 目录中，执行：\n\n```\nmv mongodb-linux-x86_64-rhel70-4.2.7 mongodb\n```\n\n这样修改以后，目录名看着清爽简洁多了。\n\n> 当然你也可以完全忽略这一步，不进行重命名，这样目录名虽然有点长，但是版本标注的很清晰。\n\n**第4步：创建软连接**\n\n执行：\n\n```\nln -s /software/mongodb/bin/* /usr/local/bin/\n```\n\n软连接创建好后，这样以后在任意目录，都可以执行 mongo 命令。\n\n> 注意：  \n> 若你没有修改默认的 .tgz 解压后的目录名，则执行：\n\n```\nln -s /software/mongodb-linux-x86_64-rhel70-4.2.7/bin/* /usr/local/bin/\n```\n\n**第5步：检测并连接 MongoDB**\n\n任意目录执行：\n\n```\nmongo\n```\n\n当看到：\n\n```\nMongoDB shell version v4.2.7\nconnecting to: mongodb://127.0.0.1:27017/?compressors=disabled&gssapiServiceName=mongodb\n...\n```\n\n即表示 MongoDB 安装成功。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23windows%25E4%25B8%258B%25E5%25AE%2589%25E8%25A3%2585%25E4%25BB%2585%25E9%2599%259064%25E4%25BD%258D%25E7%25B3%25BB%25E7%25BB%259F \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BB%85%E9%99%9064%E4%BD%8D%E7%B3%BB%E7%BB%9F\")Windows下安装(仅限64位系统)\n\n下载软件：[fastdl.mongodb.org/win32/mongo…](https://link.juejin.cn/?target=https%3A%2F%2Ffastdl.mongodb.org%2Fwin32%2Fmongodb-win32-x86_64-2012plus-4.2.6-signed.msi \"https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2012plus-4.2.6-signed.msi\")  \n安装软件：下一步 下一步，在倒数第2步界面左下角有一个选项“Install MongoDB Compass”，可以取消勾选，稍后单独安装 MongoDB Compass  \n运行软件：安装完成后，找到 安装目录\\\\MongoDB\\\\Server\\\\4.2\\\\bin\\\\mongo.exe，运行mongo.exe  \n编写测试：\n\n```\nvar message = \'hello mongodb\'\npritejson(message)\n```\n\n注意：当MongoDB安装成功后，会默认自动创建3个数据库 admin、config、local 无需删除这3个，自己可以再新建别的数据库使用。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%25AE%2589%25E8%25A3%2585mongodb-compass \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%AE%89%E8%A3%85mongodb-compass\")安装MongoDB Compass：\n\nMongoDB Compass 是图形可视化管理MongoDB数据库的工具。若服务器系统为 CentOS 肯定就不用考虑安装这个了，因为服务器根本就没有图形化窗口，但是在 Windows 系统下，非常有必要安装这个软件。  \n若在安装 MongoDB 过程中，没有同步安装 MongoDB Compass，需要手工下载并安装。  \n下载软件：[downloads.mongodb.com/compass/mon…](https://link.juejin.cn/?target=https%3A%2F%2Fdownloads.mongodb.com%2Fcompass%2Fmongodb-compass-1.21.2-win32-x64.msi \"https://downloads.mongodb.com/compass/mongodb-compass-1.21.2-win32-x64.msi\")  \n安装软件：下一步 下一步  \n运行软件：运行MongoDBCompass.exe，进入软件后，先看完软件介绍后，点击继续按钮，即可看到当前本机MongoDB数据状态。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23mongod%25E5%2592%258Cmongo%25E6%25A6%2582%25E5%25BF%25B5%25E8%25A7%25A3%25E9%2587%258A \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#mongod%E5%92%8Cmongo%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A\")mongod和mongo概念解释\n\nmongod 是 MongoDB 的服务程序，用来创建启动数据库；  \nmongo 是连接和操作 mongod 创建的数据库的工具；\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%2590%25AF%25E5%258A%25A8mongod \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%90%AF%E5%8A%A8mongod\")启动mongod\n\n推荐使用 配置文件(mongod.conf) 的方式启动 mongod。\n\nLinux系统下启动：\n\n```\nmongod -f mongod.conf\n```\n\nWindows系统下启动 (cmd命令窗口，右键，以管理员身份运行)：\n\n```\nmongod.exe -f mongod.conf\n```\n\n> 若不使用配置文件启动 mongod，采用直接 mongod + 参数 的形式，则需要输入多项对应的参数，略显麻烦。\n\nmongod.conf 配置参考：\n\n```\n#数据库目录设置\nstorage:\n  dbPath: ../data\n  journal:\n    enabled: true\n    \n#日志相关设置\nsystemLog:\n  destination: file\n  logAppend: true\n  path:  ../log/mongod.log\n\n#网络端口设置\nnet:\n  port: 27027\n  bindIp: 127.0.0.1\n\n#是否后台运行设置。 特别说明：windows系统不支持该项，不可以有此项设置\nprocessManagement:\n  fork: true\n\n#用户认证设置\nsecurity:\n  authorization: enabled\n```\n\n#### [](https://link.juejin.cn/?target=)Windows系统启动 mongod 的注意事项\n\n1.  可以使用 mongo.exe 直接连接 mongod所创建的数据库，但是直接运行 mongo.exe 连接时无法设置连接参数，例如端口为27017，无法设置账户密码等。如果 mongod 创建的数据库端口不是 27017，则 mongo.exe 连接失败，窗口会自动关闭，此时只能通过 cmd 命令窗口来连接。\n2.  windows系统命令窗口下执行 mongod -f mongod.conf 之后，即使成功启动，也不会有任何文字提示。\n3.  windows系统命令窗口不支持后台运行(fork:true)，因此 启动 mongod 之后，千万不要关闭当前 cmd 命令窗口，因为一旦关闭就相当于把 mongod 也关闭了。 想进行 mongo 命令连接 mongod，只能再新建一个 cmd 命令窗口进行操作。\n\n> 特别注意：\n> \n> 1.  需要用 管理员账户 运行 cmd命令窗口\n> 2.  启动时，执行的代码是 `mongod.exe -f mongod.conf` ，一定要注意是 `mongod.exe`\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E7%25BB%2593%25E6%259D%259Fmongod%25E8%25BF%259B%25E7%25A8%258B \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%BB%93%E6%9D%9Fmongod%E8%BF%9B%E7%A8%8B\")结束mongod进程\n\n执行以下代码：\n\n```\nkillall -9 mongod\n```\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23mongodb%25E4%25BC%2598%25E5%258A%25BF \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#mongodb%E4%BC%98%E5%8A%BF\")MongoDB优势\n\nMongoDB以JSON文档形式储存数据。\n\n以下笔记来源于：唐建法的《MongoDB高手课》视频教程\n\n对于JSON而言：  \n1、简单直观：以自然的方式来建模(自由定义数据模型)，以直观的方式与数据库交互(JSON与Object可直接相互转换)。  \n2、结构灵活：弹性模式从容相应需求的频繁变化(不要求某集合中所有元素属性都必须一致)。  \n3、快速开发：做更少的事，写更少的代码(可直接把数据以Object形式传递给数据库，而不像Mysql那样需要把一条数据中的各个属性拆分出来)。\n\n不需要考虑错综复杂的关系模型、一目了然的对象模型。\n\n对于开发人员而言：  \n1、灵活：快速响应业务变化，具体表现为：\n\n-   多形性：同一个集合中可以包含不同字段(类型)的文档对象。即JSON的特性，例如允许某集合中前100名用户有一个属性，而100名以后的用户没有该属性。\n-   动态性：线上修改数据模式，修改时应用和数据库均无需下线。 例如某集合所有数据由原来的每条10个属性增加到12个属性，这个操作可以直接在线上操作，无需让数据库先关停修改好后再上线。\n-   数据治理：支持使用JSON Schema 来规范数据模式。在保证模式灵活动态的前提下，提供数据治理能力。 简单来说就是MongoDB也可以像Mysql那样对每个表(在MongoDB中叫集合)进行数据格式规范。\n\n2、快速：JSON模型的快速特性(数据库运行效率、程序员开发效率)\n\n-   数据库引擎只需要在一个存储区读写：相对Mysql需要建立多个关联表而言，MongoDB某一集合所有数据均在同一个存储区里。\n-   反范式、无关联的组织极大优化查询速度：对于计算机而言，修改一条数据需要“定位和读写”，而“定位”和“读写”所需要消耗的性能占比，分别为95%和5%。 也就是说对于修改某条数据而言“定位”是最花费时间的。而Mysql通常为多表，不同表之间相互切换定位所花费时间会更多。最为关键的是开发者编写的代码，如果是Mysql需要编写多个表的操作代码，如果是MongoDB则直接操作一个集合即可。\n-   程序API自然，开发快速：JSON非常接近程序员原本的对象操作方式，所以开发效率高。\n\n对于运维人员而言：  \n1、原生的高可用和横向扩展能力：\n\n-   节点 复制集(Replica Set)数量可以是2-50个，默认安装为3个(1个Primary和2个Secondary)\n-   自动恢复，若主节点发生故障，从节点可自动恢复替换主节点。\n-   支持多中心部署，多中心容灾，数据同步。\n-   滚动服务。 例如先只修改其中一个副节点，然后通过 MongoDB复制集 的方式将其他节点都进行修改，从而实现数据库不下线的情况下进行数据库改造升级。\n\n2、横向扩展能力：\n\n-   通过分片集群，可以无缝扩展\n-   应用全透明\n-   多种数据分布策略\n-   轻松支持TB-PB数量级\n\nMongoDB技术优势总结：  \n1、JSON结构和对象模型接近、开发代码量低  \n2、JSON的动态模型意味着更容易响应新的业务变化需求  \n3、复制集提供高可用  \n4、分片架构支持海量数据和无缝扩容\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23mongodb-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%2592%258C%25E9%259B%2586%25E5%2590%2588-%25E7%259B%25B8%25E5%2585%25B3%25E7%259F%25A5%25E8%25AF%2586 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#mongodb-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9B%86%E5%90%88-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86\")MongoDB 数据库和集合 相关知识\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\")数据结构\n\nMongoDB数据结构为：  \n1、MongoDB下面有若干个数据库(db)  \n2、每个数据库下有若干个集合(collection)  \n3、每个集合里储存若干个文档(JSON格式的数据)  \n即：dbs -> db -> collection -> JSON document\n\n因此，如果想操作某条数据(增删改查)，正确的流程是：  \n1、先使用 use xxx 切换到该数据库  \n2、明确要修改的集合名字 db.xx  \n3、再使用具体的增删改查函数进行操作\n\n举例：假设moodmap数据库中的user集合要新增一条数据，对应的执行命令为：  \n1、use moodmap 切换到moodmap数据库  \n2、db.user.insert({\'name\':\'puxiao\'}) db.user表示要修改的集合名字为user，insert()为添加数据的函数\n\n请注意：不可以直接给某数据库添加数据，只能给该数据库下某集合添加数据。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%259F%25BA%25E7%25A1%2580%25E7%259F%25A5%25E8%25AF%2586 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\")基础知识\n\n1、当MongoDB安装成功后，会自动创建3个数据库 admin、config、local  \n2、与此同时MongoDB还会隐形存在一个数据库 test。若未切换到某具体的数据库，此时若执行向某集合中添加数据命令，那么MongoDB会启用一个名为 test 的数据库，并把数据添加到 test 中。基于这个原因，你自己创建数据库时切忌不要使用 test 来当数据库名字。  \n3、如果只创建但是从未添加过数据，则该数据库不会在 MongoDB Compass中出现，使用 use dbs 查看全部数据库也看不到。就好像默认的 test数据库最开始是不显示的，只有在未指定数据库前提下进行某集合数据添加后，MongoDB把这条添加的数据归类到test中，此时 test 数据库才可以被查看到。  \n4、在MongoDB的shell命令中，属性名是可以不加引号的，属性值需要加引号，既可以是单引号也可以是双引号。如果属性值是数字，则可不加引号。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%25BC%2580%25E5%2590%25AF%25E6%259F%25A5%25E7%259C%258B%25E5%2585%25B3%25E9%2597%25AD%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%BC%80%E5%90%AF%E6%9F%A5%E7%9C%8B%E5%85%B3%E9%97%AD%E6%95%B0%E6%8D%AE%E5%BA%93\")开启、查看、关闭数据库\n\n开启某数据库：use xxx  \n查看当前所在数据库：db  \n查看全部数据库：show dbs  \n关闭当前数据库：db.shutdownServer() 此为优雅关闭数据库的方式，即数据库先把当前全部认为执行完毕后才真正关闭数据库\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259F%25A5%25E7%259C%258B%25E9%259B%2586%25E5%2590%2588 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9F%A5%E7%9C%8B%E9%9B%86%E5%90%88\")查看集合\n\n查看当前所在数据库中的所有集合：show collections 打印出所有集合名字  \n返回当前所有数据库中集合名字：db.getCollectionNames() 将所有集合名字以数组形式返回\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E9%2585%258D%25E7%25BD%25AE%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93\")配置数据库\n\n配置端口：--port xxxx  \n以进程守护方式启动：--fork  \n日志输出路径：--loppath xxxx  \n数据库路径：--dbpath xxxx  \n启动代码示例：mongodb --port 27017 --fork --logpath data/log/mongodb.log --dbpath data/db\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%2588%259B%25E5%25BB%25BA%25E6%2588%2596%25E5%2588%2587%25E6%258D%25A2%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%88%9B%E5%BB%BA%E6%88%96%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93\")创建或切换数据库\n\n命令代码：use xxx  \n详细说明：  \n1、创建或切换数据库语法关键词：use  \n2、xxx 即要创建或切换的数据库名字  \n3、若数据库不存在，MongoDB则会创建名为xxx的数据库并切换到该数据库  \n4、若数据库已存在，则切换到该数据库  \n5、也就是说：无论新创建或是本身已存在，执行use xxx 后都会自动切换到该数据库\n\n例如，创建数据库moodmap：use moodmap  \n若没有moodmap数据库则会创建，若moodmap已存在则切换到该数据库，命令面板会提示：switched to db moodmap\n\n再次提醒：若数据库没有任何内容，则使用 use dbs 是不会出现的。 就好像上面代码中 执行 use moodmap 创建新的数据库，此时执行 use dbs，moodmap是不会出现在结果列表中的。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%2588%25A0%25E9%2599%25A4%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E6%2588%2596%25E9%259B%2586%25E5%2590%2588 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%96%E9%9B%86%E5%90%88\")删除数据库或集合\n\n删除数据库  \n命令代码：db.dropDatabase()  \n详细说明： 1、删除数据库是危险操作，需要谨慎  \n2、首先需要确认删除哪个数据库，可以切换到该数据库，例如 use moodmap 或者 查看当前所在数据库 db  \n3、执行db.dropDatabase() 即可删除该数据库\n\n删除集合  \n命令代码：db.collection.drop()\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E9%2587%258D%25E5%2591%25BD%25E5%2590%258D-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E6%2588%2596%25E9%259B%2586%25E5%2590%2588 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E9%87%8D%E5%91%BD%E5%90%8D-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%96%E9%9B%86%E5%90%88\")重命名 数据库或集合\n\nMongoDB并未提供直接函数可以重命名数据库，但是有针对集合的重命名函数renameCollection()\n\n针对集合的重命名  \n命令代码：db.adminCommand({renameCollection:\"dbname.oldname\",to:\"dbname.newname\"})  \n详细说明：  \n1、\"dbname\"为当前数据库的名字  \n2、\"dbname.oldname\"为某集合的当前名字，\"dbname.newname\"为某集合新的名字  \n例如 db.adminCommand({renameCollection:\"moodmap.user\",to:\"moodmap.users\"})，将数据库moodmap中集合user名字改为users\n\n2、不光可以修改集合名，还可以修改集合对应的数据库名 dbname  \n例如 db.adminCommand({renameCollection:\"moodmap.user\",to:\"mymap.user\"})，将数据库moodmap中的集合user 转移到 数据库mymap中的集合user。\n\n注意：这种“转移”属于“修改元数据”，是对索引的修改，并不会真正重新复制出一份，因此这种修改消耗很小。\n\n修改集合对应的数据库，存在以下几种结果：  \n1、若mymap.user本身就存在，则会转移失败，反之则会成功。  \n2、若mymap本身不存在，则会自动创建mymap。  \n3、若moodmap里面只有user 一个集合，那么转移成功后 moodmap 即为空数据库，那么此时 show dbs 或在 MongoDB Compass中将无法再看到 moodmap。\n\n基于上面对于某数据库中的集合重命名操作，我们可以变相实现对数据库的重命名。  \n假设当前数据库为moodmap，我们希望将数据库重命名为mymap。  \n实施思路：将moodmap中所有的集合都通过重命名形式，转移到mymap中，这样moodmap为空数据库则会消失(use dbs 或在 MongoDB Compass中消失)，而新的数据库mymap总拥有原moodmap所有集合，变相实现将moodmap重命名为mymap。\n\n示例代码：\n\n```\nlet source = \"source\";\nlet dest = \"dest\";\nlet colls = db.getSiblingDB(source).getCollectionNames();\nfor (let i = 0; i<colls.length; i++) {\n  let from = `${source}.${colls[i]}`;\n  let to = `${dest}.${colls[i]}`;\n  db.adminCommand({renameCollection: from, to: to});\n}\n```\n\n备注：MongoDB 4.2 支持ES6中的新语法，例如 let 和 模板字符串\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%25A2%259E%25E5%2588%25A0%25E6%2594%25B9%25E6%259F%25A5-%25E7%259B%25B8%25E5%2585%25B3%25E7%259F%25A5%25E8%25AF%2586 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86\")增删改查 相关知识\n\n对数据库进行 增删改查，例如“添加数据”准确含义为“向某数据库中的某个集合中添加JSON文档类型的数据”。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%25B7%25BB%25E5%258A%25A0%25E6%2595%25B0%25E6%258D%25AE \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE\")添加数据\n\n命令代码：db.xxx.insert(json)  \n详细说明：  \n1、添加数据语法关键词：insert  \n2、json即要添加的数据，格式为JSON  \n3、若要添加多条数据，则可使用数据，例如：\\[json1,json2\\]  \n4、添加时MongoDB会自动为该条数据添加 \\_id 的属性值。  \n5、若不想使用MongoDB默认的\\_id值，需要提前在json数据中心设定 \\_id属性。\n\n特别强调：  \n1、若我们向db.xxx添加数据时，db.xxx根本不存在，MongoDB会自动为我们创建 xxx 这个集合。  \n2、对于比较新的MongoDB版本，可以使用insertOne(json)和insertMany(\\[json1,json2,...\\])来分别添加1条或多条数据。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259F%25A5%25E6%2589%25BE%25E6%2595%25B0%25E6%258D%25AE \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE\")查找数据\n\n命令代码：db.xxx.find({})  \n详细说明：  \n1、查找数据语法关键词：find  \n2、{}为查找条件\n\n-   db.xxx.find() 参数为空，则表示条件不限，查找全部\n-   {} 空对象，则表示条件不限，查找全部\n-   {name:\'puxiao\'} 包含某属性值得JSON对象，则表示查找name为‘puxiao’的数据\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259D%25A1%25E4%25BB%25B6%25E6%25AF%2594%25E8%25BE%2583%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9D%A1%E4%BB%B6%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2\")条件比较查询\n\n命令代码：db.xxx.find({age:{xx:value}}) 详细说明： 1、满足对比条件才可以被查询到 2、xx:value中 $xx为比较计算的类型，value为比较的对象值\n\n$xx 对应含义：\n\n-   $gt 存在并大于\n-   $gte 存在并大于等于\n-   $lt 存在并小于\n-   $lte 存在并小于等于\n-   $eq 存在并等于\n-   $ne 不存在 或 存在并不等于\n-   $in 存在并在指定数组中\n-   $nin 不存在 或 存在但不在指定数组中\n-   $exists:false 不存在(未定义)\n-   $exists:true 存在(有定义)\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%25A4%259A%25E6%259D%25A1%25E4%25BB%25B6%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2\")多条件查询\n\nand条件查询  \n命令代码：db.xxx.find({name:\'puxiao\',age:18}) 或 db.xxx.find($and:\\[{name:\'puxiao\'},{age:18}\\])  \n详细说明：  \n1、多个条件(属性值)必须同时满足才可以被查询到\n\nor条件查询  \n命令代码：db.xxx.find(or:\\[{name:\'puxiao\'},{age:{lt:30}}\\]) 详细说明：  \n1、只要有1个条件(属性值)满足要求即可被查询到\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2\")使用正则表达式查询\n\n命令代码：db.xxx.find({name:/xxxxx/})  \n详细说明：  \n1、/xxxxx/ 为一个正则表达式，只要满足该表达式的值都可以被查询到。  \n举例：db.xxx.find({name:/^p/}) 查找属性name值是以p为开头的数据\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E9%2592%2588%25E5%25AF%25B9%25E5%25AD%2590%25E6%2596%2587%25E6%25A1%25A3%25E8%25BF%259B%25E8%25A1%258C%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E9%92%88%E5%AF%B9%E5%AD%90%E6%96%87%E6%A1%A3%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2\")针对子文档进行查询\n\n所谓子文档值：JSON文档数据中某属性值依然为一个JSON对象。\n\n例如使用下面命令插入一条数据： db.mood.insert({type:\'happy\',why:{wealth:\'500w\',wife:\'beautiful\'}})  \n其中属性why的值也是一个JSON文档，那么why就是这条数据的子文档。\n\n针对子文档里的数据查询，使用命令代码：  \ndb.mood.find({\'why.wealth\':\'500w\'})\n\n请注意：上述代码中属性名为 \'why.wealth\'，即表示 mood集合下属性why下的子文档属性wealth\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E9%2592%2588%25E5%25AF%25B9%25E5%25AD%2590%25E6%2596%2587%25E6%25A1%25A3-%25E5%25A4%259A%25E6%259D%25A1%25E4%25BB%25B6%25E5%25A4%259A%25E5%25AD%2597%25E6%25AE%25B5%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E9%92%88%E5%AF%B9%E5%AD%90%E6%96%87%E6%A1%A3-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2\")针对子文档 多条件多字段查询\n\n命令代码：db.xxx.find({\'why.wealth\':\'500w\',\'why.wife\':\'beautiful\'})  \n可写成另外一种形式：  \ndb.xxx.find({\'why\':{elemMatch:{wealth:\'500w\',wife:\'beautiful\'}}}) 详细说明： 1、elemMatch 为关键词，表示必须全部满足\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E8%258E%25B7%25E5%258F%2596%25E5%25B1%259E%25E6%2580%25A7%25E5%2580%25BC \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%80%BC\")获取属性值\n\n命令代码：\'xxx\"详细说明：1、假设有一条数据为\"name\":\"puxiao\",\"age\":34，那么′age′表示属性名，属性名前面加上xxx\" 详细说明： 1、假设有一条数据为 {\"name\":\"puxiao\",\"age\":34}，那么 \'age\' 表示属性名，属性名前面加上 即表示属性值，例如 \'$age\' 表示age的属性值。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E9%2581%258D%25E5%258E%2586%25E6%25B8%25B8%25E6%25A0%2587 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E9%81%8D%E5%8E%86%E6%B8%B8%E6%A0%87\")遍历游标\n\n命令代码：xxx.hasNext()、xxx.next()  \n详细说明：  \n1、声明 xxx 为某个查询结果  \n2、可通过 while(xxx.hasNext()){xxx.next()} 来循环遍历查询结果 3、hasNext()即表示‘是否还有下一个’  \n4、next()即表示‘将游标切换到下一个’\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BF%25AE%25E9%25A5%25B0%25E7%25AC%25A6 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9F%A5%E8%AF%A2%E4%BF%AE%E9%A5%B0%E7%AC%A6\")查询修饰符\n\n命令代码：limit(num)、sort({name:-1|1})  \n详细说明： limit(num) 用来限定返回结果数量，例如limit(10)表示最多返回10条结果即可。  \n举例：db.xx.find({}).limit(10)\n\nsort({xxx:-1}) 用来设定按降序排序，如果是sort({xxx:1})则表示按升序排序。  \n举例：db.xx.find({}).sort({age:-1}) 按属性age的降序排序\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BB%2593%25E6%259E%259C%25E7%25BB%259F%25E8%25AE%25A1 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%BB%9F%E8%AE%A1\")查询结果统计\n\n命令代码：db.xxx.find({}).count()  \n详细说明：使用count()函数可对结果数量进行统计\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%258E%25A7%25E5%2588%25B6%25E6%259F%25A5%25E8%25AF%25A2%25E8%25BF%2594%25E5%259B%259E%25E7%25BB%2593%25E6%259E%259C \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%8E%A7%E5%88%B6%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\")控制查询返回结果\n\n命令代码：db.xxx.find({},{\\_id:0,name:1})  \n详细说明：  \n1、在find()函数中添加第2个参数，该参数为一个JSON对象  \n2、若属性值为1，表示可以返回该属性名和属性值  \n3、若属性值为0，表示不返回该属性名和属性值  \n4、由于默认一定会返回\\_id，所以若不需要返回\\_id则需要显式声明 \\_id:0  \n5、没有提及的属性名，均不会返回\n\n限定返回字段这个在MongoDB里被称为 投影(projection)。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%25A0%25BC%25E5%25BC%258F%25E5%258C%2596%25E8%25BE%2593%25E5%2587%25BA%25E6%2589%2593%25E5%258D%25B0%25E7%25BB%2593%25E6%259E%259C \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C\")格式化输出打印结果\n\n命令代码：pretty()  \n详细说明：  \n1、在查找命令结尾处，添加.pretty()即可格式化输出打印结果\n\n例如：db.xxx.find().pretty()\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%2588%25A0%25E9%2599%25A4%25E6%2595%25B0%25E6%258D%25AE \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\")删除数据\n\n命令代码：db.xxx.remove(json)  \n详细说明：  \n1、删除数据语法关键词：remove  \n2、json为我们要删除对象的条件 3、删除对象的条件和查找数据的条件，语法一模一样\n\n-   db.xxx.remove() 参数为空，运行则会报错\n-   {} 删除所有数据\n-   {age:28} 删除所有属性age值为28的数据\n-   {age:{$lt:18}) 删除所有属性age值小于18的数据\n\n注意：删除默认是‘批量多条’的操作行为。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259B%25B4%25E6%2596%25B0%25E6%2595%25B0%25E6%258D%25AE \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE\")更新数据\n\n命令代码：db.xxx.update(json,{set:json2},{xx}) 详细说明： 1、update()函数有2个必填参数和1个可选参数 2、第1、第2个参数为必填，第3个参数为可选参数 3、第1个参数为查询条件 4、第2个参数为需要修改的属性与值，格式需要遵循 {set:{\'xx\':value}} 的格式。若不使用$set:而是第2个参数直接为{\'xx\':value}，那么意味着直接整体覆盖。  \n5、第3个参数为可选参数，为更新选项设置\n\n举例：db.xxx.update({age:18},{$set:{\'age\':34}}) 将属性age值为18的数据修改为age值为34\n\n第3个更新选项配置，一共有3个属性，分别是：\n\n-   upsert 当原本不存在要修改对象时是否添加该对象，默认为false，即不添加。请注意这里说的是 对象不存在，而不是对象属性不存在\n-   multi 是否为更新多条数据，默认为false，即只更新1条\n\n举例：db.xxx.update({age:18},{$set:{\'age\':34}},{multi:true}) 查找属性age值为18的数据，并将他们的属性age值全部修改为34\n\n如果要同时修改多条数据，除了设置第3个参数multi为true之外，还可通过使用db.xxx.updateMany()。\n\n对于insertOne()和insertMany()来说，函数中必须使用到以下关键词之一，若不使用则会报错：  \nset如果匹配到，则设置该值set 如果匹配到，则 设置该值 unset 如果匹配到，则删除该属性  \npush如果匹配到，则添加一个值到数组结尾push 如果匹配到，则 添加一个值到数组结尾 pushall 如果匹配到，则 添加多个值到数组结尾  \npop如果匹配到，则从数组结尾处剔除一个值pop 如果匹配到，则 从数组结尾处剔除一个值 pull 如果匹配到，则 从数组中删除一个值  \npullall如果匹配到，则从数组中删除全部对应的值pullall 如果匹配到，则 从数组中删除全部对应的值 addToSet 如果不存在则增加一个值到数组\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%25B7%25BB%25E5%258A%25A0%25E6%2588%2596%25E6%259B%25B4%25E6%2596%25B0%25E6%2595%25B0%25E6%258D%25AE \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%B7%BB%E5%8A%A0%E6%88%96%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE\")添加或更新数据\n\n命令代码：db.xxx.save(json)  \n详细说明：  \n1、json表示一个JSON格式的文档数据  \n2、若json中没有\\_id属性，则插入该条数据  \n3、若json中有\\_id属性，则会通过\\_id查找是否存在该\\_id的数据  \n4、若\\_id对应的数据原本存在，则将json完全替换原来数据  \n5、若\\_id对应的数据原本不存在，则插入该条数据，但是该数据的\\_id不再使用MongoDB默认的，而是使用json本身中的\\_id属性值\n\n以上为MongoDB基础用法，接下来才会真正触及MongodDB真正核心，高级用法：聚合查询\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E8%2581%259A%25E5%2590%2588%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2\")聚合查询\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AFmongodb%25E8%2581%259A%25E5%2590%2588%25E6%259F%25A5%25E8%25AF%25A2 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BB%80%E4%B9%88%E6%98%AFmongodb%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2\")什么是MongoDB聚合查询？\n\nMongoDB聚合框架(Aggregation Framework)是一个计算框架，可以作用在一个或几个集合中，对集合中的数据进行一系列运算，并将运算结果转化为期望的形式。这种多集合、多维度、多条件、多形式、多组合的查询方式就称为聚合查询。\n\n注意：聚合查询也称为聚合运算，名字不同但是表示的是同一个意思。\n\n补充说明：  \n1、像db.xxx.find(query) 这种只是针对单一集合进行一些条件查询，并返回原始数据的，可以称之为“最简单基础的查询”  \n2、像db.xxx.find(query).sort(xxx) 或 db.xxx.find(query).limit(10) 针对查询结果又进行了处理，例如排序或只获取限定数量的查询，姑且称之为“稍微复杂点的查询”  \n3、而聚合查询则是设定多项查询条件、逐层筛检、累计运算、设定返回结果格式的，就可以称之为“比较复杂的查询”。现实中项目开发肯定使用最多的还是聚合查询。\n\n举例：假设有一个数据库存放全班学生的数学考试成绩  \n1、使用db.xxx.find()可以查找出所有人的数学成绩  \n2、使用db.xxx.find().sort()可以列出所有人的数学成绩排名  \n3、若此时想查询所有学生的数学平均成绩，平均成绩这个字段原本是不存在的，此时就需要通过聚合查询，计算并返回出平均成绩。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E7%25AE%25A1%25E9%2581%2593pipeline%25E5%2592%258C%25E6%25AD%25A5%25E9%25AA%25A4stage \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%AE%A1%E9%81%93pipeline%E5%92%8C%E6%AD%A5%E9%AA%A4stage\")管道(pipeline)和步骤(stage)\n\n聚合查询(聚合运算)的整个查询(运算)过程称为管道，查询(运算)过程由多个步骤组成。\n\n聚合查询整个过程是： 1、从第一个步骤开始，计算得到结果  \n2、从第一个结果开始，进行第二个步骤，并得到第二步骤的结果  \n3、依次类推，直到最后一个步骤计算完成  \n4、将最终的计算结果返回给查询主体\n\n原始数据 -> 步骤1 -> 结果1 -> 步骤2 -> 结果2 -> ... -> 最终结果\n\n数据结果就好像是水，流经一个又一个管道，经过每个管道的过滤，最终剩下的水到达目标出口。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E8%2581%259A%25E5%2590%2588%25E6%259F%25A5%25E8%25AF%25A2%25E5%259F%25BA%25E7%25A1%2580%25E6%25A0%25BC%25E5%25BC%258F \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F\")聚合查询基础格式\n\n命令代码：db.xxx.aggregate(\\[stage1,stage2,...\\],{options})  \n详细说明： 1、聚合查询使用关键词 aggregate  \n2、aggregate函数共2个参数  \n3、第1个参数为一个数组，数组中每一项均代表一个查询运算步骤  \n4、第2个参数为一个对象，是查询运算的配置选项\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E5%25B8%25B8%25E8%25A7%2581%25E6%259F%25A5%25E8%25AF%25A2%25E8%25BF%2590%25E7%25AE%2597%25E6%25AD%25A5%25E9%25AA%25A4 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E5%B8%B8%E8%A7%81%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E6%AD%A5%E9%AA%A4\")常见查询运算步骤\n\n-   $sort 排序\n-   $limit 限定返回结果数量\n-   $unwind 将某个数组拆分成独立的元素(类似JS中的...array)\n-   $match 过滤数据，必须全部满足条件\n-   $skip 跳过指定数量，返回剩余的结果\n-   $group 将集合中的文档分组，可用于统计结果\n-   $project 修改输出的文档解构，可以重命名、增加、删除域，也可以创建计算结果\n-   $geoNear 输出接近某一地理位置的有序文档\n-   $lookup 多表关联操作\n\nmatch、match、project、$group 这3个是常见的、核心的、包裹其他查询的运算符。\n\n#### [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E7%2589%25B9%25E6%259C%2589%25E6%25AD%25A5%25E9%25AA%25A4-bucket%25E5%2592%258Cfacet \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%89%B9%E6%9C%89%E6%AD%A5%E9%AA%A4-bucket%E5%92%8Cfacet\")特有步骤 bucket和bucket和facet\n\n$bucket这个步骤可用于将数据按照某一种维度自动分组查询。常见的应用场景是搜索商品时，按不同价格区间进行查询。\n\nfacet这个步骤是将多组facet这个步骤是将多组bucket进行查询，从而实现多维度查询。例如搜索商品时，按不同价格区间、不同品牌、不同类型等多维度分组查询。\n\n## [](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpuxiao%2Fnotes%2Fblob%2Fmaster%2FMongoDB%25E5%2585%25A5%25E9%2597%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.md%23%25E6%259B%25B4%25E5%25A4%259Aapi%25E8%25AF%25A6%25E6%2583%2585 \"https://github.com/puxiao/notes/blob/master/MongoDB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%9B%B4%E5%A4%9Aapi%E8%AF%A6%E6%83%85\")更多API详情\n\nMongoDB全部API请访问：[docs.mongodb.com/manual/refe…](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.mongodb.com%2Fmanual%2Freference%2F \"https://docs.mongodb.com/manual/reference/\")\n\n补充：无论是MongoDB中文网([www.mongodb.org.cn/](https://link.juejin.cn/?target=https%3A%2F%2Fwww.mongodb.org.cn%2F \"https://www.mongodb.org.cn/\")) 还是 MongoDB中文社区([mongoing.com/](https://link.juejin.cn/?target=https%3A%2F%2Fmongoing.com%2F \"https://mongoing.com/\")) ，他们上面关于MongoDB的中文API文档都存在版本比较滞后、不是最新、不够全面的问题。  \n因此学习时，还是以英文官方API文档为好。', 'public/uploads/1694354791288.png', 3, 3, 1, 578, '2023-09-10 14:06:34', 1);
INSERT INTO `article` VALUES (83, 4, 'Vue 框架提升加载速度的优化思路', '现在前端的框架有很多，甚至两只手已经数不过来，当然也完全没必要全部都学，还是应该深入的学习一两个被广泛使用的就好。其实我和大部分同学的想法一致，认为最值得我们深究的还是主流的 Vue 和 React。我们通过深入的学习了解这些框架的思维，也让自己使用这些框架能够更加得心应手。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c8d39958197441b874df0e243907a2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里我以自己常接触到的 Vue 为例进行说明，但也要特别说明下，本人的水平有限，如果有理解不到位的地方也欢迎大家拍砖。\n\n相信和我一样选择 Vue 框架的主要原因是，它作为当前最流行的 JavaScript 前端框架之一，在轻量、效率、灵活度上面有比较强的优势。但是在实际的项目中深入使用发现，一些合理的技巧可以在一定程度上提升app的性能表现。\n\n想把自己发现关于解决加载速度的一些经验分享给大家。\n\n## 一、初次打开加载速度慢\n\n在我所经历的项目中有过这样一种情况，如果一次性加载所有的组件，就会很明显的出现打包后的 JavaScript 文件体积过大，直接影响到了 app 初次加载速度。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ed4a019a054005b22288ddbae63e8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n在社区搜索了懒加载相关的处理办法，再和团队讨论后的办法是只加载需要的组件，等到app需要的时候再异步加载其他组件。\n\n其实在 Vue 中使用懒加载的方式很简单，总括起来只需要两步:\n\n1.  使用动态 import 语法进行按需加载组件。\n2.  将加载的组件定义为异步组件。\n\n这里放一个 demo 出来：\n\n```\n// Home.vue\n\n<template>\n  <div>Home page</div>  \n</template>\n\n<script>\n  export default {\n  name: \'Home\'\n  }\n</script>\n\n// App.vue\n\n<script>\n  export default {\n  components: {\n  Home: () => import(\'./views/Home.vue\') \n  }\n  }  \n</script>\n```\n\n这样做的话 Home 组件就只会在需要的时候加载，可以在一定程度上避免加载首页不需要的组件，也能够明显的提升 app 加载速度。\n\n## 二、重复渲染的解决办法\n\n会发现在我们实际的应用中会存在频繁切换查看某些组件的情况，这时就不可避免的造成重复渲染，影响到app的性能。\n\n而大家都知道 Keep-alive 组件是 Vue 项目中的一个高阶组件，是可以帮助我们缓存组件实例，提高应用程序的性能和响应速度的，只要合理的配合使用 keep-alive 组件实现缓存就能避免每次切换都得重新渲染。\n\n同样配合一个demo:\n\n```\n// App.vue\n\n<keep-alive>\n  <component :is=\"currentView\"></component>  \n</keep-alive>\n```\n\n其实它的逻辑就是使用 keep-alive 组件将动态组件包裹起来，Vue就会缓存不活动的组件实例。例如在上面的demo里面将 currentView 动态组件使用 keep-alive 包裹起来，currentView 在切换时就会被缓存起来，实现组件的高效循环利用。\n\n但是需要注意的一点是，我们在使用 keep-alive 组件时会默认缓存所有组件，如果需要指定缓存的组件可以使用 include 和 exclude 属性。\n\n## 三、提取数据时卡顿问题\n\n除了前面说到的懒加载和 keep-alive 组件外，我们还可以通过创建好组件实例，以异步获取数据的形式去提升加载的速度，继而再显示组件的方式，最终\n\n其实这种方式可以让数据提前准备好，一旦组件需要显示时，就可以避免因为实时获取数据而造成的卡顿。\n\n我个人实现的使用方式是在 beforeMount 中获取数据，然后在 mounted 中控制显示组件：\n\n```\n// Comonent.vue\n\nexport default {\n  async beforeMount() {\n    await fetchData(); \n  },\n  mounted() {\n    this.show = true;\n  }  \n}\n```\n\n## 四、合理的异步组件使用\n\n最后我还想分享下 Vue 提供的异步组件，其实合理使用也可以发挥比较好的效果，具体的实现和最上面介绍的懒加载组件类似。\n\n区别有两点：一是懒加载组件主要是在首次访问时使用；二是异步组件在创建组件实例时进行使用。因为异步组件的基本使用逻辑是在创建实例的时候会异步解析，可以按需加载，实现方式：\n\n```\nVue.component(\'async-example\', function (resolve, reject) {\n\n  setTimeout(() => {\n    resolve({\n      template: \'<div>I am async!</div>\'\n    })\n  }, 1000)\n\n})\n```\n\n相信大家在关于 Vue 框架使用上还有更好更多的经验，我仅按照自己的使用习惯分享几个相对来说比较适合广泛用起来的办法，也欢迎各位大佬补充和指正。', 'public/uploads/1694355305953.png', 4, 3, 0, 1170, '2023-09-10 14:15:07', 1);
INSERT INTO `article` VALUES (84, 5, 'Mr.', 'What you get by achieving your goals is not as important as what you become by achieving your goals. Champions keep playing until they get it right. Anyone who has never made a mistake has never tried anything new. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. There is no way to happiness. Happiness is the way. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. You will succeed because most people are lazy. In the middle of winter I at last discovered that there was in me an invincible summer. Champions keep playing until they get it right. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. A query is used to extract data from the database in a readable format according to the user\'s request. You must be the change you wish to see in the world. If you wait, all that happens is you get older. In the middle of winter I at last discovered that there was in me an invincible summer. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. You will succeed because most people are lazy. Instead of wondering when your next vacation is, maybe you should set up a life you don’t need to escape from. The Main Window consists of several toolbars and panes for you to work on connections, database objects and advanced tools. Sometimes you win, sometimes you learn. Such sessions are also susceptible to session hijacking, where a malicious user takes over your session once you have authenticated. To successfully establish a new connection to local/remote server - no matter via SSL or SSH, set the database login information in the General tab. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. Such sessions are also susceptible to session hijacking, where a malicious user takes over your session once you have authenticated.', '', 1, 8, 0, 59, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (85, 1, '石墨文档两面后，我整理了这些面试题', '## 背景\n\n本人开学大三，非科班，苦逼机械学生，从大一下自学前端，如今练习时长还不够两年半，临近开学 ，试着面了一下武汉的石墨文档。8.23约的hr，8.24上午11点进行1面，下午两点半进行2面。先说下感受，难度不大，他们公司技术栈是react,而我是vue,所以没问框架。主要考察js,css,计网，设计模式等方面知识。一面考察基础，二面考察深度。\n\n## 一面\n\n一面持续了1个小时，主要考察js,css 我把问题整理一下。\n\n-   1.**请说出js中几种声明变量的方式?**\n\n答: es6之前都是用var,es6之后推出了let const声明，用var声明会造成变量提升，let和const是块级作用域就不会，还有一种是不用关键字，直接声明，效果和var类似。\n\n-   **既然谈到变量提升请你说一下啥是变量提升?**\n\n答:在执行代码之前，变量的声明会被提升到其作用域的顶部。\n\n**出个题你看看**\n\n```\nconsole.log(a)\nvar a = 1\nconsole.log(a)\n```\n\n求输出结果：undefined和1 这个题没难度不用多说\n\n-   2.**说一下js在点击一个dom之后，js引擎如何处理?** 这个题，开始没思路，就往事件冒泡和事件捕获方向考虑了，结果还真是，思路差不多\n\n答：javaScript 引擎会检查该元素是否已经绑定了点击事件的监听器。如果已经绑定了监听器，引擎会执行该监听器函数。如果没有绑定监听器，引擎会继续向该元素的父元素冒泡，直到找到已经绑定了监听器的元素，或者冒泡到文档根节点时停止。\n\n**那既然说到了事件冒泡，说一下如何阻止冒泡**\n\n答:用api _stopPropagation()_\n\n**那如何在事件捕获阶段执行事件呢？**\n\n这个题，我当时没答出来，这个问题蛮基础的，傻了当时唉。\n\n答案:\n\n```\n const btn = document.querySelector(\'#btn\')\n        btn.addEventListener(\'click\', () => {}, true)\n```\n\n将最后一个参数改为true,这个真是基础问题，默认是false表示开启冒泡，改为true就是捕获阶段执行，w3c上面有。\n\n-   3.**说一下css垂直居中的方式**\n\n这个题答的还不错，这个还是要记住，面试了好几家都问过。\n\n答:\n\n1.  子设置absolute，父relative 子元素left:50%, top:50%, 再用平移translate(-50%)\n2.  flex布局，父元素设置flex justify-content:center align-items:center\n3.  利用line-height搭配vertical-align也可以实现\n\n补充：如果会grid布局实现，也是可以的\n\n-   4.**如何判断是不是一个数组?**\n\n答：js中有几种检查数据类型的方式，typeof intanceof Array.isArray(), Object.prototype.toString.call() 这几种。\n\n1.  typeof只能检测出是一个对象，不能检测是不是数组。\n2.  intanceof可以，判断是不是一个数组，返回布尔值。\n3.  Array.isArray()也是返回一个布尔值。\n4.  Object.prototype.toString.call()可以精确的返回一个数据的类型\n\n-   5.**下面给你出个题看看**\n\n```\n  var length = 1\n  function fn() {\n   console.log(this.length)\n  }\n  var obj = {\n    length: 4,\n    test: function(t) {\n     t()\n     arguments[0]()\n    }\n  }\n  obj.test(fn, 6)\n```\n\n说实话刚开始看不难，后面那个arguments打印出来的值就蒙蔽了\n\n答：这个题是作用域以及this指向问题，函数的作用域要看，定义的位置，这里的fn定义在全局，所以在obj.test(fn, 6)\n\n第一个参数是1， 第二个arguments\\[0\\]这个我只知道是剩余参数，这个没答出来\n\n![1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e992d4b6b444e9a24181d4f828c6ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\narguments是接受形参的数量 , arguments\\[0\\]就是fn,再调用一次，但是此时this指向arguments了，打印的应当rguments的length，是2,因为后面又传入了一个形参，所以有两个参数，即length为2\n\n-   6.**知道事件循环吗?** 看个题\n\n```\nlet button = document.querySelector(\'#button\');\nbutton.addEventListener(\'click\', function CB1(){\n  console.log(\'Listener 1\');\n  setTimeout(() => console.log(\'Timeout 1\'))\n  promise.resolve().then(() => console.log(\'Promise 1\'))\n})\nbutton.addEventListener(\'click\', function CB1(){\n  console.log(\'Listener 2\');\n  setTimeout(() => console.log(\'Timeout 2\'))\n  promise.resolve().then(() => console.log(\'Promise 2\'))\n})\n```\n\n这个题就是典型的宏任务，微任务的考察。宏任务，微任务，我在很多评论区，看过大家争吵。我按我的理解来说，每次事件循环，都先看有没有宏任务， 有的话，给他放进宏任务队列中，再看看宏任务中有没有微任务，如果有，进入微任务队列中。在每轮事件循环中，都需要将宏任务中的微任务清空。所以宏任务先执行还是微任务先执行都是相对的。\n\n这个题输出顺序是，首先有两个点击事件是宏任务， 进入宏任务队列。接下来执行里面的逻辑，同步代码优先执行，所以先打印 \'Listener 1\', 接着遇到定时器，是宏任务，放到宏任务队列中，等下轮执行，promise.then()是微任务，所以需要将本轮宏任务的微任务执行完，因此接着输出\'Promise 1\'。\n\n这个宏任务就执行完了，接下来执行第二个，同第一个的逻辑，因此题目输出顺序为\n\n```\nListener 1 -> Promise 1 -> Listener 2 -> Promise 2 -> Timeout 1 -> Timeout 2\n```\n\n-   7.**子元素的margin-top:10%的10%是多少?**\n\n这个题答错了，很多人可能跟我一样觉得是相对于父元素的高度来计算，实际不是，是相对于父元素的**宽度**来计算的，这个要注意， 属于知识盲区了。\n\n-   8.**css3选择器说一下，知道多少说多少**\n\n答：通配符,id,class 标签，伪类, 后代，兄弟，子 :root, :where, :is :empty, :not, :has 这个题答的还是蛮多的。\n\n**那你知道他们的权重吗?**\n\n答:\n\nid:0100\n\n类、伪类、属性选择器: 0010\n\n标签:001\n\n拓展一下：继承的样式没有权重，即\\* + >这些为0000\n\n-   9.  **实现动画的方式**\n\n答: css用animation属性，js用requestAnimation函数也可以实现。\n\n**那你说说requestAnimation吗?**\n\n答：requestAnimation有些情况下可以当作定时器使用，它的时间一般是17ms, 在react fiber中也有应用。\n\n**那你说说为啥是17ms**\n\n答：因为浏览器一帧是16.66666ms，而requestAnimation执行时间取决于浏览器绘制频率。\n\n-   10.**有没有处理过跨域?**\n\n答：在前端vue中使用proxy代理，在后端设置cors允许指定域名通过，在nginx中设置反向代理。\n\n当时漏了一个jsonP，面试官问了一下jsonP的原理\n\n答： 通过script标签请求服务器, 浏览器不会对scrpit进行拦截，所以可以，但是缺点是只能通过get请求。\n\n-   11.**有了解过websocket吗？**\n-   时 答：了解过，websocket是一种全双工通信，原理利用tcp协议，WebSocket 在建立握手时，数据是通过 HTTP 传输的。但是建立之后，在真正传输时候是不需要 HTTP 协议的。\n\n**那你说说如果浏览器不支持websocket如何替代?**\n\n这个真把我问住了，我以为sse不可以，没想到是可以的，当时答的一塌糊涂😭\n\n答案:\n\n1.  轮询（Polling）：客户端定时向服务器发送请求，服务器返回最新数据，客户端再进行更新。这种方式会造成不必要的网络开销，但是兼容性好，可以在所有浏览器上使用。\n2.  长轮询（Long Polling）：客户端向服务器发送请求，服务器一直保持连接打开状态，直到有新数据可返回时才返回响应。这种方式可以减少网络开销，但是需要服务器支持。\n3.  Server-Sent Events（SSE）：服务器向客户端推送数据，客户端通过 EventSource API 接收数据。这种方式只能由服务器向客户端推送数据，不支持双向通信，但是可以实现实时更新数据，而且兼容性较好。\n\n-   11.**有用过git吧,那你说说git rebase和git merge的区别?**\n\n这个也没答好，果然git是一生的痛。 git merge我倒是知道是合并分支，这个rebase听说过，但是没用过。\n\n答案是:git merge合并分支后，会提交一个新的分支上去，并且会有新的提交记录，也会保存原来两个分支的记录，而rebase则不会保存原来的分支记录，比较简洁，但是不利于管理。\n\n到最后，面试官有点事情，就给了我两个题目做，2选1,因为不会react 就做了那个节流函数的\n\n```\nfunction throttle<T extends Function>(\n  func: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean } // Bonus，可省略该参数的实现\n): T;\n```\n\n让我根据这个ts类型，写出节流函数,也不难\n\n```\nfunction throttle (func, wait) {  \n   let flag = true\n   if(!flag) return \n   return (...args) => {\n   flag = false\n     setTimeout(() => {\n       flag = true\n       func.call(this, args)\n     })\n   }\n}\n\n```\n\n另外一个是react的题目, 请用 React hooks 重构下面的 React component\n\n```\n\nimport React, { PureComponent } from \'react\';\nexport default class FormInput extends PureComponent<{ id: number }> {\n  private text: string = \'\';\n  private onChange = e => {\n    this.text = e.target.value;\n  };\n  private submit = () => {\n    processInput(this.text);\n  };\n  public componentDidMount() {\n    fetchData(this.props.id);\n  }\n  public render() {\n    return (\n      <>\n        <input type=\"text\" onChange={this.onChange} />\n        <button onClick={this.submit} />\n      </>\n    );\n  }\n}\n```\n\n到这里一面就结束了，然后结束后hr说，一面过了，下面约的二面。\n\n## 二面\n\n因为上午问的比较基础，我就觉得下午肯定不好搞。下午两点半开始，持续半个小时。题型确实深入，有设计模式，ts装饰器,mvc在前端的应用，http状态码，js模块之间的依赖。\n\n首先就说自我介绍环节，介绍完毕后开始技术拷打。\n\n-   1.**有了解过设计模式吗?**\n\n这里我说了几种，工厂模式，单例模式，观察者模式，发布订阅模式，责任链模式，策略模式。\n\n对于工厂和策略还行，主要项目有用过，其他几种在框架中看到过，答的一般般。如果感兴趣，可以去其他博主那里看看。这里我就不细说了，我也得补补。\n\n**那你说说发布订阅模式和观察者模式区别和联系**\n\n这个我没答出来，难崩\n\n答案:\n\n发布订阅模式和观察者模式都是用于解决对象间的耦合问题，它们的本质都是基于事件的消息通信机制。它们的区别在于：\n\n1.  发布订阅模式中，发布者和订阅者之间没有直接的联系，发布者只管发布事件，而订阅者只管订阅事件，彼此之间不需要知道对方的存在；而观察者模式中，观察者和被观察者之间是直接联系的，观察者需要知道被观察者的存在，并且需要注册到被观察者的通知列表中。\n2.  在发布订阅模式中，发布者和订阅者之间通过事件通道进行通信，发布者发布事件后，所有订阅了该事件的订阅者都会收到通知；而在观察者模式中，被观察者通过调用观察者的方法进行通信，被观察者通知观察者的方式是直接调用观察者的方法。\n3.  发布订阅模式中，事件通道可以支持多级事件的传递，即一个事件可以触发另一个事件，形成事件的层级关系；而观察者模式中，被观察者只能通知观察者，不能形成事件的层级关系。\n\n联系方面，发布订阅模式和观察者模式都是基于事件的消息通信机制，都可以实现对象间的解耦，提高系统的灵活性和可维护性。同时，它们也都可以支持异步编程，通过事件回调函数实现异步处理。\n\n-   2.**有了解过ts装饰器吗?**\n\n这个我在前端很少用，在后端nestjs中装饰器比较常见，就给面试官说了一下。\n\n-   3.**ts中的泛型说一下**\n\n答：ts中的泛型相当于一个占位符，不指明数据类型，当我们需要传递具体类型时，可以根据这个泛型推断出所有需要用到这个泛型的数据类型。\n\n-   4.**有了解MVC风格吗**\n\n答：这个因为我在nestjs中用的比较多，因为nestjs就是MVC风格的框架，也就module,view,controller。\n\n**那在前端有使用过吗?**\n\n这个又被问住了，在前端的框架中都是MVVM的视图，数据模型，对如何使用这个MVC真不了解。\n\n5.**有了解过react吧,说说vue和react的区别**\n\n这个答的不全面，我只说了部分，因为对react只是了解，我觉得差不多\n\n答：写法上:vue是template写法，react是jsx写法 组件上： vue是定义单文件组件.vue文件， react是类组件以及函数组件，\n\n相同点：都是利用了虚拟dom来处理，减少dom操作\n\n6.**有遇到过模块依赖循环的问题吗**\n\n这个直接不会了，因为对框架开发比较多，我遇到过vue3 hooks依赖的问题，这个js模块化的问题，没有遇到过。\n\n2面的问题差不多就这些，深度还是有的，被面试官拷打了，总结经验,继续学习。\n\n结束后，跟面试官闲聊了一会儿，问了他对我感觉咋样，他说和上午一面面试官聊了，感觉都不错。这两个面试官，给人的感觉还是挺和善的\n\n## 总结\n\n人总是在失败中吸取教训，这次面试不会的题，也是查缺补漏，每一次都要有提升，另外技术的深度和广度都很重要，希望大家没事看看技术博客， 多学习学习。另外英语也很重要，跟面试官聊天的过程中，也是有提到有没有用过chatGpt这种ai产品，遇到问题咋解决的，我是对博客社区比较青睐的，在社区查问题比较多。另外对于去外网学习也是很重要，多看看英文文档和纯英文视频也是不错的。\n\n另外这家在武汉还在招前端开发实习，感兴趣的可以投递。\n\n最后希望这份新鲜出炉的面试题能帮助到大家， 如果觉得不错，不妨点赞加收藏！😘', 'public/uploads/1694355953095.png', 3, 4, 2, 312, '2023-09-10 14:26:05', 1);
INSERT INTO `article` VALUES (86, 3, '李跳跳收到南山必胜客律师函，狗皮膏药似的广告何时休', '![ misc_litiaotiao_issue.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9a7f8bdb8bc421dae3d3e15dfda913e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=1920&h=1080&e=png&b=167f58)\n\n[原文链接](https://link.juejin.cn/?target=https%3A%2F%2Fshouduo.netlify.app%2Fmisc_litiaotiao_issue%2F \"https://shouduo.netlify.app/misc_litiaotiao_issue/\")\n\n## 前言\n\n最近在 Android 爱好者圈子里有一则消息引爆了讨论区，“南山必胜客”腾讯公司，一纸诉状将 Android 应用“李跳跳”的开发者告上了法庭，理由是“李跳跳”可以屏蔽腾讯应用的开屏广告，影响了腾讯的广告收入，并最终导致“用户福祉的减损”。 ![腾讯律师函转存失败，建议直接上传图片文件](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fb02a1dcd294b24901c2a7f2b6a4048~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=1024&h=3462&e=jpg&b=fbfbfb)\n\n## 事件经过\n\n“李跳跳”的开发者随后发文宣称自己开发的软件并没有侵权行为，“李跳跳”是通过监听应用的启动事件，模拟用户点击相应开屏广告上的“跳过”按钮，来实现瞬间跳过开屏广告的功能。这种应用行为对于其他应用是非侵入性、非破坏性的，并且应用本身也没有联网功能，开发者自己更没有通过这个应用去获利。“李跳跳”的开发者也举例反问道，假如他现在不是用软件来进行模拟点击，而是雇佣了一群人，来帮助用户点击这些“跳过”按钮，是否也算是腾讯公司所说的侵权行为？ ![开发者回复转存失败，建议直接上传图片文件](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e12d79fb224243b0eb0eb7aaa70b39~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=936&h=5562&e=png&b=fefefe)\n\n## 个人看法\n\n我个人认为，“李跳跳”应用的程序行为更类似于一些连点器或是抢票软件。我记得我在大学的时候也有遇过类似的经历。大学时学校实行抢课制度，选课平台开放后，每个学生都可以在自己持有的学分份额内，占尽可能多的课程。为了选到自己心仪的课，我们就需要经常坐在电脑前不断地去刷新某个课程的选课情况。有一些人际关系好的同学会让有盈余学分份额的学长、学姐帮他们去抢占一些课，私下再约夜深人静的时候一退一抢，更有甚者干起了黄牛的生意开始买卖课程名额。那时我比较内向也不善于交际，看着其他人通过上述方法都选上了热门课程，难免产生嫉妒之心，为了解决这个问题，我发挥了自己的技术力去开发了一款浏览器插件，它可以帮我去定时轮询候选课程的选课情况，并且在有空位时直接发起请求选课。和“李跳跳”开发者后来在微信上的说明一样，我认为使用技术手段做非侵入式的功能实现，是不侵权但“至多是不道德的”，特别是对于那些循规蹈矩，真正纯人力靠自己抢课的同学而言。\n\n应用的前端界面只是提供使用服务的入口，至于怎么使用对用户来说是“八仙过海各显神通”的事情，有人使用筋膜枪驱动手指来连点屏幕上的购买按钮，就有人能发动亲戚朋友帮忙掐点购买同一件商品，有懂机械的人用曲柄结构绑上香肠模拟手指，就有懂软件的人用无障碍接口帮助用户点击。应用厂商能做的只有通过技术手段，来抑制这些非人力参与的操作行为，如验证码，人机检测，请求节流等。网络安全的相关从业人员都应该知道，互联网攻防从来都是不断相互追逐和超越的关系，类似的，平台和用户之间的博弈也是如此。\n\n如今越来越多的应用都把自己堆砌成“超级 App”，恨不得让用户吃喝拉撒都在自家应用里得到满足，用户甚至可以在聊天应用里看直播，在直播应用里点外卖，在外卖应用里办贷款。无孔不入、无所不用其极，这些统称为“国产毒瘤”的应用往往希望自己霸占住所有互联网服务的入口和“用户心智”，以此来提高留存率和转化率。当然厂商开发、维护和运营一个应用也下了血本，除开这些成本，还常常为了在“赢者通吃”的互联网市场中拔得头筹，厂商在应用的推广前期就需要砸钱和其他竞品打恶性价格战。站稳脚跟后，购买版权、激励创作、刺激消费等日常运营也是一笔不小的开支。而与此同时，中国的互联网生态又培养了用户对虚拟服务就应该免费获得的固有印象，最终当某个应用在竞争中笑到最后，开始思考盈利问题时，才发现留下来的用户全是没有消费意愿的群体，不可避免地，在应用内处处设广也就成了厂商最稳健的一条、无痛拔毛式的盈利方式了。 ![恶心的开屏广告转存失败，建议直接上传图片文件](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77b404ec081b4f8cb61e061fd4fa40a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=2958&h=940&e=png&b=676767)\n\n至今我仍记得 2015 年左右那些外卖平台的“百团大战”，那个外卖用红包减免后只要 0.5 元，最后外卖小哥忘记带可乐还倒赔我 2 元的时代；以及那些堆满城市每个角落花花绿绿的共享单车，最后公司破产导致我的 200 元押金到今天还在排队处理中的时代。我也记得魅族曾经推崇的系统内零广告 Zero 系列手机，如今却在手机市场份额统计里落得个只能被计算进“其他”类别的下场；记得B站坚持不在视频中加广告贴片，2018 年纳斯达克上市至今仍年年亏损的事实。\n\n## 总结\n\n我自己其实没有安装使用过“李跳跳”，早些年在酷安的 Android 社区里，各个应用的评论区里就能找到各种各样修改版的对应去广告应用，相比“李跳跳”，这些修改版的应用除了没有开屏广告，往往应用内也删减了许多非核心功能的入口。后来我把主力机从 Android 换成 iPhone，屏蔽这些大厂应用的广告就变成我长期研究的课题了，iOS 上大概有三种屏蔽广告的方法，一种是越狱后使用 Flex 3 打各种应用的补丁；另一种是通过巨魔商店安装砸壳后修改过的 App；最后一种是使用代理软件，拦截广告的网络请求。这些方法显然对原应用都是侵入式、破坏式的修改，但因为难以追溯，厂商往往也只能睁一只眼闭一只眼，最多就是敦促相关平台删除分享教程和资源的帖子。如今互联网行业迎来寒潮，各路厂商纷纷降本增效，任何影响到盈利的障碍都将一一扫除。“李跳跳”之后，“一指禅”、“叮小跳”的开发者也陆续收到了腾讯的诉状，随着形势的收紧，去广告、精简应用的技巧，今天看来只能渡己，不能渡人。\n\n相关阅读： [李跳跳进阶指南 | 作者：李跳跳](https://juejin.cn/post/6938590373740544007 \"https://juejin.cn/post/6938590373740544007\") [利用autojs获取控件信息 | 作者：李跳跳](https://juejin.cn/post/7146224911030157320 \"https://juejin.cn/post/7146224911030157320\") [网络热传App鉴定 |「李跳跳」里用到的无障碍权限是什么？ | 作者：星际码仔](https://juejin.cn/post/7163425815584047112 \"https://juejin.cn/post/7163425815584047112\")', 'public/uploads/1694316372719.png', 4, 3, 0, 570, '2023-08-10 03:26:13', 1);
INSERT INTO `article` VALUES (87, 3, 'React Native 0.72 版本问世：这次都有哪些重要的更新？', '经过漫长的等待，React Native 0.72 终于来了！它带来了许多要求很高的功能、性能和开发人员体验的改进以及其他一些重要的变化。\n\n从 [这里](https://link.juejin.cn/?target=https%3A%2F%2Freact-native-community.github.io%2Fupgrade-helper%2F%3Ffrom%3D0.71.0%26to%3D0.72.0 \"https://react-native-community.github.io/upgrade-helper/?from=0.71.0&to=0.72.0\") 看到本次升级的总览：\n\n在这篇文章中，我们将了解 React Native 0.72 中的新增功能，以及最重要的是，为什么这些新功能对 React Native 开发人员很重要。\n\n## Metro 新功能\n\n众所周知，Metro 是 React Native 默认的 JS 打包模块，React Native 0.72 版本引入了 Metro 中的几个重要功能。\n\n### 支持 symlinks\n\n此版本的一个很重要的亮点是增加了对 Metro 中 symlinks 的 beta 版本支持，这也是社区一直长期要求的功能之一。\n\n简单来讲，该功能允许 Metro 去追踪 symlinks，从而支持各种以前不受支持的项目结构和工具。这一变化让 React Native 与 `monorepo` 设置和 `pnpm` 无缝协作，消除了对复杂解决方法或第三方工具的需求。\n\n### 支持 Package Exports\n\n同样，Metro 中添加了对 `包导出` 的支持，为 package.json 中的 `main` 字段提供了替代方案。\n\n借助`包导出`支持，库的作者现在可以明确定义用户应该可以访问其包的哪些部分，从而提供更好的封装并减少潜在的命名冲突。此增强功能简化了将外部库集成到 React Native 项目中的过程，并促进更好的代码组织。\n\n### 启用新功能\n\n如果想要启用上述两个新功能，只需要在 `metro.config.js` 文件里更新这两个配置即可：\n\n```\nconst config = {\n // …\n resolver: {\n   unstable_enableSymlinks: true,\n   unstable_enablePackageExports: true,\n },\n};\n```\n\n## 改进开发过程中的错误处理与上报\n\n相信各位 React Native 开发者经常在开发过程中遇到下面这个 RedBox 页面： ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f6feecd22743828667c612c2c0f55e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个确实是开发过程中一直以来的痛点之一，React Native 在 0.72 版本对此也进行了一些优化。\n\n### 无效样式不再通过 RedBox 提示\n\n在 React Native 0.72 中，开发过程中无效样式不再以 Redbox 的形式展示。\n\n相反，警告会记录到控制台，使开发人员更容易识别和修复样式错误，而不会影响用户体验。此更改提高了 React Native 应用程序的整体可用性，并提供了更流畅的开发工作流程。\n\n### 优化 Hermes 引擎对引用未定义函数的错误提示\n\nHermes 引擎改进了尝试调用未定义函数的错误消息，现在是直接 **显示被调用的变量名称**。\n\n这听起来可能很小，但相比之前的 `undefined is not a function` 提示相比，这可以说是一个很大的改进了。此外，堆栈跟踪现在会过滤掉内部字节代码帧，从而提供更具可读性的调用堆栈。\n\n最后，React Native CLI 本身也在此版本中进行了更新，通过减少重复、澄清措辞、减少详细的堆栈跟踪以及添加某些命令的相关文档的深层链接来增强错误输出。\n\n## 新架构及其性能改进\n\n之前我也写过一篇关于 [React Native 新架构](https://juejin.cn/post/7212143399037190181 \"https://juejin.cn/post/7212143399037190181\") 的介绍文章。\n\n如果您有一直关注 React Native 的更新，您就会知道每个新版本都会对 `新架构` 进行一些优化和改进，React Native 0.72 也不例外。\n\n### Fabric 渲染性能提升\n\n新的 Fabric 渲染引擎得到了提升：\n\n-   文本渲染性能在 iOS 上提高了 **27%**，在 Android 上提高了 **18%**。\n\n有关 Fabric 性能改进的更多详细信息，可以参考[这篇文章](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactwg%2Freact-native-new-architecture%2Fdiscussions%2F123 \"https://github.com/reactwg/react-native-new-architecture/discussions/123\")\n\n### Hermes 引擎性能提升\n\n新架构的 JavaScript 引擎 Hermes 也做了许多性能改进：\n\n-   大型 `object` 的编译速度更快了\n-   对 `JSON parse` 进行了多项优化\n\n这些改进将特别有利于您的应用进行大量 JSON 操作或者打包大量的对象。\n\n最后，对于 iOS，新架构现在与常用的 use\\_frameworks 兼容！ CocoaPod 配置——这对于许多应用程序集成先前版本的新架构来说是一个障碍。\n\n### 新架构工作组\n\n从 React Native 0.72 开始，为了更集中和更频繁的更新，新架构更新将由专门的工作组管理。\n\n如果您对新架构更新感兴趣，请务必关注[工作组](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactwg%2Freact-native-new-architecture%2Fdiscussions \"https://github.com/reactwg/react-native-new-architecture/discussions\")。\n\n## Breaking Changes 以及弃用的组件\n\nReact Native 0.72 有很多改进，这其中也包括一些默认包和功能的 breaking changes。如果您正打算升级到 0.72，请务必查看这些更改并相应地更新您的依赖项！\n\n主要变化是 **Slider、DatePickerIOS 和 ProgressViewIOS 等一些组件已从 React Native 核心中删除，并已提取到社区包中**。如果您正在使用这些组件，只需找到并安装推荐的社区包即可。\n\n此外，几个包已被重命名，现在位于 react-native/packages 下，并在 @react-native npm范围下发布。 这些更改不会影响不直接依赖于重命名的包的开发人员。\n\n但是，在升级到 React Native 0.72 时，开发人员应将任何重命名的依赖项更新为其 ~0.72 版本。\n\n## 写在最后\n\n如果您是一名长期的 React Native 开发者，您应该就会知道性能不佳一直是 React Native 一个最受开发者诟病的问题。\n\n不过可以看到的是，在过去的几个版本中，特别是随着新架构的引入，React Native 团队已经在花心思的重点解决性能问题，并已经取得了一些显著的成效。\n\nReact Native 还没 “死”，而且我相信它会越来越好。\n\n本文参考：\n\n-   [javascript.plainenglish.io/react-nativ…](https://link.juejin.cn/?target=https%3A%2F%2Fjavascript.plainenglish.io%2Freact-native-0-72-whats-new-and-why-does-it-matter-2dcaa02542ea \"https://javascript.plainenglish.io/react-native-0-72-whats-new-and-why-does-it-matter-2dcaa02542ea\")\n-   [github.com/facebook/re…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact-native%2Fblob%2Fmain%2FCHANGELOG.md%23v072 \"https://github.com/facebook/react-native/blob/main/CHANGELOG.md#v072\")\n\n> 不管您是从未接触过 RN 的小白，还是已经精通 RN 的大佬，都欢迎加入 **React Native 技术交流群**，一起畅所欲言吧～ !', 'public/uploads/1694327887508.png', 2, 2, 0, 432, '2023-09-10 06:38:46', 1);
INSERT INTO `article` VALUES (88, 8, '【iOS逆向与安全】编写一个使应用保持前台运行的系统插件', '## 前言\n\niOS越狱为用户打开了无限的可能性，其中之一是便是开发系统级插件，为了确保应用程序一直保持在前台，即使在意外情况下也是如此。\n\n本文将向您展示如何轻松编写这样的插件，让我们开始探索iOS系统插件的世界吧！\n\n___\n\n## 一、目标\n\n学会创建功能强大的iOS系统插件。\n\n## 二、开发环境和工具清单\n\n-   mac系统\n-   frida：动态调试\n-   已越狱iOS设备(iOS12.5.5)：动态调试及插件测试\n\n## 三、步骤\n\n## 1、定位关键函数\n\nSpringBoard是iOS系统非常重要的一个系统应用程序，它为用户提供了访问和管理应用程序的主要方式，同时也是用户与设备交互的一个重要界面。咱们今天的调试目标就是它。\n\n使用frida-trace动态调试地，如何给定关键词来缩小函数范围，我在这有几点经验：\n\n> 0.  根据类的前缀来减少不相关的类:\n>     \n>     如果你要跟踪的库为CoreFoundation.framework。那对应的trace为`frida-trace -UF -m \"*[CF* *]\"`\n>     \n>     同样，如果你要跟踪的库为AVFoundation.framework。那对应的trace为`frida-trace -UF -m \"*[AV* *]\"`\n>     \n>     这种命名约定的背后是，iOS系统库中的类名通常采用库名的首字母缩写加上具体类名的形式，以确保类名的唯一性和可读性。例如，MapKit.framework中的类MKMapView.h、CoreLocation.framework中的类CLLocationManager.h、以及AVFoundation.framework中的类AVCaptureSession.h都遵循了这一约定。\n>     \n>     为什么UIKit.framework里的是UILabel.h，而不是UIKLabel.h呢？因为这货出现得太早了，当时的命名规范还未形成。\n>     \n>     为什么Foundation.framework里的是NSString.h，而不是FString.h呢？这货也一样，太早了，命名不规范。NS的全称是NeXTStep框架，也就是Objective-c语言早期的实现之一，更多信息请google。\n>     \n> 1.  根据你的目标来限定关键词，如你想要跟踪的功能和定位有关系。那你可以尝试trace`\"*[*Location* *]\"`或`\"*[* *Location*]\"`。或者你要跟踪的和发送消息有关系。那你可以尝试trace`\"*[* *sendMsg*]\"`或`\"*[* *sendMsg]\"`。注：在这需要注意字母的大小写。比如Location，这个L有可能是写，这种情况你可以这样trace`\"*[* ocation*]\"`，不写这个L就好了嘛。\n>     \n\n那试想一下。我们今天的插件是不是和应用有关系，那它的关键词是不是就应该是Application或App。还有状态有关系。应用的切换，就在在各种状态之前变化，那这关键词是不是就是State或state。根据经验的第一条。咱们目标应用SpringBoard，那类名的前缀是不是应该是SB。\n\n连上你的手机，并启动任意程序。在终端执行`frida-trace -U -m \"*[SB* *]\" -o a.log SpringBoard`，然而，以SB开头的类太多了，这命令trace了3万多个函数，范围太广，手机直接卡死了......\n\n![later](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f51772aae91345e3ac231b8806131785~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=260&h=194&e=jpg&b=04021a)\n\n重新越狱调整命令为`frida-trace -U -m \"*[SB*pp* *]\" -o a.log SpringBoard`，将应用切换到后台，获取到关键日志如下：\n\n```\n  ......\n  ......\n  ......\n  ......\n  ......\n  ......\n  仍然太多了，你也可以一点点分析，看看哪些函数可疑，然后再跟踪。\n```\n\n再调试trace命令，加上state`frida-trace -U -m \"*[SB*pp* *tate*]\" -o a.log SpringBoard`，将应用切换到后台，获取到的部分关键日志如下：\n\n```\n-[SBMainDisplayWorkspaceAppInteractionEventSource layoutStateTransitionCoordinator:0x283547690 transitionDidEndWithTransitionContext:0x28275c900]\n-[SBAppToAppWorkspaceTransaction shouldPerformToAppStateCleanupOnCompletion]\n-[SBToAppsWorkspaceTransaction performToAppStateCleanup]\n-[SBWorkspaceApplicationSceneTransitionContext layoutState]\n-[SBWorkspaceApplicationSceneTransitionContext previousLayoutState]\n-[SBApplication _noteProcess:0x109b51300 didChangeToState:0x283be0880]\n-[SBApplication _updateProcess:<FBApplicationProcess: 0x109b51300; Cydia (com.saurik.Cydia); pid: 20212> withState:<FBProcessState: 0x283be0880; pid: 20212; taskState: Running; visibility: Background>]\n-[SBApplication _internalProcessState]\n-[SBApplicationProcessState taskState]\n-[SBApplication _internalProcessState]\n-[SBApplicationProcessState _initWithProcess:0x109b51300 stateSnapshot:0x283be0880]\n-[SBApplication _setInternalProcessState:0x283bf8f40]\n-[SBApplicationProcessState taskState]\n-[SBApplicationProcessState taskState]\n-[SBApplicationAutoLaunchService _applicationProcessStateDidChange:0x2835676f0]\n-[SBApplication processState]\n-[SBApplicationProcessState taskState]\n-[SBApplication _noteProcess:0x109b51300 didChangeToState:0x283b07b20]\n-[SBApplication _updateProcess:<FBApplicationProcess: 0x109b51300; Cydia (com.saurik.Cydia); pid: 20212> withState:<FBProcessState: 0x283b07b20; pid: 20212; taskState: Suspended; visibility: Background>]\n-[SBApplication _internalProcessState]\n-[SBApplicationProcessState taskState]\n-[SBApplication _internalProcessState]\n-[SBApplicationProcessState _initWithProcess:0x109b51300 stateSnapshot:0x283b07b20]\n-[SBApplication _setInternalProcessState:0x283b98ea0]\n-[SBApplicationProcessState taskState]\n-[SBApplicationProcessState taskState]\n-[SBApplicationAutoLaunchService _applicationProcessStateDidChange:0x283544690]\n-[SBApplication processState]\n-[SBApplication _internalProcessState]\n```\n\n从以上信息我们提取出关键类为`SBApplication`，可疑函数`-[SBApplication _noteProcess:0x109b51300 didChangeToState:0x283b07b20]`，跟踪该类`frida-trace -U -m \"-[SBApplication _noteProcess:didChangeToState:]\" -o a.log SpringBoard`，js代码如下：\n\n```\n{\n  onEnter(log, args, state) {\n    log(`-[SBApplication _noteProcess:${ObjC.Object(args[2])} didChangeToState:${ObjC.Object(args[3])}]`);\n  },\n  onLeave(log, retval, state) {\n  }\n}\n\n```\n\n应用切到后台，获取到日志如下：\n\n```\n-[SBApplication _noteProcess:<FBApplicationProcess: 0x113b1e540; Cydia (com.saurik.Cydia); pid: 20869> didChangeToState:<FBProcessState: 0x283bd71e0; pid: 20869; taskState: Running; visibility: Background>]\n-[SBApplication _noteProcess:<FBApplicationProcess: 0x113b1e540; Cydia (com.saurik.Cydia); pid: 20869> didChangeToState:<FBProcessState: 0x283b82660; pid: 20869; taskState: Suspended; visibility: Background>]\n```\n\n根据日志信息，可以看出。第一个参数里包含了我们当前的应用信息。第二个参数则是应用的状态。Running、Suspended、Not Running。\n\n至此，目标函数已找到。\n\n注：目标函数不止这一个，只要你通过你自己的关键词定位，尝试，也许是找到的其他函数。只要应用的状态正确且唯一，都可以使用。比如我之前调试过程中找到的函数是`[SBMainWorkspace process:stateDidChangeFromState:toState:]`，也是可以用的。\n\n## 2、编写插件代码\n\n使用Xcode的MonkeyDev插件的Logos Tweak来创建插件工程：\n\n![image-20230826005639156](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c0fc9ee3df6498c9a24c1bb7e862004~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=1140&h=686&e=png&b=fefefe)\n\n应用状态hook代码如下：\n\n```\n%hook SBMainWorkspace\n\n-(void)process:(id)arg1 stateDidChangeFromState:(id)arg2 toState:(id)arg3{\n    %orig;\n\n    // arg1的类型为：FBApplicationProcess，获取包名的方法名为bundleIdentifier\n    // arg3的类型为：FBProcessState，获取到状态的方法名为taskState\n    // 在这查找类对应的头文件：https://developer.limneos.net/index.php\n    \n    NSString *bundleID = [arg1 valueForKey:@\"bundleIdentifier\"];\n    BOOL isValid =  [AppAngel validBundleID:bundleID];\n\n    int toState = [[arg3 valueForKey:@\"taskState\"] intValue]; // 调试可得：2运行，3后台，1杀死\n\n    NSLog(@\"witwit =%@=%@=\", bundleID, arg3);\n    NSLog(@\"witwit hook=%d=%d=\", isValid, toState);\n    if (isValid {\n        if (toState == 3) {\n            [AppAngel launchApp:bundleID];\n        } else if (toState == 1) {\n            [AppAngel performSelector:@selector(launchApp:) withObject:bundleID afterDelay:1];\n        }\n    }\n}\n\n%end\n```\n\n由于插件开启后，目标应用无法切换到后台，这时你想关闭插件咋办？于是有了关闭快捷键音量-或电源键，相关hook代码如下：\n\n```\n%hook VolumeControl\n-(void)increaseVolume {\n    NSTimeInterval nowtime = [[NSDate date] timeIntervalSince1970];\n    NSLog(@\"witwit iosother increaseVolume\");\n\n    if (nowtime - g_volume_up_time < 1) {\n       g_volume_up_count += 1;\n       if (g_volume_up_count >= 2) {\n            g_volume_up_count = 0;\n            [AppAngel enablePlugins:YES];\n        }\n    } else {\n        g_volume_up_count = 0;\n    }\n    %orig;\n    g_volume_up_time = nowtime;\n}\n\n-(void)decreaseVolume {\n    NSTimeInterval nowtime = [[NSDate date] timeIntervalSince1970];\n    NSLog(@\"witwit iosother decreaseVolume\");\n\n    if (nowtime - g_volume_down_time < 1) {\n       g_volume_down_count += 1;\n       if (g_volume_down_count >= 2) {\n            g_volume_down_count = 0;\n            [AppAngel enablePlugins:NO];\n        }\n    } else {\n        g_volume_down_count = 0;\n    }\n    %orig;\n    g_volume_down_time = nowtime;\n}\n\n// 在使用音量键开启或关闭插件的toast在iOS12系统中会和音量弹窗重叠，hook音量弹窗\n- (BOOL)_HUDIsDisplayableForCategory:(NSString *)category {\n    if ([category isEqualToString:@\"Audio/Video\"]) {\n        return NO;\n    }\n    return %orig;\n}\n\n%end\n```\n\n电源键监听相关代码如下：\n\n```\n // 注册锁屏通知\n    notify_register_dispatch(\"com.apple.springboard.lockstate\", &notifyToken, dispatch_get_main_queue(), ^(int token) {\n        uint64_t state = 0;\n        notify_get_state(token, &state);\n        BOOL isScreenLocked = state == 1;\n        \n        if (isScreenLocked) {\n            NSLog(@\"witwit 锁屏了\");\n            if ( [AppAngel getPreferencesWithKey:@\"HookEnable\"]) {\n                [AppAngel enablePlugins:NO];\n            }\n        }\n    });\n```\n\n由于我们可以会对特定的App进行配置。于是使用AppList插件来实现该界面：\n\n![image-20230826004858208](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fee8e29f54f476c860daba43c660faf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp#?w=750&h=1334&e=png&b=fefefe)\n\n相关源码如下：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>entry</key>\n  <dict>\n    <key>bundle</key>\n    <string>AppList</string>\n    <key>cell</key>\n    <string>PSLinkCell</string>\n    <key>icon</key>\n    <string>/Library/PreferenceLoader/Preferences/AppAngelIcon.png</string>\n    <key>isController</key>\n    <string>1</string>\n    <key>label</key>\n    <string>应用天使</string>\n    <key>ALSettingsPath</key>\n    <string>/var/mobile/Library/Preferences/com.witchan.AppAngel.plist</string>\n    <key>ALSettingsKeyPrefix</key>\n    <string>witwit-</string>\n    <key>ALChangeNotification</key>\n    <string>com.rpetrich.applist.sample.notification</string>\n    <key>ALAllowsSelection</key>\n    <string>1</string>\n    <key>ALSectionDescriptors</key>\n    <array>\n      <dict>\n        <key>items</key>\n        <array>\n          <dict>\n            <key>text</key>\n            <string>关于我</string>\n            <key>action</key>\n            <string>launchURL</string>\n            <key>url</key>\n            <string>https://mp.weixin.qq.com/s/WERMNPzW6WV5YGFthVqCRg</string>\n          </dict>\n        </array>\n      </dict>\n      <dict>\n        <key>footer-title</key>\n        <string>连按音量+键开启插件，连按音量-或电源键停止插件                                                         </string>\n        <key>items</key>\n        <array>\n          <dict>\n            <key>cell-class-name</key>\n            <string>ALSwitchCell</string>\n            <key>default</key>\n            <string>NO</string>\n            <key>ALSettingsKey</key>\n            <string>witwit-HookEnable</string>\n            <key>text</key>\n            <string>插件开关</string>\n          </dict>\n        </array>\n      </dict>\n      <dict>\n        <key>title</key>\n        <string>用户应用</string>\n        <key>predicate</key>\n        <string>isSystemApplication = FALSE</string>\n        <key>cell-class-name</key>\n        <string>ALSwitchCell</string>\n        <key>icon-size</key>\n        <string>29</string>\n        <key>suppress-hidden-apps</key>\n        <string>1</string>\n      </dict>\n      <dict>\n        <key>title</key>\n        <string>系统应用</string>\n        <key>predicate</key>\n        <string>isSystemApplication = TRUE</string>\n        <key>cell-class-name</key>\n        <string>ALSwitchCell</string>\n        <key>icon-size</key>\n        <string>29</string>\n        <key>suppress-hidden-apps</key>\n        <string>1</string>\n      </dict>\n    </array>\n  </dict>\n</dict>\n</plist>\n\n```\n\n___\n\n## 总结\n\n本文主要系统插件的实现过程进行了分析及试验，插件名叫【应用天使】已在iOS12和15系统上测试并通过，已上传到bigboss源。需要的同学请可下载使用，当你在使用中遇到任何问题也可向我反馈。如需要插件完整源码，请公众号回复【应用天使】即可获取完整代码。\n\n> 注：在iOS15系统中，bigboss源的AppList插件不支持，请从[repo.palera.in/](https://link.juejin.cn/?target=https%3A%2F%2Frepo.palera.in%2F \"https://repo.palera.in/\")源里下载并安装AppList，或者自行下载支持iOS15的AppList。\n\n> 提示：阅读此文档的过程中遇到任何问题，请关住工众好【_`移动端Android和iOS开发技术分享`_】或+99 君羊【_`812546729`_】', '', 5, 4, 0, 61, '2023-06-10 07:34:54', 1);
INSERT INTO `article` VALUES (89, 6, 'Mr.', 'Remember that failure is an event, not a person. Actually it is just in an idea when feel oneself can achieve and cannot achieve. If it scares you, it might be a good thing to try. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. Sometimes you win, sometimes you learn. To get a secure connection, the first thing you need to do is to install OpenSSL Library and download Database Source. Remember that failure is an event, not a person. A query is used to extract data from the database in a readable format according to the user\'s request. Difficult circumstances serve as a textbook of life for people. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. A man is not old until regrets take the place of dreams. To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. The past has no power over the present moment. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. A man is not old until regrets take the place of dreams. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. If opportunity doesn’t knock, build a door. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. Success consists of going from failure to failure without loss of enthusiasm. To connect to a database or schema, simply double-click it in the pane. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more.', '', 1, 4, 0, 356, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (90, 7, '【后端面经-Java】AQS详解', '## 1\\. AQS是什么？\n\nAQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock。 简单来说，**AQS定义了一套框架，来实现同步类**。\n\n## 2\\. AQS核心思想\n\n### 2.1 基本框架\n\nAQS的核心思想是对于共享资源，维护一个双端队列来管理线程，队列中的线程依次获取资源，获取不到的线程进入队列等待，直到资源释放，队列中的线程依次获取资源。 AQS的基本框架如图所示： ![框架.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc6687933b2418895cb7319a006462d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n#### 2.1.1 资源state\n\nstate变量表示共享资源，通常是`int`类型。\n\n1.  **访问方法** state类型用户无法直接进行修改，而需要借助于AQS提供的方法进行修改，即`getState()`、`setState()`、`compareAndSetState()`等。\n2.  **访问类型** AQS定义了两种资源访问类型:\n    -   独占（Exclusive）:一个时间点资源只能由一个线程占用；\n    -   共享（Share）:一个时间点资源可以被多个线程共用。\n\n#### 2.1.2 CLH双向队列\n\nCLH队列是一种基于逻辑队列非线程饥饿的自旋公平锁，具体介绍可参考[此篇博客](https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_47184173%2Farticle%2Fdetails%2F115340014 \"https://blog.csdn.net/weixin_47184173/article/details/115340014\")。CLH中每个节点都表示一个线程，处于头部的节点获取资源，而其他资源则等待。\n\n1.  **节点结构** `Node`类源码如下所示：\n\n```\nstatic final class Node {\n    // 模式，分为共享与独占\n    // 共享模式\n    static final Node SHARED = new Node();\n    // 独占模式\n    static final Node EXCLUSIVE = null;        \n    // 结点状态\n    // CANCELLED，值为1，表示当前的线程被取消\n    // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark\n    // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中\n    // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行\n    // 值为0，表示当前节点在sync队列中，等待着获取锁\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;        \n\n    // 结点状态\n    volatile int waitStatus;        \n    // 前驱结点\n    volatile Node prev;    \n    // 后继结点\n    volatile Node next;        \n    // 结点所对应的线程\n    volatile Thread thread;        \n    // 下一个等待者\n    Node nextWaiter;\n    \n    // 结点是否在共享模式下等待\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n    \n    // 获取前驱结点，若前驱结点为空，抛出异常\n    final Node predecessor() throws NullPointerException {\n        // 保存前驱结点\n        Node p = prev; \n        if (p == null) // 前驱结点为空，抛出异常\n            throw new NullPointerException();\n        else // 前驱结点不为空，返回\n            return p;\n    }\n    \n    // 无参构造方法\n    Node() {    // Used to establish initial head or SHARED marker\n    }\n    \n    // 构造方法\n        Node(Thread thread, Node mode) {    // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    \n    // 构造方法\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n\n```\n\n`Node`的方法和属性值如图所示：\n\n![node节点.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e360c3483e47b78783925ba51971b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n其中,\n\n-   `waitStatus`表示当前节点在队列中的状态；\n-   `thread`表示当前节点表示的线程；\n-   `prev`和`next`分别表示当前节点的前驱节点和后继节点；\n-   `nextWaiter`d当存在CONDTION队列时，表示一个condition状态的后继节点。\n\n2.  **waitStatus** 结点的等待状态是一个整数值，具体的参数值和含义如下所示：\n\n-   `1`\\-`CANCELLED`，表示节点获取锁的请求被取消，此时节点不再请求资源；\n-   `0`，是节点初始化的默认值；\n-   `-1`\\-`SIGNAL`,表示线程做好准备，等待资源释放；\n-   `-2`\\-`CONDITION`，表示节点在condition等待队列中，等待被唤醒而进入同步队列；\n-   `-3`\\-`PROPAGATE`，当前线程处于共享模式下的时候会使用该字段。\n\n### 2.2 AQS模板\n\nAQS提供一系列结构，作为一个完整的模板，**自定义的同步器只需要实现资源的获取和释放就可以**，而不需要考虑底层的队列修改、状态改变等逻辑。 使用AQS实现一个自定义同步器，需要实现的方法：\n\n-   `isHeldExclusively()`：该线程是否独占资源，在使用到condition的时候会实现这一方法；\n-   `tryAcquire(int)`：独占模式获取资源的方式，成功获取返回`true`，否则返回`false`;\n-   `tryRelease(int)`:独占模式释放资源的方式，成功获取返回`true`，否则返回`false`;\n-   `tryAcquireShared(int)`：共享模式获取资源的方式，成功获取返回`true`，否则返回`false`;\n-   `tryReleaseShared(int)`：共享模式释放资源的方式，成功获取返回`true`，否则返回`false`;\n\n一般来说，一个同步器是资源独占模式或者资源共享模式的其中之一，因此`tryAcquire(int)`和`tryAcquireShared(int)`只需要实现一个即可，`tryRelease(int)`和`tryReleaseShared(int)`同理。 但是同步器也可以实现两种模式的资源获取和释放，从而实现独占和共享两种模式。\n\n## 3\\. 源码分析\n\n### 3.1 acquire(int)\n\n`acquire(int)`是获取源码部分的顶层入口，源码如下所示：\n\n```\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n这段代码展现的资源获取流程如下：\n\n-   `tryAcquire()`尝试直接去获取资源；获取成功则直接返回\n-   如果获取失败，则`addWaiter()`将该线程加入等待队列的尾部，并标记为独占模式；\n-   `acquireQueued()`使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。\n\n简单总结就是：\n\n-   获取资源；\n-   失败就排队；\n-   排队要等待。\n\n从上文的描述可见重要的方法有三个：`tryAquire()`、`addWaiter()`、`acquireQueued()`。下面将逐个分析其源码：\n\n#### 3.1.1 tryAcquire(int)\n\n`tryAcquire(int)`是获取资源的方法，源码如下所示：\n\n```\nprotected boolean tryAcquire(int arg) {\n      throw new UnsupportedOperationException();\n}\n```\n\n该方法是一个空方法，需要自定义同步器实现，因此在使用AQS实现同步器时，需要重写该方法。这也是“**自定义的同步器只需要实现资源的获取和释放就可以**”的体现。\n\n#### 3.1.2 addWaiter(Node.EXCLUSIVE)\n\n`addWaiter(Node.EXCLUSIVE)`是将线程加入等待队列的尾部，源码如下所示：\n\n```\nprivate Node addWaiter(Node mode) {\n    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）\n    //aquire()方法是独占模式，因此直接使用Exclusive参数。\n    Node node = new Node(Thread.currentThread(), mode);\n\n    //尝试快速方式直接放到队尾。\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n\n    //上一步失败则通过enq入队。\n    enq(node);\n    return node;\n}\n```\n\n首先，使用模式将当前线程构造为一个节点，然后尝试将该节点放入队尾，如果成功则返回，否则调用`enq(node)`将节点放入队尾，最终返回当前节点的位置指针。 其中，`enq(node)`方法是将节点加入队列的方法，源码如下所示：\n\n```\nprivate Node enq(final Node node) {\n    for (;;) { // 无限循环，确保结点能够成功入队列\n        // 保存尾结点\n        Node t = tail;\n        if (t == null) { // 尾结点为空，即还没被初始化\n            if (compareAndSetHead(new Node())) // 头节点为空，并设置头节点为新生成的结点\n                tail = head; // 头节点与尾结点都指向同一个新生结点\n        } else { // 尾结点不为空，即已经被初始化过\n            // 将node结点的prev域连接到尾结点\n            node.prev = t; \n            if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node\n                // 设置尾结点的next域为node\n                t.next = node; \n                return t; // 返回尾结点\n            }\n        }\n    }\n}\n```\n\n#### 3.1.3 acquireQueued(Node node, int arg)\n\n这部分源码是将线程阻塞在等待队列中，线程处于等待状态，直到获取到资源后才返回，源码如下所示：\n\n```\n// sync队列中的结点在独占且忽略中断的模式下获取(资源)\nfinal boolean acquireQueued(final Node node, int arg) {\n    // 标志\n    boolean failed = true;\n    try {\n        // 中断标志\n        boolean interrupted = false;\n        for (;;) { // 无限循环\n            // 获取node节点的前驱结点\n            final Node p = node.predecessor(); \n            if (p == head && tryAcquire(arg)) { // 前驱为头节点并且成功获得锁\n                setHead(node); // 设置头节点\n                p.next = null; // help GC\n                failed = false; // 设置标志\n                return interrupted; \n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())//\n                //shouldParkAfterFailedAcquire只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。\n                //parkAndCheckInterrupt首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n`acquireQueued(Node node, int arg)`方法的主要逻辑如下：\n\n-   获取`node`节点的前驱结点,判断前驱节点是不是头部节点head，有没有成功获取资源。\n-   如果前驱结点是头部节点head并且获取了资源，说明自己应该被唤醒，设置该节点为head节点等待下一个获得资源；\n-   如果前驱节点不是头部节点或者没有获取资源，则判断是否需要park当前线程，\n    -   判断前驱节点状态是不是`SIGNAL`，是的话则park当前节点，否则不执行park操作；\n-   `park`当前节点之后，当前节点进入等待状态，等待被其他节点`unpark`操作唤醒。然后重复此逻辑步骤。\n\n### 3.2 release(int)\n\n`release(int)`是释放资源的顶层入口方法，源码如下所示：\n\n```\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) { // 释放成功\n        // 保存头节点\n        Node h = head; \n        if (h != null && h.waitStatus != 0) // 头节点不为空并且头节点状态不为0\n            unparkSuccessor(h); //释放头节点的后继结点\n        return true;\n    }\n    return false;\n}\n```\n\n`release(int)`方法的主要逻辑如下：\n\n-   尝试释放资源，如果释放成功则返回`true`，否则返回`false`；\n-   释放成功之后，需要调用`unparkSuccessor(h)`唤醒后继节点。\n\n下面介绍两个重要的源码函数：`tryRelease(int)`和`unparkSuccessor(h)`。\n\n#### 3.2.1 tryRelease(int)\n\n`tryRelease(int)`是释放资源的方法，源码如下所示：\n\n```\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n这部分是需要自定义同步器自己实现的，要注意的是返回值需要为`boolean`类型，表示释放资源是否成功。\n\n#### 3.2.2 unparkSuccessor(h)\n\n`unparkSuccessor(h)`是唤醒后继节点的方法，源码如下所示：\n\n```\nprivate void unparkSuccessor(Node node) {\n    //这里，node一般为当前线程所在的结点。\n    int ws = node.waitStatus;\n    if (ws < 0)//置零当前线程所在的结点状态，允许失败。\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;//找到下一个需要唤醒的结点s\n    if (s == null || s.waitStatus > 0) {//如果为空或已取消\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev) // 从后向前找。\n            if (t.waitStatus <= 0)//从这里可以看出，<=0的结点，都是还有效的结点。\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);//唤醒\n}\n```\n\n这部分主要是查找第一个还处于等待状态的节点，将其唤醒； 查找顺序是从后往前找，这是因为CLH队列中的`prev`链是强一致的，从后往前找更加安全，而`next`链因为`addWaiter()`方法和`cancelAcquire()`方法的存在，不是强一致的，因此从前往后找可能会出现问题。这部分的具体解释可以参考[参考文献-1](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fwaterystone%2Fp%2F4920797.html \"https://www.cnblogs.com/waterystone/p/4920797.html\")\n\n### 3.3 acquireShared(int)和releaseShared(int)\n\n#### 3.3.1 acquireShared(int)\n\n是使用共享模式获取共享资源的顶层入口方法，源码如下所示：\n\n```\npublic final void acquireShared(int arg) {\n     if (tryAcquireShared(arg) < 0)\n         doAcquireShared(arg);\n}\n```\n\n流程如下：\n\n-   通过`tryAcquireShared(arg)`尝试获取资源，如果获取成功则直接返回；\n-   如果获取资源失败，则调用`doAcquireShared(arg)`将线程阻塞在等待队列中，直到被`unpark()`/`interrupt()`并成功获取到资源才返回。\n\n其中，`tryAcquireShared(arg)`是获取共享资源的方法，也是需要用户自己实现。\n\n而`doAcquireShared(arg)`是将线程阻塞在等待队列中，直到获取到资源后才返回，具体流程和`acquireQueued()`方法类似， 源码如下所示：\n\n```\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);//加入队列尾部\n    boolean failed = true;//是否成功标志\n    try {\n        boolean interrupted = false;//等待过程中是否被中断过的标志\n        for (;;) {\n            final Node p = node.predecessor();//前驱\n            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的\n                int r = tryAcquireShared(arg);//尝试获取资源\n                if (r >= 0) {//成功\n                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程\n                    p.next = null; // help GC\n                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n\n            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n#### 3.3.2 releaseShared(int)\n\n`releaseShared(int)`是释放共享资源的顶层入口方法，源码如下所示：\n\n```\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {//尝试释放资源\n        doReleaseShared();//唤醒后继结点\n        return true;\n    }\n    return false;\n}\n```\n\n流程如下：\n\n-   使用`tryReleaseShared(arg)`尝试释放资源，如果释放成功则返回true，否则返回false；\n-   如果释放成功，则调用`doReleaseShared()`唤醒后继节点。\n\n下面介绍一下`doReleaseShared()`方法，源码如下所示：\n\n```\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                unparkSuccessor(h);//唤醒后继\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        if (h == head)// head发生变化\n            break;\n    }\n}\n```\n\n## 4\\. 面试问题模拟\n\n> Q：AQS是接口吗？有哪些没有实现的方法？看过相关源码吗？\n\nAQS定义了一个实现同步类的框架，实现方法主要有`tryAquire`和`tryRelease`，表示独占模式的资源获取和释放，`tryAquireShared`和`tryReleaseShared`表示共享模式的资源获取和释放。 源码分析如上文所述。\n\n## 参考资料\n\n1.  [Java并发之AQS详解](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fwaterystone%2Fp%2F4920797.html \"https://www.cnblogs.com/waterystone/p/4920797.html\")\n2.  [JUC锁: 锁核心类AQS详解](https://link.juejin.cn/?target=https%3A%2F%2Fpdai.tech%2Fmd%2Fjava%2Fthread%2Fjava-thread-x-lock-AbstractQueuedSynchronizer.html \"https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html\")\n3.  [从ReentrantLock的实现看AQS的原理及应用](https://link.juejin.cn/?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F12%2F05%2Faqs-theory-and-apply.html \"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\")', 'public/uploads/1694354850030.png', 3, 9, 1, 197, '2023-09-10 14:07:40', 1);
INSERT INTO `article` VALUES (91, 7, 'Golang如何在编译时注入版本信息', '## Golang如何在编译时注入版本信息\n\n## 问题\n\n一般而言，稍微做得好一点的开源软件，其二进制文件都会带上版本信息，比如`Docker`，你可以通过以下命令来查看：\n\n```\n$ docker --version\nDocker version 20.10.17, build 100c701\n$ docker version\n...\n//输出太长，这里就不展示了\n```\n\n有些Web应用还提供了`/version`接口，你可以通过接口来获取：\n\n```\n$ curl http://127.0.0.1:8080/version | jq\n{\n  \"Build Time\": \"Fri, 16 Jun 2023 16:19:23 +0800\",\n  \"Git Commit\": \"b554659\",\n  \"Go Version\": \"go1.19\",\n  \"OS/Arch\": \"darwin/amd64\",\n  \"version\": \"0.9.2\"\n}\n```\n\n然而很多公司并没有这方面的强制性规范，多数开发人员也没有这样的意识或习惯，所以大部分项目并没有实现这个功能。如果二进制文件不带上版本信息，你可能要借助其它系统来查询或追溯，这无疑是一件难受的事，对于代码调试和问题定位很不友好。\n\n那么在`Golang`中，如何实现这个功能呢？\n\n## 思路\n\n版本信息有很多，比如代码版本号、Git提交号、编译时间、Go版本号等，如何让二进制文件带上这些信息呢？\n\n硬编码在代码里肯定不行。因为Git提交号是将代码提交到代码仓库时才产生，而Go版本号和编译时间只有在编译时才能拿到。\n\n比较合理的做法是在编译时注入。Go编译工具提供了`-ldflags`选项，通过`-X`参数可以注入包变量的值，我们只需要在代码中将版本信息定义成包变量，然后在编译时完成注入即可。这个过程可以实现为自动化完成，下面以`make`工具为例说明。\n\n## 实现步骤\n\n###### 1\\. 在代码中定义版本信息的变量\n\n将代码版本号、Git提交号、编译时间定义为包变量：\n\n```\npackage config\n\nvar (\nVersion   string  //代码版本号\nGitCommit string  //Git提交号\nBuildTime string  //编译时间\n)\n```\n\nGo版本号等信息可以借助`runtime`包获取：\n\n```\nruntime.Version()  //Go版本\nruntime.GOOS       //操作系统\nruntime.GOARCH     //平台架构\n```\n\n###### 2\\. 在代码中使用这些变量\n\n1）实现`--version`参数或`version`子命令\n\n以[`Cobra`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fspf13%2Fcobra \"https://github.com/spf13/cobra\")命令行框架为例，为rootCmd实现`--version`参数：\n\n```\nrootCmd.Version = config.Version\nrootCmd.SetVersionTemplate(fmt.Sprintf(`{{with .Name}}{{printf \"%%s version information: \" .}}{{end}}\n    {{printf \"Version:    %%s\" .Version}}\n    Git Commit: %s\n    Build Time: %s\n    Go version: %s\n    OS/Arch:    %s/%s\n`, config.GitCommit, config.BuildTime, runtime.Version(), runtime.GOOS, runtime.GOARCH))\n```\n\n2）实现`/version`接口\n\n以[`Gin`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgin-gonic%2Fgin \"https://github.com/gin-gonic/gin\")框架为例，将`/version`路由到如下的`Version`函数：\n\n```\nfunc Version(ctx *gin.Context) {\nctx.Writer.Header().Set(\"Content-Type\", \"application/json\")\nctx.Writer.WriteHeader(http.StatusOK)\njson.NewEncoder(ctx.Writer).Encode(map[string]string{\n\"version\":    config.Version,\n\"Git Commit\": config.GitCommit,\n\"Build Time\": config.BuildTime,\n\"Go Version\": runtime.Version(),\n\"OS/Arch\":    runtime.GOOS + \"/\" + runtime.GOARCH,\n})\n}\n```\n\n###### 3\\. 在编译前获取版本信息\n\n在`Makefile`中，用`git`命令获取代码版本号、Git提交号，用`date`命令获取当前时间\n\n```\nVERSION    = $(shell git describe --tags --always)\nGIT_COMMIT = $(shell git rev-parse --short HEAD)\nBUILD_TIME = $(shell date -R)\n```\n\n###### 4\\. 在编译时注入版本信息\n\n在`Makefile`中，通过`-ldflags`选项为`go build`命令传入编译参数，实现版本信息的注入\n\n```\ndefine LDFLAGS\n\"-X \'github.com/myname/myapp/config.Version=${VERSION}\' \\\n-X \'github.com/myname/myapp/config.GitCommit=${GIT_COMMIT}\' \\\n-X \'github.com/myname/myapp/config.BuildTime=${BUILD_TIME}\'\"\nendef\n\nbuild:\n    go build -ldflags ${LDFLAGS} -o myapp_${VERSION} .\n```\n\n###### 5\\. 验证效果\n\n编译出二进制，即可验证`--version`参数；用二进制启动服务进程，即可验证`/version`接口。\n\n```\n$ make build\n...\n//编译过程，省略输出\n\n$ myapp --version\nmyapp version information: \n    Version:    0.9.2\n    Git Commit: b554659\n    Build Time: Sat, 17 Jun 2023 11:30:44 +0800\n    Go version: go1.20.5\n    OS/Arch:    darwin/arm64\n\n$ myapp\n...\n//启动进程，省略输出\n\n$ curl http://127.0.0.1:8080/version | jq\n{\n  \"Build Time\": \"Sat, 17 Jun 2023 11:30:44 +0800\",\n  \"Git Commit\": \"b554659\",\n  \"Go Version\": \"go1.20.5\",\n  \"OS/Arch\": \"darwin/arm64\",\n  \"version\": \"0.9.2\"\n}\n```\n\n## 总结\n\n二进制文件直接带上版本信息，能为代码调试和问题定位带来很大的方便。本文介绍了通过`-ldflags`选项实现在编译时注入版本信息的具体做法。\n\n这是一个比较通用的方法，很多开源软件比如 [Docker](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmoby%2Fmoby \"https://github.com/moby/moby\") 也是这样做的。', 'public/uploads/1694354904783.png', 3, 3, 1, 384, '2023-09-10 14:08:26', 1);
INSERT INTO `article` VALUES (92, 4, 'Ms.', 'Creativity is intelligence having fun. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. Flexible settings enable you to set up a custom key for comparison and synchronization. Anyone who has ever made anything of importance was disciplined. To open a query using an external editor, control-click it and select Open with External Editor. You can set the file path of an external editor in Preferences. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. If it scares you, it might be a good thing to try. The Synchronize to Database function will give you a full picture of all database differences. I destroy my enemies when I make them my friends. Optimism is the one quality more associated with success and happiness than any other. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. Success consists of going from failure to failure without loss of enthusiasm. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. You will succeed because most people are lazy. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. It wasn’t raining when Noah built the ark. Flexible settings enable you to set up a custom key for comparison and synchronization. The Synchronize to Database function will give you a full picture of all database differences. Remember that failure is an event, not a person. It provides strong authentication and secure encrypted communications between two hosts, known as SSH Port Forwarding (Tunneling), over an insecure network. Secure SHell (SSH) is a program to log in into another computer over a network, execute commands on a remote server, and move files from one machine to another. If the Show objects under schema in navigation pane option is checked at the Preferences window, all database objects are also displayed in the pane. A query is used to extract data from the database in a readable format according to the user\'s request. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. The past has no power over the present moment. I destroy my enemies when I make them my friends. Actually it is just in an idea when feel oneself can achieve and cannot achieve. I destroy my enemies when I make them my friends. After comparing data, the window shows the number of records that will be inserted, updated or deleted in the target. To start working with your server in Navicat, you should first establish a connection or several connections using the Connection window. Typically, it is employed as an encrypted version of Telnet. Monitored servers include MySQL, MariaDB and SQL Server, and compatible with cloud databases like Amazon RDS, Amazon Aurora, Oracle Cloud, Google Cloud and Microsoft Azure. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. Anyone who has never made a mistake has never tried anything new. The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. If the plan doesn’t work, change the plan, but never the goal. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily. I will greet this day with love in my heart. A comfort zone is a beautiful place, but nothing ever grows there. Navicat Cloud provides a cloud service for synchronizing connections, queries, model files and virtual group information from Navicat, other Navicat family members, different machines and different platforms. Flexible settings enable you to set up a custom key for comparison and synchronization. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. The Synchronize to Database function will give you a full picture of all database differences. The Main Window consists of several toolbars and panes for you to work on connections, database objects and advanced tools. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. In the middle of winter I at last discovered that there was in me an invincible summer. You cannot save people, you can just love them. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. Remember that failure is an event, not a person. If your Internet Service Provider (ISP) does not provide direct access to its server, Secure Tunneling Protocol (SSH) / HTTP is another solution. There is no way to happiness. Happiness is the way. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. If it scares you, it might be a good thing to try. In the Objects tab, you can use the List List, Detail Detail and ER Diagram ER Diagram buttons to change the object view. Optimism is the one quality more associated with success and happiness than any other. The Information Pane shows the detailed object information, project activities, the DDL of database objects, object dependencies, membership of users/roles and preview. Navicat Data Modeler enables you to build high-quality conceptual, logical and physical data models for a wide variety of audiences. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. I destroy my enemies when I make them my friends. To connect to a database or schema, simply double-click it in the pane. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. Navicat provides a wide range advanced features, such as compelling code editing capabilities, smart code-completion, SQL formatting, and more. To open a query using an external editor, control-click it and select Open with External Editor. You can set the file path of an external editor in Preferences. Typically, it is employed as an encrypted version of Telnet. Success consists of going from failure to failure without loss of enthusiasm. Navicat Monitor is a safe, simple and agentless remote server monitoring tool that is packed with powerful features to make your monitoring effective as possible. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. Champions keep playing until they get it right.', '', 1, 2, 0, 465, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (93, 7, '看看成都Go面试卷不卷？游戏行业 3年经验 20k+', 'Go最新面经分享：算法、并发模型、缓存落盘、etcd、actor模型、epoll等等...\n\n本文先分享2段面经，**文末总结了关键问题的复盘笔记**。一定要看到最后！\n\n## 求职者情况\n\n分享一下好友的最新面经。\n\n简单说下这位好友的情况：坐标成都，游戏行业，**3年开发经验，最近2年做Go语言开发，1年Java/PHP工作经验。**\n\n手撕CSAPP选手，半年前坚持打卡**手写的学习笔记**。（最近半年被公司摧残，没时间了....）\n\n**大家有啥好坑，欢迎联系我，帮我好友内推哈。**\n\n## 面经分享\n\n### 第一家\n\n> Golang后端，3年+经验，游戏行业，成都，15~25K\n\n下面以对话的方式大概描述问题：\n\nA--->面试官\n\nB--->我\n\nA：自我介绍\n\nB：巴拉巴拉\n\nA：Actor 模型你是怎么理解的？\n\nB：无锁的并发计算模型，Actor 有自己的状态，只能通过 mailBox 去收发消息、异步消息传递~\n\nA：你不是百度了吧？\n\nB：没有。因为我觉得它的一部分思想和 Go 的 GMP 挺像的，好记（这里我就给自己挖坑了，擦嘞~）\n\nA：你能说说它们哪里像吗？\n\nB：Go 的调度器全局队列和它的 MailBox 挺像的\n\nA：那你的意思是，实现 MailBox，你会使用队列吗？\n\nB：是的，用 chan 关键字，元素类型为 Interface\n\nA：**这样是可以，那么我给你一个场景，在同一时刻，有 1 万个消息打进来呢？**\n\nB：增加缓冲区大小、无锁队列、批量处理消息、背压机制\n\nA：能从数据结构的角度说说吗？\n\nB：chan 底层是数组，线性结构，我想用非线性结构红黑树接收消息\n\nA：为什么？\n\nB：因为 epoll 模型就是这么做的\n\nA：优势是什么\n\nB：忘了...\n\nA：你再想想，比如动态调整缓冲区，可是是一瞬间打进来的，你怎么知道调整的多大，预留也不好做，巴拉巴拉\n\nB：额，不知道\n\nA：**用环形队列**\n\nB：啊？我没想到，因为我的印象里，它的特定是固定大小，消息太多了，不是会覆盖吗，会导致消息丢失。（我提出这个疑问的时候，他没有继续给我聊了，如果只用环形队列肯定有这个问题）我确实没有想到，很少用到它...\n\nA：你能聊聊分布式吗？\n\nB：巴拉巴拉，有扩展性、容错、很多节点，不同地域、数据共享，巴拉巴拉\n\nA：你提到了数据共享，那你说说一致性你怎么做？\n\nB：我会先想到用 etcd 吧，因为它的 raft 可以保证一致性\n\nA：继续...\n\nB：**etcd Leader选举、数据复制、心跳、然后读取，保证一致性**，巴拉巴拉它们的细节\n\nA：etcd 是键值数据库呀，主要场景是配置之类的吧，那我现在有一个场景，就是 10w qps 如何承载 50w qps 的场景，同时保证它们的数据一致性\n\nB：啥？（我有点没听懂这个问题，硬来）首先是能够承载这个量级吧，考虑主从复制，然后用分片技术水平扩展、异步处理、加缓存巴拉巴拉\n\nA：主从同步你能说说典型的应用吗？\n\nB：（我已经被前面那个问题问蒙蔽了，想说 Redis 的，有点开不了口）额...\n\nA：Redis 就是主从吧！\n\nB：是....是的\n\n然后就下来就是 Redis 拷打小皮鞭了，不多说了，谢谢大家。\n\n### 第二家\n\n> Golang后端，坐标成都，游戏行业，15~20k\n\n先说感受，总体不是很难。下面听我慢慢聊：\n\nA -> 面试官\n\nB -> 我\n\nA：自我介绍\n\nB：巴拉巴拉\n\nA：我看你简历上提到力扣做了挺多题的。\n\nB：是的，但是已经有段时间没做了，做过的题我都有基本思路。\n\nA：你能说说你知道哪些排序吗？\n\nB：冒泡、选择、插入、快速、归并、堆、桶\n\nA：快排你能说一下它的思路吗？\n\nB：通过选择一个基准元素，将数组分割成左右两个子数组，再对子数组进行递归排序，直到整个数组有序。\n\nA：稳定排序和不稳定排序的概念能换说一下吗？\n\nB：假如排序前后两个元素的相对顺序在排序后仍然不变，那么这种算法就是稳定排序。不稳定排序反之。（这里答的其实不太好，可以结合前面提到的排序算法说一下，哪些具体的算法是稳定的）\n\nA：你对二叉树了解吗？\n\nB：了解的，树形结构，有根节点、父节点、子节点、叶子节点、度、高度、深度这些概念。\n\nA：常见的二叉树有哪些？\n\nB：平衡二叉树、二叉搜索树，巴拉巴拉。\n\nA：能说一下前序遍历和后序遍历吗？\n\nB：前序遍历，遍历顺序是根节点、左子树、右子树。后序遍历是左子树、右子树、根节点。\n\nA：前序遍历和后续遍历能够构建一颗二叉树吗？\n\nB：额，这个问题我不太理解。。。\n\nA：没事，换一个问题。Go 语言中的 Map 是如何实现的，你能聊一聊吗？\n\nB：Map 是使用哈希表、链表来实现的。然后我从散列函数、解决哈希冲突、动态扩容、并发安全性聊\n\nA：Go 的并发模式你了解吗？\n\nB：请问是指的扇入扇出模式、for select 循环模式这种吗？（后来回忆一下，面试官想让我聊的应该是CSP并发模型）\n\nA：不是，你可以说一说你了解的 Go 的并发原语\n\nB：好的，我从两个部分简单说一下，一个就是关键字，另一个是包。像关键字有 go，创建协程。channel，进行通信。select，处理 channel 的收发。mutex，锁。context，上下文。包的话 atomic。\n\nA：你知道 csp 吗，能简单说一下嘛？\n\nB：（我脑子里第一时间和 cap 搞混了，但还是拉回来了）csp 是一种通信协作模型。在 Go 里面有一句很经典的话，**不要用共享内存来通信，要用通信来共享内存。**\n\nA：（**露出了满意的笑容，扭头看向旁边的同事**）我没什么问的了，你有什么问的吗？\n\nB：你之前用过 mongodb，存储在 mongodb 中的索引你是怎么设计的？\n\nA：不好意思，我之前没有关注过这个部分，因为之前的整体架构都是将需要落盘的数据放在内存，然后标记脏位，通过一些策略来异步落盘，而需要查询数据时，也是直接从内存查询，因为项目启动时，会把所有的玩家数据加载到内存中。\n\nB：没事，那我们聊一下 redis 吧，你知道 redis 的落盘方案吗？\n\nA：知道，AOF、RDB（然后开始介绍它们的特点）巴拉巴拉\n\nB：你会如何评估 redis 的落盘方案？\n\nA：我会从数据安全性、可恢复性、性能、硬盘空间成本、使用场景来评估。\n\nB：硬盘空间成本？你能具体说说吗？\n\nA：AOF占用空间大等....巴拉巴拉。\n\nB：redis 的 Key 过长会影响性能吗？\n\nA：额，我觉得应该会影响性能，因为你问了这个问题，但是这个我没太关注过，对于 Key 我更在意的是可读性。\n\n最后聊了一些 Redis 的数据结构，又继续聊了一下一些特定二叉树的概念，还问了我对于矩阵、向量的理解，我就围绕以前做过的天赋系统聊了一下矩阵。\n\n## 复盘！复盘！\n\n为了对大家更有帮助，我把面试中回答的关键问题，做了复盘和调研，总结如下：\n\n### Actor模型\n\nActor模型是一种并发计算模型，用于描述并发系统中的实体和它们之间的通信。在Actor模型中，系统中的每个实体被称为一个Actor，每个Actor都有自己的状态和行为，并且可以通过消息传递与其他Actor进行通信。\n\n在Actor模型中，每个Actor都是独立的，它们之间没有共享的内存。Actor之间通过异步消息传递进行通信，一个Actor可以向其他Actor发送消息，也可以接收其他Actor发送的消息。当一个Actor接收到消息时，它可以根据消息内容和自身的状态来决定如何处理消息，并可能改变自身的状态或向其他Actor发送消息。\n\n**Actor模型的特点包括：**\n\n**1\\. 并发性：** 每个Actor都可以独立地执行，不受其他Actor的影响，从而实现并发执行。\n\n**2\\. 无共享状态：** 每个Actor都有自己的状态，不与其他Actor共享内存，避免了共享状态带来的并发问题。\n\n**3\\. 异步消息传递：** Actor之间通过异步消息传递进行通信，消息的发送和接收是非阻塞的，提高了系统的响应性能。\n\n**4\\. 面向对象：** 每个Actor都可以看作是一个对象，具有自己的状态和行为，可以封装数据和方法。\n\n**总结一下：通过使用Actor模型，可以简化并发系统的设计和实现，提高系统的可扩展性和可维护性。同时，Actor模型也能够有效地处理并发问题，避免了传统并发编程中常见的共享状态和锁竞争的问题。**\n\n### 对比Go的GMP模型和Actor模型\n\nGo的GMP（Goroutine, M, P）模型和Actor模型都是用于并发编程的模型，但在一些方面有所不同。\n\nGo的GMP模型是Go语言并发编程的基础，它通过goroutine（轻量级线程）和调度器（scheduler）来实现并发。GMP模型中的goroutine是Go语言中的并发执行单元，它可以独立地执行函数或方法。调度器负责将goroutine分配给线程（P），以便并行执行。线程（P）是操作系统线程的抽象，它负责执行goroutine。M（Machine）是Go语言运行时系统的一部分，它管理线程的创建和销毁，并提供与操作系统的交互。GMP模型的优点是轻量级的goroutine和高效的调度器，使得并发编程变得简单且高效。\n\nActor模型是一种并发编程模型，它通过将并发执行的单元（称为actor）之间的通信和状态封装在一起来实现并发。在Actor模型中，每个actor都是独立的实体，它们通过消息传递进行通信。每个actor都有自己的状态和行为，并且只能通过接收和发送消息来与其他actor进行通信。**Actor模型的优点是提供了一种结构化的方式来处理并发，避免了共享状态和锁的问题。**\n\n虽然GMP模型和Actor模型都是用于并发编程，但它们在实现方式和语义上有所不同。**GMP模型更加底层，直接操作线程和goroutine，适用于需要更细粒度控制的场景。而Actor模型更加高级，通过消息传递来实现并发，适用于需要更结构化和可扩展的场景。**\n\n总结起来，GMP模型适用于Go语言中的并发编程，提供了轻量级的goroutine和高效的调度器；**而Actor模型适用于一般的并发编程，通过消息传递来实现并发。**\n\n### epoll模型\n\nepoll是一种在Linux系统中用于高效处理大量并发连接的I/O事件通知机制。它具有以下特点：\n\n1.  支持高并发：epoll使用事件驱动的方式，能够同时处理大量的并发连接，适用于高并发的网络应用场景。\n    \n2.  高效的事件通知机制：epoll采用了基于事件驱动的方式，当有事件发生时，内核会将事件通知给应用程序，而不需要应用程序轮询检查事件是否发生，从而减少了系统资源的消耗。\n    \n3.  支持边缘触发和水平触发：epoll提供了两种工作模式，边缘触发（EPOLLET）和水平触发（EPOLLIN/EPOLLOUT）。边缘触发模式只在状态发生变化时通知应用程序，而水平触发模式则在状态可读或可写时都会通知应用程序。\n    \n4.  支持多种I/O事件类型：epoll可以同时监控多种I/O事件类型，包括读事件、写事件、错误事件等。\n    \n5.  高效的内核数据结构：epoll使用红黑树和双向链表等高效的数据结构来管理大量的文件描述符，提高了事件的处理效率。\n    \n\n总之，epoll模型具有高并发、高效的事件通知机制和多种I/O事件类型的支持，适用于处理大量并发连接的网络应用场景。\n\n### etcd保证数据一致性\n\n**etcd通过使用Raft一致性算法来保证数据的一致性。** Raft是一种分布式一致性算法，它将集群中的节点分为Leader、Follower和Candidate三种角色，通过选举机制选出Leader节点来处理客户端的请求。\n\n当客户端向etcd发送写请求时，Leader节点会将该请求复制到其他节点的日志中，并等待大多数节点确认接收到该日志条目。一旦大多数节点确认接收到该日志条目，Leader节点会将该请求应用到自己的状态机中，并将结果返回给客户端。同时，Leader节点会通知其他节点将该请求应用到自己的状态机中。\n\n如果Leader节点失去连接或崩溃，剩余的节点会通过选举机制选出新的Leader节点。新的Leader节点会根据自己的日志和其他节点的日志进行比较，保证自己的日志是最新的，并将缺失的日志条目复制给其他节点，以保持数据的一致性。\n\n通过Raft算法，etcd能够保证数据在集群中的一致性，并且在Leader节点失效时能够快速选举出新的Leader节点，保证系统的可用性和数据的一致性。\n\n### redis的落盘方案\n\nRedis的落盘方案主要有两种：RDB（Redis Database）和AOF（Append Only File）。\n\n1.  RDB（Redis Database）：RDB是Redis默认的持久化方式。它通过将Redis的内存数据快照保存到磁盘上的二进制文件中来实现持久化。RDB的优点是快速和紧凑，适合用于备份和恢复数据。RDB的缺点是在发生故障时可能会丢失一部分数据，因为RDB是定期进行持久化的，而不是实时的。\n    \n2.  AOF（Append Only File）：AOF是另一种持久化方式，它通过将Redis的写操作追加到文件末尾来记录数据的变化。AOF的优点是可以提供更好的数据安全性，因为它记录了每个写操作，可以在发生故障时进行恢复。AOF的缺点是相对于RDB来说，文件体积较大，恢复数据的速度较慢。\n    \n\n在实际应用中，可以根据需求选择适合的落盘方案。**如果对数据的安全性要求较高，可以选择AOF方式；如果对数据的实时性要求较高，可以选择RDB方式。另外，也可以同时使用RDB和AOF两种方式，以提供更好的数据保护和恢复能力。**\n\n## 更多面经\n\n下面的面经同样精彩，希望对大家找工作有帮助：\n\n[一天约了4个面试，复盘一下面试经历和薪资范围](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNjM0MzQyNg%3D%3D%26mid%3D2247487849%26idx%3D1%26sn%3De085f50c6bb9683325bd06a294e941bc%26chksm%3De870be04df073712212f2abae8638458dd16197261cc9f76c02c0b601600ab1b75e731599b1a%26token%3D389589284%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=MzIyNjM0MzQyNg==&mid=2247487849&idx=1&sn=e085f50c6bb9683325bd06a294e941bc&chksm=e870be04df073712212f2abae8638458dd16197261cc9f76c02c0b601600ab1b75e731599b1a&token=389589284&lang=zh_CN#rd\")\n\n[避免失业和35岁危机，把这份百度3面的面经分享出来](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNjM0MzQyNg%3D%3D%26mid%3D2247489015%26idx%3D1%26sn%3D49db491cf781b14c7f9a72ded23ceb4c%26chksm%3De870ba9adf07338ca80419fed08fc2a3ffdb2cd6d31a58f5b0e700169adbf83220a21c060d01%26token%3D389589284%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=MzIyNjM0MzQyNg==&mid=2247489015&idx=1&sn=49db491cf781b14c7f9a72ded23ceb4c&chksm=e870ba9adf07338ca80419fed08fc2a3ffdb2cd6d31a58f5b0e700169adbf83220a21c060d01&token=389589284&lang=zh_CN#rd\")\n\n[2023最新社招面经分享：字节 米哈游 富途 猿辅导](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNjM0MzQyNg%3D%3D%26mid%3D2247487871%26idx%3D1%26sn%3D5be3189c6fe6c293bc8d49251599f992%26chksm%3De870be12df07370464efb0502d9935cfdd0810d6ce0b369562064f7a433210953cbaa1afbfff%26token%3D389589284%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=MzIyNjM0MzQyNg==&mid=2247487871&idx=1&sn=5be3189c6fe6c293bc8d49251599f992&chksm=e870be12df07370464efb0502d9935cfdd0810d6ce0b369562064f7a433210953cbaa1afbfff&token=389589284&lang=zh_CN#rd\")\n\n## 联系我\n\n欢迎和我一起讨论交流：[可以在掘金私信我](https://juejin.cn/notification/im?participantId=2189882892232029 \"https://juejin.cn/notification/im?participantId=2189882892232029\")\n\n也欢迎关注我的公众号： [程序员升职加薪之旅](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNjM0MzQyNg%3D%3D%26mid%3D2247486565%26idx%3D2%26sn%3D76e0d850c0a7d2cfe398ca2c1391c4d9%26chksm%3De870a308df072a1e73c42f4cdb99a636614ad8eff839168fb1bc3241156899e2a9420ed4cea9%26scene%3D21%23wechat_redirect \"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNjM0MzQyNg%3D%3D%26mid%3D2247486565%26idx%3D2%26sn%3D76e0d850c0a7d2cfe398ca2c1391c4d9%26chksm%3De870a308df072a1e73c42f4cdb99a636614ad8eff839168fb1bc3241156899e2a9420ed4cea9%26scene%3D21%23wechat_redirect\")\n\n微信号：wangzhongyang1993\n\n也欢迎大家**关注我的掘金**，点赞、留言、转发。**你的支持，是我更文的最大动力！**', 'public/uploads/1694354952465.png', 3, 6, 1, 1039, '2023-09-10 14:09:19', 1);
INSERT INTO `article` VALUES (94, 4, 'TypeScript从0到1的学习之路（都这个年头了，你确定不学习ts卷一下吗？）8500字分享', '我正在参加「掘金·启航计划」\n\n> 今天是2022年9月19日，也是我开始计划写这篇文章的日子。为什么要写这篇文章呢，其实在我去年下半年的时候，专门学过ts，但是实际工作中，用ts的地方其实用的很浅。平常工作也就定义个types啊，或者枚举enum啊。什么泛型之类的，工作中从来没有用过。以至于当我在看别人的工具包的时候，人家定义的函数参数类型，我有一些看不明白，所以才专门重新学了一遍ts，并且写一篇博客记录一下，这样当我往后忘记的时候，就只需要再看一遍自己的博客就好了。我也推荐大家用写博客的方式，来记录自己的学习之路。看 -> 做 -> 教 -> 是学习的三大阶段，你只看别人怎么写，基本是学不会的。如果边看，边做。可能当时记住了，但过段时间不用你也会忘，只有当你学会了，并且教会别人，时常巩固，才能收益最大化。\n\n## TypeScript是什么\n\nTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n\n> 简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。\n\n## TypeScript的优缺点\n\n刚接触TypeScript的小伙伴可能会有点疑惑，为什么要使用typescript，我直接用js不香吗。其实我刚开始接触typescript也是这么想的。明明用js，半天就能搞定的事，用了ts，工作量反而要翻一倍甚至不止。如果你要写出漂亮的ts代码，人力成本肯定要大大增加的，这也是一些小型创业公司不用ts的原因，烧钱啊。但是，不知道大家有没有碰到过，一个用了ts的项目，和没用ts的项目，当你有一天去维护它的时候，用ts的项目维护起来简直如鱼得水，也不会犯因为类型错误而报的错，而反观没用ts的，你去用一些函数的时候，都不知道它接受几个参数，也不知道传什么类型。所以，学习ts是非常有必要的（ps：主要是不学ts，以后容易被淘汰啊，我也不想学啊）\n\n### 优点\n\n-   增强代码的可维护性，尤其在大型项目的时候效果显著\n-   友好地在编辑器里提示错误，编译阶段就能检查类型发现大部分错误\n-   支持最新的JavaScript新特特性\n-   周边生态繁荣，vue3已全面支持 typescript\n\n### 缺点\n\n-   需要一定的学习成本\n-   和一些插件库的兼容并不是特别完美，如以前在 vue2 项目里使用 typescript就并不是那么顺畅\n-   增加前期开发的成本（但是便于后期的维护）\n\n## TypeScript起步使用\n\n## 安装TypeScript\n\n有两种主要的方式来获取TypeScript工具：\n\n-   通过npm（Node.js包管理器）\n-   安装Visual Studio的TypeScript插件\n\nVisual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以[下载](https://link.juejin.cn/?target=https%3A%2F%2Fwww.tslang.cn%2F%23download-links \"https://www.tslang.cn/#download-links\")它。\n\n针对使用npm的用户：\n\n```\n> npm install -g typescript\n```\n\n## 构建你的第一个TypeScript文件\n\n在编辑器，将下面的代码输入到`greeter.ts`文件里：\n\n```\nfunction greeter(person) {\n    return \"Hello, \" + person;\n}\n\nlet user = \"Jane User\";\n\ndocument.body.innerHTML = greeter(user);\n```\n\n## 编译代码\n\n我们使用了`.ts`扩展名，但是这段代码仅仅是JavaScript而已。 你可以直接从现有的JavaScript应用里复制/粘贴这段代码。\n\n在命令行上，运行TypeScript编译器：\n\n```\ntsc greeter.ts\n```\n\n输出结果为一个`greeter.js`文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了！\n\n## 安装ts-node\n\n当然，如果只用tsc这个命令，每次都会生成一个新的js文件，很麻烦。所以我们来安装ts-node。这样每次运行都只需要运行一次命令就好 安装\n\n```\nnpm i ts-node -g\n```\n\n运行\n\n```\nts-node 文件名\n```\n\n有了ts-node，我们就能很方便的调试ts文件。一切准备就绪，让我们开始学习吧\n\n## TypeScript的基础类型\n\n## string\n\nJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string`表示文本数据类型。 和JavaScript一样，可以使用双引号（ `\"`）或单引号（`\'`）表示字符串。\n\n如果给的类型不对，会直接报错，代码编辑器会显示出来。例如（后面我不会贴图了，知道编辑器会报错就行）\n\n```\nconst str: string = 1234; // false 定义str为string类型 如果给别的类型会直接报错\nlet str1: string = \'1234\'; // true\nstr1 = \'2345\'; // true\nstr1 = 1234; // false\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7906187414d140a1bfe91bfab588a120~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## number\n\n和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 `number`。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\n\n```\nconst num: number = \'1234\'; // false 不能将string分配给number\nlet num1: number = 1234; // true\nnum1 = \'2345\'; // false 不能将string分配给number\nnum1 = 1234; // true\n```\n\n## boolean\n\n最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做`boolean`（其它语言中也一样）。\n\n```\nconst boo: boolean = \'1234\'; // false 不能将string分配给boolean\nlet boo1: boolean = true; // true\nboo1 = \'1234\'; // false 不能将string分配给boolean\nboo1 = false; // true\n```\n\n## enum\n\n`enum`类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green; // 1\n```\n\n默认情况下，从`0`开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1`开始编号，如果后面成员没设置编号，自动从你上一个设置的编号开始排序：\n\n```\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green; // 2\n```\n\n或者，全部都采用手动赋值：\n\n```\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green; // 2\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\n\n```\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示\'Green\'因为上面代码里它的值是2\n```\n\n## array\n\nTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```\nlet list1: number[] = [1, 2, 3];\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```\nlet list2: Array<number> = [1, 2, 3];\n```\n\n## tuple元祖\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。听上去可能高大尚，其他它只是在数组类型上，知道了一个数字的长度，所以给数组的每个元素都定义类型。 比如，你可以定义一对值分别为 `string`和`number`类型的元组。\n\n```\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\'hello\', 10]; // OK\n// Initialize it incorrectly\nx = [10, \'hello\']; // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, \'number\' does not have \'substr\'\n```\n\n当访问一个越界的元素，会报错：\n\n```\nx[3] = \'world\';  //false 不能将“world”分配给undefined\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。我们不知道怎么定义类型合适的时候，可以先写一个any，代表任意类型\n\n```\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\n\n在对现有代码进行改写的时候，`any`类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 `Object`有相似的作用，就像它在其它语言中那样。 但是 `Object`类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\n\n```\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn\'t check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property \'toFixed\' doesn\'t exist on type \'Object\'.\n```\n\n当你只知道一部分数据的类型时，`any`类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```\nlet list: any[] = [1, true, \"free\"];\n\nlist[1] = 100;\n```\n\n（any虽然可以阻止报错，但在我们知道类型的时候，一定要及时改过来，虽然any大法确实香，哈哈哈哈）\n\n## void\n\n在 TS 中，void 和 undefined 功能高度类似，可以在逻辑上避免不小心使用了空指针导致的错误。\n\n```\nfunction foo() {}  // 这个空函数没有返回任何值，返回类型缺省为void\nconst a = foo();// 此时a的类型定义为void，你也不能调用a的任何属性方法\n```\n\nvoid 和 undefined 类型最大的区别是，你可以理解为 undefined 是 void 的一个子集，当你对函数返回值并不在意时，使用 void 而不是 undefined。举一个 React 中的实际的例子。\n\n```\n// Parent.tsx\nfunction Parent(): JSX.Element {\n  const getValue = (): number => { return 2 };   /* 这里函数返回的是number类型 */\n  // const getValue = (): string => { return \'str\' };/* 这里函数返回的string类型，同样可以传给子属性 */\n  return <Child getValue={getValue} />\n}\n```\n\n```\n// Child.tsx\ntype Props = {\n  getValue: () => void;  // 这里的void表示逻辑上不关注具体的返回值类型，number、string、undefined等都可以\n}\nfunction Child({ getValue }: Props) => <div>{getValue()}</div>\n```\n\n## Null 和 Undefined\n\nTypeScript里，`undefined`和`null`两者各自有自己的类型分别叫做`undefined`和`null`。 和 `void`相似，它们的本身的类型用处不是很大：\n\n```\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n默认情况下`null`和`undefined`是所有类型的子类型。 就是说你可以把 `null`和`undefined`赋值给`number`类型的变量。\n\n然而，当你指定了`--strictNullChecks`标记，`null`和`undefined`只能赋值给`void`和它们各自。 这能避免 很多常见的问题。\n\n**但是 undefined 可以给 void 赋值**\n\n```\nlet c:void = undefined // 编译正确\nlet d:void = null // 编译错误\n```\n\n## never\n\n是指没法正常结束返回的类型，一个必定会报错或者死循环的函数会返回这样的类型。\n\n```\nfunction foo(): never { throw new Error(\'error message\') }  // throw error 返回值是never\nfunction foo(): never { while(true){} }  // 这个死循环的也会无法正常退出\n```\n\n还有就是永远没有相交的类型：\n\n```\ntype human = \'boy\' & \'girl\' // 这两个单独的字符串类型并不可能相交，故human为never类型\n```\n\n不过任何类型联合上 never 类型，还是原来的类型：\n\n```\ntype language = \'ts\' | never   // language的类型还是\'ts\'类型\n```\n\n关于 never 有如下特性：\n\n-   在一个函数中调用了返回 never 的函数后，之后的代码都会变成`deadcode`\n\n```\nfunction test() {\n  foo();  // 这里的foo指上面返回never的函数\n  console.log(111); // Error: 编译器报错，此行代码永远不会执行到\n}\n```\n\n-   无法把其他类型赋给 never：\n\n```\nlet n: never;\nlet o: any = {};\nn = o;  // Error: 不能把一个非never类型赋值给never类型，包括any\n```\n\n关于never类型，其实有很多人会疑惑，never类型表示一个没有可能的值，既然没有可能，那么为什么会有这么一个类型。在知乎上，有尤大大这么一串回答，其实挺有意思的，下面是尤大大原话。\n\n举个具体点的例子，当你有一个 union type:\n\n```\ninterface Foo {\n  type: \'foo\'\n}\n\ninterface Bar {\n  type: \'bar\'\n}\n\ntype All = Foo | Bar\n```\n\n在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：\n\n```\nfunction handleValue(val: All) {\n  switch (val.type) {\n    case \'foo\':\n      // 这里 val 被收窄为 Foo\n      break\n    case \'bar\':\n      // val 在这里是 Bar\n      break\n    default:\n      // val 在这里是 never\n      const exhaustiveCheck: never = val\n      break\n  }\n}\n```\n\n注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：\n\n```\ntype All = Foo | Bar | Baz\n```\n\n然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e77a9a4e609e45b7b94eed3abe049965~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。\n\n## unkonwn\n\nunknown 指的是**不可预先定义的类型**，在很多场景下，它可以替代 any 的功能同时保留静态检查的能力。\n\n```\nconst num: number = 10;\n(num as unknown as string).split(\'\');  // 注意，这里和any一样完全可以通过静态检查\n```\n\n这个时候 unknown 的作用就跟 any 高度类似了，你可以把它转化成任何类型，不同的地方是，在静态编译的时候，unknown 不能调用任何方法，而 any 可以。\n\n```\nconst foo: unknown = \'string\';\nfoo.substr(1);   // Error: 静态检查不通过报错\nconst bar: any = 10;\nany.substr(1);// Pass: any类型相当于放弃了静态检查\n```\n\nunknown 的一个使用场景是，避免使用 any 作为函数的参数类型而导致的静态类型检查 bug：\n\n```\nfunction test(input: unknown): number {\n  if (Array.isArray(input)) {\n    return input.length;    // Pass: 这个代码块中，类型守卫已经将input识别为array类型\n  }\n  return input.length;      // Error: 这里的input还是unknown类型，静态检查报错。如果入参是any，则会放弃检查直接成功，带来报错风险\n}\n```\n\n## 类型别名\n\n像我们上面定义的类型，其实他们只能被使用一次，如何能够多次使用达到复用，这就需要用到别名关键字去定义类型了\n\n## type\n\n使用type去定义类型 可以多次复用，例如定义一个string类型的变量\n\n```\ntype Str = number;\nconst str: Str = \'1234\' // 不能将类型分配给number\n```\n\n定义类型名的时候，一般采用大驼峰写法，能很好的区分变量名和类型名\n\n```\ntype Obj = {\n  a: boolean,\n  b: number\n};\nconst obj: Obj = {\n  a: true,\n  b: 1\n} // true\n```\n\n## interface\n\ninterface接口是专门给对象定义类型\n\n```\ninterface Obj {\n  a: true,\n  b: boolean\n}\nconst obj: Obj = {\n  a: true,\n  b: false\n} // true\n```\n\ninterface比type具有专门的针对性，扩展了extends继承关键字，可以继承类型，例如\n\n```\ninterface Obj {\n  a: true,\n  b: boolean\n}\n\ninterface Obj1 extends Obj {\n  c: string,\n  d: \'我是小明\'\n}\n\nconst obj: Obj1 = {\n  a: true,\n  b: false,\n  c: \'sss\',\n  d: \'我是小明\'\n} // true\n```\n\n除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n}\n```\n\n## enum\n\n其实枚举类型也可以服用，也相当于取了别名，但是在上面基础类型讲了，就不再叙述了\n\n## 对象类型\n\n## object, Object 和 {} 类型\n\n-   object object 类型用于表示所有的非原始类型，即我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined 类型也不能赋给 object。\n\n```\nlet object: object;\nobject = 1; // 报错\nobject = \"a\"; // 报错\nobject = true; // 报错\nobject = null; // 报错\nobject = undefined; // 报错\nobject = {}; // 编译正确\n复制代码\n```\n\n-   Object\n\n大 Object 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 null 和 undefined 不可以)\n\n```\nlet bigObject: Object;\nobject = 1; // 编译正确\nobject = \"a\"; // 编译正确\nobject = true; // 编译正确\nobject = null; // 报错\nObjectCase = undefined; // 报错\nObjectCase = {}; // ok\n复制代码\n```\n\n-   {}\n\n{} 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合\n\n## class类\n\n```\nclass Person {\n  name: string;\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n  say(): void {\n    alert(\'nihao\' + this.name)\n  }\n}\n```\n\n同样 也可以使用extends关键字实现继承\n\n```\nclass Person {\n  name: string;\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n  say(): void {\n    console.log(\'nihao\' + this.name)\n  }\n}\n\nclass Student extends Person {\n  school: string;\n  constructor(name: string, age: number, school: string) {\n    super(name, age);\n    this.school = school\n  }\n  say1(): void {\n    alert(\'nihao\')\n  }\n}\nconst student = new Student(\'xiaoming\', 18, \'大河小学\') // {name: \'xiaoming\', age: 18, school: \'大河小学\'}\nstudent.say()\n```\n\n## function函数\n\n函数类型定义有两种方式，一种是函数表达式的，还有一种是函数声明的\n\n### 函数声明\n\n```\nfunction fn(x: number, y: number): number {\n  return x + y\n}\n```\n\n### 函数表达式\n\n```\n// 函数表达式\nconst fnn = (x: string, y: string): string => {\n  return x + y\n}\n```\n\n### 函数参数可选\n\n函数其实比较特殊，因为有一些参数，你可以传，也可以不传，那么如何去判断呢。就会用到我们的可选参数，这里有一个注意点，就是可选参数必须放到后面。这点应该不难理解：\n\n```\n// 可选参数\nfunction fn1(x?: number, y?: number): number {\n  return x + y\n} // true\n\nfunction fn2(x?: number, y: number): number {\n  return x + y\n} // false 必须参数不能位于可选参数后\n```\n\n### 重载\n\nJavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。如果一个函数，我们想传入string，有的时候又传入number，那该怎么定义呢，我们就可以定义多个函数类型。\n\n```\nfunction add(x: number, y: number): number;\nfunction add(x: string, y: string): string;\nfunction add(x, y) {\n  return x + y;\n}\nconst res = add(\"1\", \"2\") // res1类型为string\nconst res1 = add(1, 2) // res1类型为number\nconst res2 = add(\'1\', 2) // false 没有与此调用匹配的重载\n```\n\n注意 上面定义的三个add 其中两个都是函数类型，并不是函数声明，最终执行的是最下面这个函数声明。函数声明只能有一个，然而函数类型可以多个同名\n\n为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n### 索引类型\n\nTypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 `number`来索引时，JavaScript会将它转换成`string`然后再去索引对象。 也就是说用 `100`（一个`number`）去索引等同于使用`\"100\"`（一个`string`）去索引，因此两者需要保持一致。\n\n```\nclass Animal {\n    name: string;\n}\nclass Dog extends Animal {\n    breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n    [x: number]: Animal;\n    [x: string]: Dog;\n}\n```\n\n字符串索引签名能够很好的描述`dictionary`模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 `obj.property`和`obj[\"property\"]`两种形式都可以。 下面的例子里， `name`的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n```\n\n你不能设置`myArray[2]`，因为索引签名是只读的。\n\n## 类型推论\n\n## 基础\n\nTypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子\n\n```\nlet x = 3; // x的类型会自动被推论为number\n```\n\n变量`x`的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。\n\n```\nlet x = [0, 1, null]; // x的类型为 number[]\nx = [undefined] // true\n```\n\n为了推断`x`的类型，我们必须考虑所有元素的类型。 这里有两种选择： `number`和`null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n## 交叉类型\n\n交叉类型其实与js中的&&很相似，代表都有，符号用&表示，表示两个类型必须都存在\n\n```\ntype Person = {\n  name: string,\n  age: number\n}\ntype Stu = {\n  scroll: string\n}\ntype Student = Person & Stu\nconst student: Student = {\n  name: \'123\',\n  age: 16,\n  scroll: \'大河\'\n}\n```\n\n一般都是对象类型的才有交叉类型，像字面量类型的联合，就直接变成never类型了，因为不可能存在\n\n```\ntype A = \'boy\' & \'girl\' // A的类型为never\n```\n\n## 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number`或 `string`类型的参数。 例如下面的函数：\n\n```\nconst fns = (x:string | number) => {\n  return x\n}\n```\n\n联合类型符号用｜表示，代表或的意思。属性多，至少满足其中一种类型就成，像下面例子也是可以通过ts编译的\n\n```\ntype Obj1 = {\n  a: string,\n  b: number\n}\n\ntype Obj2 = {\n  c: string,\n  d: number\n}\nconst obj: Obj1 | Obj2 = {\n  a: \'123\',\n  b: 456,\n  c: \'124\'\n} // true 虽然多了个c属性，但是该类型满足了Obj1类型，同时c属性也在Obj2的类型里面，所以能通过编译\n```\n\n## 类型断言\n\n某些情况下，我们可能比typescript更加清楚的知道某个变量的类型，所以我们可能希望手动指定一个值的类型\n\n类型断言有两种方式\n\n-   尖括号写法\n\n```\nlet str: any = \"to be or not to be\";\nlet strLength: number = (<string>str).length;\n复制代码\n```\n\n-   as 写法\n\n```\nlet str: any = \"to be or not to be\";\nlet strLength: number = (str as string).length;\n```\n\n## 非空断言\n\n这个运算符可以用在变量名或者函数名之后，用来强调对应的元素是非 null|undefined 的\n\n```\nfunction onClick(callback?: () => void) {\n  callback!();// 参数是可选入参，加了这个感叹号!之后，TS编译不报错\n}\n```\n\n## ts操作符\n\n## 键值获取keyof\n\nkeyof 可以获取一个类型所有键值，返回一个联合类型，如下：\n\n```\ntype Person = {\n  name: string;\n  age: number;\n}\ntype PersonKey = keyof Person;  // PersonKey得到的类型为 \'name\' | \'age\n```\n\nkeyof 的一个典型用途是限制访问对象的 key 合法化，因为 any 做索引是不被接受的。keyof 经常搭配in来使用，后面会讲\n\n```\nfunction getValue (p: Person, k: keyof Person) {\n  return p[k];  // 如果k不如此定义，则无法以p[k]的代码格式通过编译\n}\n```\n\n总结起来 keyof 的语法格式如下\n\n```\n类型 = keyof 类型\n```\n\n## 实例类型获取typeof\n\n我们可以根据已有的数据，通过typeof，去获取它的类型\n\n```\nconst person = {\n name: \'xiaomign\',\n age: 15\n}\ntype Person = typeof person // Person类型为{name: string; age: number}\n```\n\ntypeof还可以搭配keyof使用，例如\n\n```\nconst person = {\n  name: \'xiaomign\',\n  age: 15\n}\ntype Person = typeof person // Person类型为{name: string; age: number}\ntype Personkey = keyof typeof person // Person类型为 \'name\' | \'age\'\n```\n\ntypeof语法格式为\n\n```\n类型 = typeof 实例\n```\n\n## 遍历属性 in\n\nin 只能用在类型的定义中，可以对枚举类型进行遍历，如下：\n\n```\n// 这个类型可以将任何类型的键值转化成number类型\ntype TypeToNumber<T> = {\n  [key in keyof T]: number\n}\n```\n\n`keyof`返回泛型 T 的所有键枚举类型，`key`是自定义的任何变量名，中间用`in`链接，外围用`[]`包裹起来(这个是固定搭配)，冒号右侧`number`将所有的`key`定义为`number`类型。\n\n于是可以这样使用了：\n\n```\nconst obj: TypeToNumber<Person> = { name: 10, age: 10 }\n```\n\n总结起来 in 的语法格式如下：\n\n```\n[ 自定义变量名 in 枚举类型 ]: 类型\n```\n\n## 泛型\n\n泛型在ts中，是最难学，也是最重要的一部分，如果说学了上面相当于会蹬自行车，那么学好泛型，相当于能开飞机了。重要性不言而喻。泛型的意义在于能使我们类型更加灵活，举个例子，一个函数传入一个参数，那个参数如果传的是string 那么返回个string出来，如果传number，则返回number。这个时候你该如何去定义这个类型。所以泛型就由此诞生了\n\n## 基本使用\n\n下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 `echo`命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```\nfunction identity(arg: number): number {\n    return arg;\n}\n```\n\n或者，我们使用`any`类型来定义函数：\n\n```\nfunction identity(arg: any): any {\n    return arg;\n}\n```\n\n使用`any`类型会导致这个函数可以接收任何类型的`arg`参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 _类型变量_，它是一种特殊的变量，只用于表示类型而不是值。\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n## 泛型推导与默认值\n\n上面提到了，我们可以简化对泛型类型定义的书写，因为TS会自动根据变量定义时的类型推导出变量类型，这一般是发生在函数调用的场合的。\n\n```\ntype Dog<T> = { name: string, type: T }\n\nfunction adopt<T>(dog: Dog<T>) { return dog };\n\nconst dog = { name: \'ww\', type: \'hsq\' };  // 这里按照Dog类型的定义一个type为string的对象\nadopt(dog);  // Pass: 函数会根据入参类型推断出type为string\n复制代码\n```\n\n若不适用函数泛型推导，我们若需要定义变量类型则必须指定泛型类型。\n\n```\nconst dog: Dog<string> = { name: \'ww\', type: \'hsq\' }  // 不可省略<string>这部分\n```\n\n如果我们想不指定，可以使用泛型默认值的方案。\n\n```\ntype Dog<T = any> = { name: string, type: T }\nconst dog: Dog = { name: \'ww\', type: \'hsq\' }\ndog.type = 123;    // 不过这样type类型就是any了，无法自动推导出来，失去了泛型的意义\n```\n\n泛型默认值的语法格式简单总结如下：\n\n```\n泛型名 = 默认类型\n```\n\n## 泛型类型\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <U>(arg: U) => U = identity;\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity;\n```\n\n这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```\ninterface GenericIdentityFn {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\n## 泛型约束\n\n有的时候，我们想要约束泛型，如何能办到这事，就需要extends关键字。这里的extends并不代表继承，在这里反而是约束了泛型的类型\n\n你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 `loggingIdentity`例子中，我们想访问`arg`的`length`属性，但是编译器并不能证明每种类型都有`length`属性，所以就报错了。\n\n```\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn\'t have .length\n    return arg;\n}\n```\n\n相比于操作any所有类型，我们想要限制函数去处理任意带有`.length`属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。\n\n为此，我们定义一个接口来描述约束条件。 创建一个包含 `.length`属性的接口，使用这个接口和`extends`关键字来实现约束：\n\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);  // Now we know it has a .length property, so no more error\n    return arg;\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```\nloggingIdentity(3);  // Error, number doesn\'t have a .length property\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```\nloggingIdentity({length: 10, value: 3});\n```\n\n## 泛型条件\n\n上面提到 extends，其实也可以当做一个三元运算符，如下：\n\n```\nT extends U? X: Y\n```\n\n这里便不限制 T 一定要是 U 的子类型，如果是 U 子类型，则将 T 定义为 X 类型，否则定义为 Y 类型。\n\n这块要搭配下面泛型推断一起来学\n\n## 泛型推断 infer\n\ninfer 的中文是“推断”的意思，一般是搭配上面的泛型条件语句使用的，所谓推断，就是你不用预先指定在泛型列表中，在运行时会自动判断，不过你得先预定义好整体的结构。举个例子\n\n```\ntype Foo<T> = T extends {t: infer Test} ? Test: string\n```\n\n首选看 extends 后面的内容，`{t: infer Test}`可以看成是一个包含`t属性`的**类型定义**，这个`t属性`的 value 类型通过`infer`进行推断后会赋值给`Test`类型，如果泛型实际参数符合`{t: infer Test}`的定义那么返回的就是`Test`类型，否则默认给缺省的`string`类型。\n\n举个例子加深下理解：\n\n```\ntype One = Foo<number>  // string，因为number不是一个包含t的对象类型\ntype Two = Foo<{t: boolean}>  // boolean，因为泛型参数匹配上了，使用了infer对应的type\ntype Three = Foo<{a: number, t: () => void}> // () => void，泛型定义是参数的子集，同样适配\n```\n\n`infer`用来对满足的泛型类型进行子类型的抽取，有很多高级的泛型工具也巧妙的使用了这个方法。\n\n## 泛型工具\n\n泛型工具有很多，例如将类型全部变为只读，以及类型全部变为可选\n\n## 1\\. Required\n\n将类型的属性变成必选\n\n```\ninterface Person {\n  name?: string,\n  age?: number,\n  hobby?: string[]\n}\ntype Required<T> = {\n  [Key in keyof T]-?: T[Key]\n}\n\nconst user: Required<Person> = {\n  name: \"树哥\",\n  age: 18,\n  hobby: [\"code\"]\n}\n```\n\n在这里 -？是一个非常有意思的写法，相当于把可选去掉\n\n## 2\\. Partial\n\n与 Required 相反，将所有属性转换为可选属性\n\n```\ninterface Person {\n  name: string,\n  age: number,\n  hobby: string[]\n}\ntype Partial<T> = {\n  [K in keyof T]?: T[K]\n}\n\nconst user: Partial<Person> = {\n  name: \"树哥\",\n  age: 18,\n} // 编译正确\n```\n\n## 3\\. Exclude\n\n`Exclude<T, U>` 的作用是将某个类型中属于另一个的类型移除掉,剩余的属性构成新的类型\n\n此工具是在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分。这里使用never，是因为任何属性和never联合 都是自身\n\n```\ntype Excluede<T, U> = T extends U ? never : T\n\nconst user: Excluede<\'a\' | \'b\' | \'c\', \'a\' | \'b\'> = \'c\' //true\n```\n\n## 4\\. Extract\n\n和 Exclude 相反，`Extract<T,U>` 从 T 中提取出 U。\n\n```\ntype Extract<T, U> = T extends U ? T : never\n\nconst user: Extract<\'a\' | \'b\' | \'c\', \'a\' | \'b\' | \'f\'> = \'a\'//true\n```\n\n> 适用于：并集类型\n\n## 5\\. Readonly\n\n把数组或对象的所有属性值转换为只读的，这就意味着这些属性不能被重新赋值。\n\n```\ninterface Person {\n  name?: string,\n  age?: number,\n  hobby?: string[]\n}\ntype Readonly<T> = {\n  readonly [Key in keyof T]: T[Key]\n}\n\nconst user: Readonly<Person> = {\n  name: \"树哥\",\n  age: 18,\n  hobby: [\"code\"]\n}\nuser.age = 12 // false, 因为它是只读属性\n```\n\n## 6\\. Record\n\nRecord<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。\n\n```\ninterface Person {\n  name?: string,\n  age?: number,\n  hobby?: string[]\n}\ntype Pe = \'key1\' | \'key2\'\ntype Record<T extends keyof any, U> = {\n  [Key in T]: U\n}\n\nconst user: Record<Pe, string> = {\n  key1: \"树哥\",\n  key2: \'334\',\n} // true 所有类型都被转位string类型\n```\n\n## 7\\. Pick\n\n从某个类型中挑出一些属性出来\n\n```\ninterface Person {\n  name: string,\n  age: number,\n  hobby: string[]\n}\n\ntype Pick<T, U extends keyof T> = {\n  [Key in U]: T[U]\n}\n\nconst user: Pick<Person, \'age\' | \'hobby\'> = {\n  age: 4,\n  hobby: [\'1\']\n} // true\n```\n\n## 8\\. Omit\n\n与Pick相反，`Omit<T,K>` 从T中取出除去K的其他所有属性。\n\n```\ninterface Person {\n  name: string,\n  age: number,\n  gender: string\n}\n// type Omit<T, K extends keyof T> = {\n//   [Key in K]: T[K]\n// }\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\ntype P1 = Omit<Person, \"age\" | \"gender\">\nconst user: P1 = {\n  name: \'树哥\',\n}\n```\n\n## 9\\. NonNullable\n\n去除类型中的 `null` 和 `undefined`\n\n```\ntype NonNullable<T> = T extends keyof null | undefined ? never : T;\ntype P1 = NonNullable<string | number | undefined>; // string | number\ntype P2 = NonNullable<string[] | null | undefined>; // string[]\ntype P3 = NonNullable<string[] | number[] | { a: string } | undefined>; // string[] | number[] | {a: string}\n\n```\n\n## 10\\. ReturnType\n\n用来得到一个函数的返回值类型\n\n```\ntype Func2 = (value: string) => string;\ntype ReturnType<T extends (...angs: any) => any> = T extends (...angs: any) => infer R ? R : any;\ntype off = ReturnType<Func2> // string;\nconst test: ReturnType<Func2> = \'23\'; // true\n```\n\n## 11\\. Parameters\n\n用于获得函数的参数类型所组成的元组类型。\n\n```\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\ntype P1 = Parameters<(a: number, b: string) => string>; // [number, string]\n```\n\n## 结语\n\n到现在 整篇文章算结束了，其实ts远不止这些。还有ts的配置，以及更多工具的学习，但是我没写了。1是太多永远写不完，2是ts的配置的话，其实更多的创建项目，一年难得配一次。不用就会忘，与其现在记住，不如需要用的时候再去了解。\n\n我相信大家能看到这里的时候，都是想学好ts。学习永无止境，大家一定要自己去敲代码学习。像我这篇文章也复制了别人很多话哈哈哈，但是代码我都是自己敲的，因为只有代码自己敲才能真正的学好。下面有借鉴文章地址，和原作者联系了，原作者同意借鉴。如有侵权联系我删除，我自己代码也放到git上了，需要的话可以下载。\n\n## 参考文献\n\n-   [\\# 2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）](https://juejin.cn/post/7124117404187099172#heading-54 \"https://juejin.cn/post/7124117404187099172#heading-54\")\n-   [\\# TypeScript 高级用法](https://juejin.cn/post/6926794697553739784#heading-25 \"https://juejin.cn/post/6926794697553739784#heading-25\")\n-   [\\# TypeScript中文网](https://link.juejin.cn/?target=https%3A%2F%2Fwww.tslang.cn%2Fdocs%2Fhandbook%2Ftypescript-in-5-minutes.html \"https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html\")\n\n## github代码地址\n\n[github仓库地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fszq19980523%2Ftypescript-learn \"https://github.com/szq19980523/typescript-learn\")', 'public/uploads/1694355370899.png', 2, 1, 1, 808, '2000-09-10 14:16:20', 1);
INSERT INTO `article` VALUES (95, 3, 'UniApp: 微信小程序登录流程梳理', '## 简述\n\nUniApp是一个跨平台开发框架，可以用于同时开发多个平台的应用程序，包括微信小程序、App、H5等。它基于Vue.js框架，通过编写一套代码，就可以在不同平台上运行和展示。哈哈，这介绍说得倒是轻松，其实实现起来，还是要各端调试。\n\n但是在兼容移动端app的情况下，虽说uniapp可以生成且跨平台，但是性能方面与原生ios和android有很大差距的，但是作为前端的我，哪能面面相觑，当然是以最小的成本实现其需求了，若是有时间还是可以在时间成本与性能直接选择Flutter更为最佳。\n\nFlutter使用Dart语言进行开发，其底层渲染引擎可以直接与硬件交互，达到更高的性能表现。另外，Flutter还通过自带的热重载和快速渲染机制，提供了快速且流畅的开发体验。相比之下，UniApp是基于WebView的封装，可能会存在性能上的一些限制。好了，不扯皮了。\n\n这里主要针对微信小程序端做的一些总结。\n\n## 登录流程与实现\n\n### 流程\n\n[微信官方文档](https://link.juejin.cn/?target=)\n\n我看了一下掘金上，很多解读微信小程序官方登录流程的时候都贴了这个图，但这也没办法，流程是微信他们那边定的，而我们则只需要熟悉和了解，才能更好地对接他们（**即微信小程序官方**）开发的接口\n\n\n#### 1\\. 调用wx.login() 获取`code`\n\n这个code的作用是**临时登录凭证** 换句话说就是只能使用一次就失效了\n\n#### 2\\. 调用 [auth.code2Session](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2FOpenApiDoc%2Fuser-login%2Fcode2Session.html \"https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html\") 接口\n\n换取 **用户唯一标识 OpenID** 、 用户在微信开放平台账号下的**唯一标识UnionID**（若当前小程序已绑定到微信开放平台账号） 和 **会话密钥 session\\_key**。\n\n后端发送请求后获取到的返回信息：\n\n```\n{\"session_key\":\"G59Evf\\/Em54X6WsFsrpA1g==\",\"openid\":\"or43434fgggc4-VoSPhTyUnToY60\"}\n```\n\n##### **注意事项**\n\n会话密钥 `session_key` 是对用户数据进行 [加密签名](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fopen-ability%2Fsignature.html \"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\") 的密钥。为了应用自身的数据安全，开发者服务器**不应该把会话密钥下发到小程序，也不应该对外提供这个密钥**\n\n#### 3\\. 生成自定义登录态\n\n之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。 自定义登录态与`openid和session_key`关联，有很多方式可以实现的，如：\n\n-   第一种方式：我们可以将`openid和session_key`存进redis中，前端来访问的时候带上就能够访问。\n-   第二种方式：利用`jwt`方式生成`Token`返回给前端，让前端下次请求时带上，然后后端解析token后识别身份。\n\n**for example**\n\ntoken的生成，一般后台框架都写有集成好的JWT库，比如我们前端通常选用的NestJS,就可以直接引入`npm install @nestjs/jwt` 后端通过一定的规则去生成token,\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a222a983b0e47918d19a98b6a2fec37~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我们可以将openid和session\\_key存进token生成模式中去，\n\n```\n@Get(\'test\')\ntest(@Res({ passthrough: true}) response: Response) {\n    const newToken = this.jwtService.sign({\n      openid: \'xxx\',\n      session_key: \'xxx\'\n    });\n\n    response.setHeader(\'token\', newToken);\n    return \'hello\';\n}\n\n```\n\n那么前端这边接受到的就是携带有session\\_key和openid的token,但是前端无法解析出来，而只需回传给后端识别身份即可，这样就避免了信息泄露的情况。\n\n### 概念\n\n#### OpenID和UnionID的理解\n\n官方给的解释是**OpenID是用户唯一标识**，而**UnionID**则是用户在微信开放平台账号下的**唯一标识** 这里我个人的通俗总结： OpenID是用户在一个具体的小程序或公众号中的唯一标识符。它是用户在登录授权过程中由微信服务器返回的，用于识别用户身份和进行用户认证。每个小程序或公众号都会生成一个独立的OpenID，不同小程序或公众号之间的OpenID是不互通的，即同一个用户在不同小程序或公众号中登录时，会生成不同的OpenID。\n\nUnionID是基于同一开放平台账号下的多个小程序或公众号之间的唯一标识符。当一个用户在同一开放平台下的不同小程序或公众号中都授权登录时，这些小程序或公众号会共享同一个UnionID。通过UnionID，开发者可以实现在不同小程序或公众号之间共享用户信息，实现跨应用的用户关联和个性化服务。\n\n总结起来，OpenID是用于识别同一小程序或公众号中的用户身份，而UnionID用于识别同一开放平台下多个小程序或公众号中的用户身份，这样说是不是通俗易懂了\n\n### 实现\n\n先了解下，使用uniapp自带封装好的方法 UniApp提供了封装好的API和插件，可以方便地获取微信信息。以下是一些常用的方法：\n\n#### **1\\. uni.login** \n\n通过`uni.login`方法可以获取用户的微信登录凭证，返回一个包含登录凭证和其他信息的对象。示例如下：\n\n```\nuni.login({\n  provider: \'weixin\',\n  success: function (res) {\n    var code = res.code; // 微信登录凭证\n    // 其他操作...\n  },\n  fail: function (err) {\n    console.log(err);\n  }\n});\n```\n\n#### **2\\. uni.getUserInfo**\n\n通过`uni.getUserInfo`方法可以获取用户的基本信息，如昵称、头像等。示例如下：\n\n```\nuni.getUserInfo({\n  provider: \'weixin\',\n  success: function (res) {\n    var userInfo = res.userInfo; // 用户信息\n    // 其他操作...\n  },\n  fail: function (err) {\n    console.log(err);\n  }\n});\n```\n\n#### **3\\. uni.checkSession** \n\n使用`uni.checkSession`方法可以检查用户的登录状态是否过期，以避免重复登录。示例如下：\n\n```\nuni.checkSession({\n  success: function () {\n    console.log(\'登录状态有效\');\n  },\n  fail: function () {\n    console.log(\'登录状态过期\');\n    // 其他操作...\n  }\n});\n```\n\n通过上述方法，开发者可以轻松地获取微信信息并进行相应的业务处理。需要注意的是，使用以上API需要在`manifest.json`文件中配置相应的权限和插件。\n\n其中，uni.login对应微信小程序中的wx.login获取code码，传给后端，然后后端调wxapi得到session\\_key和openid;\n\n### **在这个过程遇到的bug:**\n\n#### 非法code原因\n\n需要开发者，拿到开发该项目的appID，并且是该项目开发者管理员或者开发者身份，才可以进行调试对接，不然会报非法参数，code被占用等情况，而后端也需要拿到对应的当前项目的appid和appSecret对前端传过来的code值，去调wxapi,才能正确识别\n\n对了，还有一点就是，配置服务器的ip白名单，这个在微信小程序后台那里通过管理员身份添加白名单。\n\n#### 需要https体验版\n\n如果你在开发微信小程序时使用了带有域名的接口，但是在手机上预览时无法发送请求，可能是以下几个原因导致的：\n\n域名没有添加到小程序的服务器域名白名单中: 在小程序管理后台的开发设置中，可以设置服务器域名白名单，只有在白名单中的域名才能被小程序访问到。请确保你使用的接口域名已经添加到了白名单中。\n\n接口域名没有经过备案： 部分接口域名需要进行备案才能在小程序中使用。如果你的接口域名没有备案，可能无法在手机上预览时请求成功。\n\n接口域名使用了HTTPS协议： 从2019年1月1日开始，微信小程序强制要求所有的接口请求必须使用HTTPS协议。如果你的接口域名使用的是HTTP协议，可能会导致手机上预览时请求失败。请确保你的接口域名已经启用了HTTPS。', '', 2, 2, 1, 208, '2023-09-10 06:40:21', 1);
INSERT INTO `article` VALUES (96, 4, 'Android：RecyclerView封装，打造列表极简加载', '## 前言\n\n```\nmBinding.recycler.linear().divider()\n            .set<OrdinaryListBean> {\n                addLayout(R.layout.layout_ordinary_item)\n            }.setList(getList())\n```\n\n如果我要说，除了数据和布局之外，以上的几行代码，就实现了一个列表加载，有老铁会相信吗？\n\n可以很负责人的告诉大家，经过Kotlin的DSL语言和扩展函数的使用，实现一个列表加载就是如此的简单，有的老铁可能会很懵，怎么没有看到适配器啊，也没有看到设置布局管理器啊，这就是此次封装的隐秘之处，弱化adapter的存在，当然了只是使用上弱化，其内部依然用到了adapter。\n\n经过代码上不断的完善，功能上不断的拓展，目前的封装，已经满足绝大部分的常见需求，决定开源出来，希望可以给RecyclerView的使用上，带来一丝变化，当然了，此项目也会不定期更新，也欢迎大家在使用上提出自己的见解和问题，也希望点个小星星。\n\n目前已开发功能：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be38be7d052454b9eb45e7e17e0c0ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n本篇文章的概述如下\n\n**1、封装库快速使用**\n\n**2、具体功能一一概述**\n\n**3、开源地址**\n\n**4、使用总结**\n\n**5、后续规划**\n\n## 一、封装库快速使用\n\n目前封装的库，已经上传到远程Maven，大家可以按照如下的步骤进行使用：\n\n1、在你的根项目下的build.gradle文件下，引入maven。\n\n```\nallprojects {\n    repositories {\n        maven { url \"https://gitee.com/AbnerAndroid/almighty/raw/master\" }\n    }\n}\n```\n\n2、在你需要使用的Module中build.gradle文件下，引入依赖。\n\n```\ndependencies {\n    implementation \'com.vip:relist:1.0.5\'//一个包含了列表加载和下拉刷新、上拉加载的库，它包含了下面的两个库，使用它，下面的两个就不要引用了。\n    implementation \'com.vip:list:1.0.4\'//列表加载库，如果使用了relist，这个不要再引用\n    implementation \'com.vip:refresh:1.0.0\'//下拉刷新、上拉加载库，如果使用了relist，这个不要再引用\n}\n```\n\n需要注意的是，目前拆分了**三个依赖**，大家一定看清楚后，进行选择使用。refresh依赖只是对SmartRefreshLayout包了一层，没有做过多的扩展，如果大家项目中已经有了刷新库，其实只用list这个依赖即可。**list库是纯RecyclerView封装库，没有用到任何的第三方，大家可以放心使用。**\n\n| 依赖 | 概述 | 版本号 | 集成 |\n| --- | --- | --- | --- |\n| relist | 一个包含了列表加载和下拉刷新、上拉加载的库 | 1.0.5 | implementation \'com.vip:relist:1.0.5\' |\n| list | 只包含列表加载（添加头尾、缺省页、侧滑删除、吸顶效果、分割线、DataBinding等） | 1.0.4 | implementation \'com.vip:list:1.0.4\' |\n| refresh | 只包含下拉刷新、上拉加载 | 1.0.0 | implementation \'com.vip:refresh:1.0.0\' |\n\n## 二、具体功能使用\n\n关于功能上的使用，大家可以直接看源码，或者访问github地址后看使用说明也可以，当然了，在这里我也罗列一下。\n\n### 1、普通的列表加载\n\n普通的列表加载，就是RecyclerView原始的用法，创建适配器Adapter，给RecyclerView设置布局管理器，给RecyclerView设置适配器，虽然说，Adapter已经抽取封装了，但考虑到还有一部分小伙伴具有**怀旧意识**，也很喜欢使用这种方式加载列表，于是呢，这种方式就保留了。\n\n具体使用，举例如下：\n\n#### 创建适配器\n\n即便是普通列表加载，这里也是建议继承父类BaseAdapter，因为直接继承RecyclerView.Adapter的方式， 还得要重写一大堆方法，实在是冗余。\n\nBaseAdapter对RecyclerView.Adapter做了一层封装，只需要传递要加载的layout和数据对象泛型即可，这两个就不贴源码了，一个是xml布局，一个自己定义的对象，没啥好说的。\n\n数据绑定和逻辑处理，实现dataOperation方法即可，当然，这个也是强制要实现的方法。\n\n```\n\nclass OrdinaryListAdapter : BaseAdapter<OrdinaryListBean>(R.layout.layout_ordinary_item) {\n\n    override fun dataOperation(holder: BaseViewHolder, t: OrdinaryListBean?, position: Int) {\n\n        t?.title?.let {\n            holder.setText(R.id.tv_title, it)\n        }\n\n        t?.desc?.let {\n            holder.setText(R.id.tv_desc, it)\n        }\n\n        val ivPic = holder.findView<ImageView>(R.id.iv_pic)\n\n        t?.icon?.let {\n            ivPic.setImageResource(it)\n        }\n\n\n    }\n}\n```\n\n#### 设置布局管理器和适配器\n\n这些代码就比较熟悉了吧，都是RecyclerView的原始用法，点击事件调用adapter中的setOnItemClickListener方法即可。\n\n因为使用了ViewDataBinding，这里的mBinding.recycler指的是RecyclerView控件。\n\n```\n       val manger = LinearLayoutManager(requireContext())\n        manger.orientation = LinearLayoutManager.VERTICAL\n        //设置布局管理器\n        mBinding.recycler.layoutManager = manger\n\n        val adapter = OrdinaryListAdapter()\n        //设置适配器\n        mBinding.recycler.adapter = adapter\n\n        //设置分割线\n        mBinding.recycler.addItemDecoration(\n            ItemDivider(\n                Color.parseColor(\"#cccccc\"),\n                RecyclerView.VERTICAL, 0\n            )\n        )\n\n        //设置数据\n        adapter.setList(getList())\n\n        adapter.setOnItemClickListener {\n            //条目点击事件\n            Toast.makeText(requireContext(), \"当前点击条目为：$it\", Toast.LENGTH_SHORT).show()\n        }\n```\n\n#### 简化设置布局管理器和适配器\n\n看到上面的代码，还是觉得有些冗余，普通列表加载，也是建议大家尽量使用简洁用法。\n\n```\n val adapter = OrdinaryListAdapter()\n\n  mBinding.recycler.linear()//设置布局管理器\n            .divider()//设置分割线\n            .adapter=adapter//设置适配器\n\n       //设置数据\n        adapter.setList(getList())\n\n        adapter.setOnItemClickListener {\n            //条目点击事件\n            Toast.makeText(requireContext(), \"当前点击条目为：$it\", Toast.LENGTH_SHORT).show()\n        }\n \n```\n\n布局管理器调用如下：\n\n```\n垂直列表：linear()\n横向列表：linear(RecyclerView.HORIZONTAL)\n网格列表：grid(2)，一列展示几个，传递数值即可\n瀑布流列表：staggered(2)，一列展示几个，传递数值即可\n```\n\n至于其他的列表展示，如，网格和瀑布流形式，只需要更改布局管理器即可。\n\n### 2、封装之后的列表加载\n\n封装之后的列表加载，是推荐使用的，相对于普通的列表加载，完全弱化了适配器的存在，只需要考虑数据处理即可，非常的简单。\n\n```\nmBinding.recycler.linear()\n            .divider()\n            .set<OrdinaryListBean> {\n                addLayout(R.layout.layout_ordinary_item)\n                bindData {\n                    //获取DataBinding\n                    val binding = getDataBinding<LayoutOrdinaryItemBinding>()\n                    //获取Model\n                    val model = getModel(adapterPosition)\n                    binding?.apply {\n                        tvTitle.text = model.title\n                        tvDesc.text = model.desc\n                        ivPic.setImageResource(model.icon!!)\n                    }\n                    setOnItemClickListener {\n                        //条目点击事件\n                        Toast.makeText(requireContext(), \"当前点击条目为：$it\", Toast.LENGTH_SHORT)\n                            .show()\n                    }\n                }\n\n            }.setList(getList())\n```\n\n相关方法说明：\n\n| 属性或方法 | 概述 |\n| --- | --- |\n| mBinding.recycler | 因为使用了ViewDataBinding，这里的mBinding.recycler指的是RecyclerView控件。 |\n| linear | 布局管理器，可调用方法如下：垂直列表：linear()横向列表：linear(RecyclerView.HORIZONTAL)网格列表：grid(2)，一列展示几个，传递数值即可瀑布流列表：staggered(2)，一列展示几个，传递数值即可 |\n| divider | 分割线 |\n| set | 扩展函数，泛型为加载的对象 |\n| addLayout | 添加列表Item展示的布局 |\n| bindData | 绑定数据和处理逻辑 |\n| getDataBinding | 获取ViewDataBinding |\n| getModel | 获取数据对象 |\n| setOnItemClickListener | 条目点击事件 |\n| setList | 设置列表数据 |\n\n有的老铁可能会问了，封装之后简单是简单了，但是如果遇到复杂列表，都写到一个类里，代码量实在是太多了，哎！这确实是 个问题，但是呢，又不是问题，如果bindData里的逻辑比较多，你完成可以抽取到其他地方，比如ViewModel里，在ViewModel定义 方法后，调用即可，又或者呢，使用后边的DataBinding。\n\n### 3、多条目列表加载\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2c77bea32a944a6bdf598512c06a390~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n效果图可以忽略，重在功能哈~，多条目加载也封装了，有适配器和无适配方式，在实际的业务开发中，大家可以选择性进行使用。\n\n#### 有适配器模式\n\n也就是和传统的多条目保持一致，都在适配器里进行数据的渲染和逻辑处理。\n\n还是那句话，多条目的适配器也抽取了基类，既然都有基类了，为了代码上的简洁，建议还是继承基类比较好。\n\n**如何添加多条目？**\n\n直接在构造方法里，调用addLayout即可，有几个多条目就添加几个，是不是非常的方便，泛型为数据对象，参数为多条目xml布局。\n\n**如何数据渲染和逻辑处理？**\n\n实现bindOperation方法即可，通过holder.itemViewType来却分多条目的类型，当然了这个必须和数据对象里的类型保持一致。\n\n**区分多条目类型**\n\n数据对象实现BaseMultipleItem，重写itemViewType属性，itemViewType就是用来区分多条目类型的，可以随意设置，或者是接口的某个参数，或者是对应的layout。\n\n```\nclass OrdinaryMultipleItemAdapter : BaseMultipleItemAdapter {\n\n    constructor() {\n        //添加多条目类型以及绑定的数据对象\n        addLayout<MultipleItem01Bean>(R.layout.layout_ordinary_multiple_01)\n        addLayout<MultipleItem02Bean>(R.layout.layout_ordinary_multiple_02)\n        addLayout<MultipleItem03Bean>(R.layout.layout_ordinary_multiple_03)\n    }\n\n    override fun bindOperation(holder: BaseViewHolder, t: BaseMultipleItem?, position: Int) {\n\n        when (holder.itemViewType) {\n            1 -> {\n                val bean = t as MultipleItem01Bean\n                holder.setText(R.id.tv_title, bean.title!!)\n                holder.setText(R.id.tv_desc, bean.desc!!)\n                val ivPic = holder.findView<ImageView>(R.id.iv_pic)\n                ivPic.setImageDrawable(bean.icon)\n            }\n            2 -> {\n                val bean = t as MultipleItem02Bean\n                val ivPic01 = holder.findView<ImageView>(R.id.iv_01)\n                val ivPic02 = holder.findView<ImageView>(R.id.iv_02)\n                val ivPic03 = holder.findView<ImageView>(R.id.iv_03)\n\n                ivPic01.setImageDrawable(bean.icon01)\n                ivPic02.setImageDrawable(bean.icon02)\n                ivPic03.setImageDrawable(bean.icon03)\n            }\n            3 -> {\n                val bean = t as MultipleItem03Bean\n                holder.setText(R.id.tv_content, bean.content!!)\n            }\n        }\n    }\n\n}\n```\n\n设置布局管理器和适配器\n\n```\nval adapter = OrdinaryMultipleItemAdapter()\n        mBinding.recycler.linear()\n            .divider().adapter = adapter\n        adapter.setList(getMoreList())\n```\n\n#### 无适配器模式\n\n无适配器模式，更加的简单，只需要调用**setMore方法**即可，有多少条目就调用addLayout几次，在bindData里进行数据渲染和逻辑处理，当然了，也可以使用DataBinding形式，需要追加BR。\n\n```\nmBinding.recycler.linear()\n            .divider()\n            .setMore {\n                addLayout<MultipleItem01Bean>(R.layout.layout_multiple_01, BR.multiple1)\n                addLayout<MultipleItem02Bean>(R.layout.layout_multiple_02, BR.multiple2)\n                addLayout<MultipleItem03Bean>(R.layout.layout_multiple_03, BR.multiple3)\n                bindData {\n\n                }\n            }.setList(getMoreList())\n```\n\n### 4、DataBinding形式列表加载\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565268834f9d4a3583b7cf9cbe8799ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nDataBinding的出现，使得数据绑定更加的简单化，大大减少了代码的书写，大家可以采用提供的两种方式进行使用，一种是针对Item的绑定，一种是对RecyclerView自身的绑定。\n\n#### Item绑定\n\n**第一步，addLayout，增加和xml绑定的BR**\n\n```\n mBinding.recycler.linear().divider()\n            .set<OrdinaryListBean> {\n                addLayout(R.layout.layout_ordinary_bind_item, BR.ordinary)\n                setOnItemViewClickListener { view, position ->\n                    //条目点击事件\n                    Toast.makeText(requireContext(), \"当前点击条目为：$position\", Toast.LENGTH_SHORT).show()\n                }\n            }.setList(getList())\n```\n\n**第二步，xml数据绑定**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <data>\n\n        <variable\n            name=\"ordinary\"\n            type=\"com.abner.list.ordinary.OrdinaryListBean\" />\n    </data>\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"@dimen/vip_dp_80\"\n        android:paddingLeft=\"@dimen/vip_dp_20\"\n        android:paddingRight=\"@dimen/vip_dp_20\">\n\n        <ImageView\n            android:id=\"@+id/iv_pic\"\n            android:layout_width=\"@dimen/vip_dp_60\"\n            android:layout_height=\"@dimen/vip_dp_60\"\n            android:src=\"@mipmap/vip_list_logo\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintLeft_toLeftOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\" />\n\n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginStart=\"@dimen/vip_dp_10\"\n            android:orientation=\"vertical\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintLeft_toRightOf=\"@id/iv_pic\"\n            app:layout_constraintTop_toTopOf=\"parent\">\n\n            <TextView\n                android:id=\"@+id/tv_title\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"@{ordinary.title}\"\n                android:textColor=\"#222222\"\n                android:textSize=\"@dimen/vip_sp_16\" />\n\n            <TextView\n                android:id=\"@+id/tv_desc\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginTop=\"@dimen/vip_dp_10\"\n                android:text=\"@{ordinary.desc}\"\n                android:textColor=\"#666666\"\n                android:textSize=\"@dimen/vip_sp_14\" />\n\n        </LinearLayout>\n\n    </androidx.constraintlayout.widget.ConstraintLayout>\n</layout>\n```\n\n#### RecyclerView绑定\n\n**第一步，xml中RecyclerView数据绑定**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n\n        <variable\n            name=\"model\"\n            type=\"com.abner.list.bind.RecyclerViewBindViewModel\" />\n    </data>\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <androidx.recyclerview.widget.RecyclerView\n            android:id=\"@+id/recycler\"\n            listData=\"@{model.list}\"\n            listLayout=\"@{model.layoutId}\"\n            listManager=\"@{0}\"\n            listVariableName=\"@{model.listVariableName}\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n\n    </androidx.constraintlayout.widget.ConstraintLayout>\n</layout>\n```\n\n**第二步、对应model中提供数据**\n\n```\nclass RecyclerViewBindViewModel : BaseViewModel() {\n\n    val layoutId = R.layout.layout_ordinary_bind_item//item列表\n\n    /**\n     * AUTHOR:AbnerMing\n     * INTRODUCE:获取视图绑定的name\n     */\n    fun getListVariableName(): Int {\n        return BR.ordinary\n    }\n\n    /**\n     * AUTHOR:AbnerMing\n     * INTRODUCE:模拟数据\n     */\n    fun getList(): MutableList<OrdinaryListBean> {\n\n        return mutableListOf<OrdinaryListBean>().apply {\n            for (a in 0..20) {\n                val bean = OrdinaryListBean()\n                bean.title = \"我是标题$a\"\n                bean.desc = \"我是描述信息$a\"\n                bean.icon = R.mipmap.vip_list_logo\n                add(bean)\n            }\n        }\n    }\n}\n```\n\n**属性一览**\n\n| 属性 | 类型 | 概述 |\n| --- | --- | --- |\n| listManager | Int | 布局管理器：默认为纵向的普通列表。0：普通列表1：网格2：瀑布流 |\n| listOrientation | Int | 设置列表方向，默认纵向。横向：RecyclerView.HORIZONTAL |\n| listSpanCount | Int | 展示几列，适用于网格和瀑布流 |\n| isDivider | Boolean | 是否展示分割线 |\n| dividerDrawable | Int | 分割线样式 |\n| listLayout | Int | Item布局 |\n| listData | MutableList<T> | 数据 |\n| listVariableName | Int | 绑定的BR |\n| listAdapter | OnAdapterListener<T> | 返回适配器，可以通过这里实现，适配器中的逻辑处理 |\n| isMultiple | Boolean | 是否是多条目 |\n| multipleAdapter | OnAdapterMultipleListener | 返回多条目适配器 |\n| multipleData | MutableList<BaseMultipleItem> | 多条目数据 |\n| multipleLayout | MutableList<Int> | 多条目布局 |\n| multipleLayoutBindData | MutableList<Class<\\*>> | layout绑定的数据对象 |\n| multipleVariableName | MutableList<Int> | xml绑定的对应的VariableName |\n\n两种绑定方式，各有优点，大家可以根据实际的业务进行选择使用。\n\n### 5、设置分割线\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c362204cfbfe47a98dfab6ee1278a77f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n调用divider方法即可。\n\n```\n mBinding.recycler.linear()\n            .divider()\n            .set<OrdinaryListBean> {\n                addLayout(R.layout.layout_ordinary_bind_item, BR.ordinary)\n            }.setList(getList())\n```\n\ndivider可选参数如下：\n\n| 参数 | 类型 | 概述 |\n| --- | --- | --- |\n| color | Int | 分割线颜色，默认是#cccccc |\n| orientation | Int | 分割线方向，默认和纵向保持一致，RecyclerView.VERTICAL |\n| lineWidth | Int | 分割线的高度 |\n| margin | Int | 分割线距离左右或者距离上下的边距 |\n| hideLast | Boolean | 是否隐藏最后一条分割线 |\n| itemType | Int | 默认为0，不为0时，则绘制横向线条，适用于网格列表分割线 |\n\n### 6、头和尾追加和删除\n\n头和尾的添加支持layout和View两种添加方式，代码如下所示：\n\n```\nmAdapter?.addHead(R.layout.layout_head)//初始 添加头  不用刷新\nmAdapter?.addFoot(R.layout.layout_foot)//初始 添加尾  不用刷新\n```\n\n后续如果动态添加头尾，需要更新适配器。\n\n```\n mAdapter?.addHead(view, true)//追加头，需要刷新\n mAdapter?.addFoot(view, true)//追加尾，需要刷新\n```\n\n动态删除头尾操作，支持按照索引进行删除。\n\n```\nmAdapter?.removeHead()\nmAdapter?.removeFooter()\n```\n\n### 7、数据追加和删除\n\n#### 初始添加数据\n\n```\nmAdapter?.setList(getList())\n```\n\n#### 追加数据，支持对象和集合两种方式\n\n```\n mAdapter?.addData()\n```\n\n#### 删除数据\n\n```\nmAdapter?.removeData(0)\n```\n\n### 8、设置缺省页面\n\n缺省页面没什么好说的，数据为空或者数据加载错误的时候，设置一张占位View。\n\n空页面，调用addEmptyView即可，支持layout和View两种模式，错误页面，调用addErrorView，和空页面使用方式一致。\n\n```\n mAdapter = mBinding.recycler.linear()\n            .divider()\n            .set {\n                addEmptyView(R.layout.layout_empty)//初始化 空页面\n                addErrorView(R.layout.layout_error)//初始化  错误页面\n                addLayout(R.layout.layout_item, BR.str)\n            }\n\n        //初始添加数据\n        mAdapter?.setList(getList())\n```\n\n| 功能 | 实现 |\n| --- | --- |\n| 显示空 | mAdapter?.showEmptyView() |\n| 隐藏空 | mAdapter?.hintEmptyView() |\n| 显示错误 | mAdapter?.showErrorView() |\n| 隐藏错误 | mAdapter?.hintErrorView() |\n\n### 9、拖拽排序功能\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37729fd1cd5e4bff918b927ba44f3353~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n调用drag方法即可实现拖拽排序功能。\n\n```\n mBinding.recycler.linear()\n            .drag()//支持拖拽\n            .set<DragBean> {\n                addLayout(R.layout.layout_drag_item, BR.drag)\n            }.setList(getList())\n```\n\n**注意事项**\n\n传递的数据对象必须实现BaseNoDragBean，需要重写isDrag属性，false为禁止拖拽，true为允许拖拽。\n\n```\nclass DragBean : BaseNoDragBean {\n    override var isDrag = false\n\n    var content = \"\"\n\n}\n```\n\n### 10、侧滑删除条目\n\n调用slideDelete方法即可，支持左右侧滑删除，传递不同的值即可。\n\n```\n mBinding.recycler\n            .linear()\n            .slideDelete()//支持侧滑删除 默认是左滑删除 0是右边  1是左右两边\n            .set<String> {\n                addLayout(R.layout.layout_main_item, BR.str)\n            }.setList(getList())\n```\n\n### 11、侧滑显示按钮\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6696c1a521a546ad8270ddae6b8382a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n由原来的set方法改为setSlide方法即可。\n\n```\n mBinding.recycler\n            .linear()\n            .divider()\n            .setSlide<String> {//如果要显示按钮 使用 setSlide\n                addLayout(R.layout.layout_item)\n                bindData {\n                    val model = getModel(adapterPosition)\n                    setText(R.id.tv_content, model)\n                }\n            }.setList(getList())\n```\n\n有的老铁可能会问，我想展示多个按钮，或者展示自定义的View，如何实现呢？在setSlide调用**addSlideLayout**，传入自己的xml布局即可。\n\n### 12、条目吸顶功能\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b18e7256fe4a6196fb631743a5150e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n实现吸顶就调用stick方法即可。\n\n```\n mBinding.recycler.linear()\n            .stick()\n            .set<StickHeaderBean> {\n                addLayout(R.layout.layout_stick_item, BR.stick)\n            }.setList(getList())\n```\n\n需要注意，数据对象需要实现StickHeaderBean，重写分组标识。\n\n```\nclass StickHeaderBean : BaseStickHeaderBean {\n\n    override var stickGroup: String = \"\"//分组标识\n\n    var name = \"\"//普通内容\n}\n```\n\n### 13、单选、多选、全选、反选\n\n当然了这都是业务层的逻辑，按理来说，没必要在封装，但是考虑到代码的简洁性，单选和多选的判断逻辑就封装了一下，大家如有用到此功能，可按照如下的方式进行操作即可。\n\n#### 单选\n\n主要的就两部分：\n\n**1、开启单选刷新**\n\nmNotifySingleChoice = true\n\n**2、判断单选**\n\n adapterPosition == mCheckPosition，可以利用mCheckPosition来判断，进而更新UI。\n\n```\nmBinding.recycler.linear().divider().set<SingleBean> {\n            mNotifySingleChoice = true//开启单选刷新\n            addLayout(R.layout.layout_single_choice_list_item, BR.single)\n            bindData {\n                val binding = this.getDataBinding<LayoutSingleChoiceListItemBinding>()\n                //判断单选，直接判断  adapterPosition == mCheckPosition 即可\n                binding?.checkbox?.isChecked = adapterPosition == mCheckPosition\n                setOnItemViewClickListener { view, position ->\n                    //条目点击\n                    val singleBean = getList()[position]//单选 选择的对象\n                    mViewModel.name.set(singleBean.name)\n                }\n            }\n        }.setList(getList())\n```\n\n#### 多选\n\n和单选一样，也是两部分\n\n**1、设置多选更新**\n\nmNotifyMultipleChoice = true\n\n**2、多选回调监听**\n\nsetOnMultipleChoiceListener{}\n\n```\nmBinding.recycler.linear().divider().set<MultipleBean> {\n            mNotifyMultipleChoice = true//多选更新\n            addLayout(R.layout.layout_multiple_choice_list_item, BR.multiple)\n            bindData {\n                //多选回调监听\n                setOnMultipleChoiceListener {\n                    var allPrice = 0.0f\n                    it.forEach {\n                        allPrice += it.price\n                    }\n                    mViewModel.commodityNumber.set(\"选择商品数量为：\" + it.size)\n                    mViewModel.allPrice.set(\"总价格为：$allPrice\")\n                }\n            }\n        }.setList(getList())\n```\n\n### 14、上拉刷新和下拉加载\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c845102e659b4634a37cad438e7cbe69~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n刷新和加载使用的是**SmartRefreshLayout**这个开源框架，毕竟已经有很优秀的框架了，没必要再重新封装一个，具体的用法，大家可以按照SmartRefreshLayout的文档去操作使用就行。\n\n支持全局设置下拉和上拉展示View，只需要在Application里初始化即可。\n\n```\n     //上拉加载和下拉刷新，初始化头和尾\n        ListConfig.apply {\n            addRefreshHeader {\n                ClassicsHeader(it)\n            }\n            addRefreshFooter {\n                ClassicsFooter(it)\n            }\n        }\n```\n\n这里也简单举个例子：\n\n**1、xml中引入**\n\n```\n  <com.abner.refresh.kernel.SmartRefreshLayout\n        android:id=\"@+id/srl_layout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <androidx.recyclerview.widget.RecyclerView\n            android:id=\"@+id/rv_view\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n    </com.abner.refresh.kernel.SmartRefreshLayout>\n```\n\n**2、代码简单使用**\n\n```\nmSmartRefreshLayout?.setOnRefreshLoadMoreListener(object : OnRefreshLoadMoreListener {\n            override fun onRefresh(refreshLayout: RefreshLayout) {\n               \n            }\n\n            override fun onLoadMore(refreshLayout: RefreshLayout) {\n             \n            }\n        })\n```\n\n当然了，为了更好的拓展使用，针对SmartRefreshLayout，又简单做了一层包装，别无他意，就是为了让使用更加的简单。\n\n**1、xml里引入PageRefreshLayout**\n\n```\n <com.abner.relist.PageRefreshLayout\n            android:id=\"@+id/refresh\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n```\n\n**2、代码里使用**\n\n```\n  mBinding.refresh.getRecycler().linear()\n            .divider()\n            .set<String> {\n                addLayout(R.layout.layout_item, BR.str)\n            }\n        //刷新和加载\n        mBinding.refresh.refresh { isRefresh, refreshLayout ->\n            mViewModel.doHttp {\n                addData(it)\n            }\n        }.autoRefresh()\n```\n\n直接调用refresh方法即可，isRefresh为true是下拉，否则就是上拉，非常的方便，而addData方法，则实现了分页加载数据，上拉和下拉直接调用addData即可。\n\n**PageRefreshLayout可调用方法如下**\n\n| 方法 | 参数 | 概述 |\n| --- | --- | --- |\n| autoRefresh | 无参 | 自动刷新操作 |\n| refresh | 无参 | 静默刷新（不带下拉刷新动画） |\n| addData | Collection<T> | 添加数据，分页会自动追加数据，下拉和上拉会自动关闭 |\n| setEnableRefresh | Boolean | 是否禁止下拉 |\n| setEnableLoadMore | Boolean | 是否禁止上拉 |\n| finishRefresh | 无参 | 关闭下拉刷新 |\n| finishLoadMore | 无参 | 关闭上拉刷新 |\n| getPager | 无参 | 获取当前页码 |\n| refresh | 回调函数 | 刷新和加载方法 |\n| getSmartRefresh | 无参 | 获取SmartRefreshLayout |\n| getRecycler | 无参 | 获取RecyclerView |\n| addEmptyView | Int/View | 添加空的布局，支持layout和View |\n| addErrorView | Int/View | 添加错误的布局，支持layout和View |\n| showEmptyView | 无参 | 显示空布局 |\n| showErrorView | 无参 | 显示错误布局 |\n| hintEmptyView | 无参 | 隐藏空布局 |\n| hintErrorView | 无参 | 隐藏错误布局 |\n| setHeightWrapContent | 无参 | 设置整体的列表由充满改为包裹内容。 |\n\n## 三、开源地址\n\n关于大家在使用上的问题以及后续的优化，或者功能新增，都会时长更新，方便的话，给个小星星呗~\n\n开源地址：[github.com/AbnerMing88…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAbnerMing888%2FVipList \"https://github.com/AbnerMing888/VipList\")\n\n## 四、使用总结\n\n1、无适配器的模式，在逻辑相对复杂的页面，建议大家可以抽取到ViewModel中实现，当然，也可以采用DataBinding的形式。\n\n2、很多使用方式，或者常见的业务开发场景，在文档中或者源码中，都会详细的备注，大家可以细心的查看即可。\n\n3、条目点击事件，给出了两个，大家可以选择性使用。\n\n只返回索引\n\n```\nsetOnItemClickListener { \n                    \n}\n```\n\n当前点击的View和索引。\n\n```\n setOnItemViewClickListener { view, position ->\n                   \n }\n```\n\n## 五、后续规划\n\n此库的封装，除了刷新加载库使用了SmartRefreshLayout，其他的都是自己从0到1的开发，目前，自己已经在项目中使用，暂时没有出现任何问题，当然了，后续，也会不断的对其进行优化，增加一些其他的功能，希望有需要的小伙伴，长期关注。\n\n**关于维护上**，不断的优化和解决一些大家所提的问题。\n\n**关于源码上**，后续会逐一剖析其实现方式，确确实实，里面用到了一些另类技术，当然了，这都是后话了。', 'public/uploads/1694330186296.png', 4, 7, 0, 654, '2023-09-10 07:16:32', 1);
INSERT INTO `article` VALUES (97, 1, '一个小公司的技术开发心酸事', '## 背景\n\n长话短说，就是在2022年6月的时候加入了一家很小创业公司。老板不太懂技术，也不太懂管理，靠着一腔热血加上对实体运输行业的了解，加上盲目的自信，贸然开始创业，后期经营困难，最终散伙。\n\n自己当时也是不察，贸然加入，后边公司经营困难，连最后几个月的工资都没给发。\n\n当时老板的要求就是尽力降低人力成本，尽快的开发出来App(Android+IOS)，老板需要尽快的运营起来。\n\n## 初期的技术选型\n\n当时就自己加上一个刚毕业的纯前端开发以及一个前面招聘的ui，连个人事、测试都没有。\n\n结合公司的需求与自己的技术经验(主要是前端和nodejs的经验)，选择使用如下的方案：\n\n1.  使用`uni-app`进行`App`的开发，兼容多端，也可以为以后开发小程序什么的做方案预留，主要考虑到的点是比较快，先要解决有和无的问题；\n2.  使用`egg.js` + `MySQL`来开发后端，开发速度会快一点，行业比较小众，不太可能会遇到一些较大的性能问题，暂时看也是够用了的，后期过渡到`midway.js`也方便；\n3.  使用`antd-vue`开发运营后台，主要考虑到与`uni-app`技术栈的统一，节省转换成本；\n\n也就是初期选择使用`egg.js` + `MySQL` + `uni-app` + `antd-vue`，来开发两个App和一个运营后台，快速解决0到1的问题。\n\n### 关于App开发技术方案的选择\n\nApp的开发方案有很多，比如纯原生、flutter、uniapp、react-native/taro等，这里就当是的情况做一下选择。\n\n1.  IOS与Android纯原生开发方案，需要新招人，两端同时开发，两端分别测试，这个资金及时间成本老板是不能接受的；\n2.  flutter，这个要么自己从头开始学习，要么招人，相对于纯原生的方案好一点，但是也不是最好的选择；\n3.  react-native/taro与uni-app是比较类似的选择，不过考虑到熟练程度、难易程度以及开发效率，最终还是选择了uni-app。\n\n### 为什么选择egg.js做后端\n\n很多时候方案的选择并不能只从技术方面考虑，当是只能选择成本最低的，当时的情况是`egg.js`完全能满足。\n\n1.  使用一些成熟的后端开发方案，如Java、、php、go之类的应该是比较好的技术方案，但对于老板来说不是好的经济方案；\n2.  `egg.js`开发比较简单、快捷，个人也比较熟悉，对于新成员的学习成本也很低，对于JS有一定水平的也能很快掌握`egg.js后端的开发`。\n\n## 中间的各种折腾\n\n前期开发还算顺利，在规定的时间内，完成了开发、测试、上线。但是，老板并没有如前面说的，很快运营，很快就盈利，运营的开展非常缓慢。中间还经历了各种折腾的事情。\n\n1.  老板运营遇到困难，就到处找一些专家（基本跟我们这事情没半毛钱关系的专家），不断的提一些业务和ui上的意见，不断的修改；\n2.  期间新来的产品还要全部推翻原有设计，重新开发；\n3.  还有个兼职的领导非要说要招聘原生开发和Java开发重新进行开发，问为什么，也说不出什么所以然，也是道听途说。\n\n反正就是不断提出要修改产品、设计、和代码。中间经过不断的讨论，摆出自己的意见，好在最终技术方案没修改，前期的工作成果还在。后边加了一些新的需求：系统升级1.1、ui升级2.0、开发小程序版本、开发新的配套系统(小程序版本)以及开发相关的后台、添加即时通信服务、以及各种小的功能开发与升级；\n\n中间老板要加快进度了就让招人，然后又无缘无故的要开人，就让人很无奈。最大的运营问题，始终没什么进展，明显的问题并不在产品这块，但是在这里不断的折腾这群开发，也真是难受。\n\n明明你已经很努力的协调各种事情、站在公司的角度考虑、努力写代码，却仍然无济于事。\n\n### 后期技术方案的调整\n\n1.  后期调整了App的打包方案；\n2.  在新的配套系统中，使用`midway.js`来开发新的业务，这都是基于前面的`egg.js`的团队掌握程度，为了后续的开发规范，做此升级；\n3.  内网管理公用npm包，开发业务组件库；\n4.  规范代码、规范开发流程；\n\n## 人员招聘，团队的管理\n\n### 人员招聘\n\n如下是对于当时的人员招聘的一些感受：\n\n1.  小公司的人员招聘是相对比较难的，特别是还给不了多少钱的；\n2.  好在我们选择的技术方案，只要对于JS掌握的比较好就可以了，前后端都要开发一点，也方便人员工作调整，避免开发资源的浪费。\n\n### 团队管理\n\n对于小团队的管理的一些个人理解：\n\n1.  小公司刚起步，就应该实事求是，以业务为导向；\n2.  小公司最好采取全栈的开发方式，避免任务的不协调，造成开发资源的浪费；\n3.  设置推荐的代码规范，参照大家日常的代码习惯来制定，目标就是让大家的代码相对规范；\n4.  要求按照规范的流程设计与开发、避免一些流程的问题造成管理的混乱和公司的损失；\n    1.  如按照常规的业务开发流程，产品评估 => 任务分配 => 技术评估 => 开发 => 测试 => cr => 上线 => 线上问题跟踪处理；\n5.  行之有效可量化的考核规范，如开发任务的截止日期完成、核心流程开发文档的书写、是否有线上bug、严谨手动修改数据库等；\n6.  鼓励分享，相互学习，一段工作经历总要有所提升，有所收获才是有意义的；\n7.  及时沟通反馈、团队成员的个人想法、掌握开发进度、工作难点等；\n\n## 最后总结及选择创业公司避坑建议!important\n\n1.  选择创业公司，一定要确认老板是一个靠谱的人，别是一个总是画饼的油腻老司机，或者一个优柔寡断，没有主见的人，这样的情况下，大概率事情是干不成的；\n    1.  老板靠谱，即使当前的项目搞不成，也可能未来在别的地方做出一番事情；\n2.  初了上边这个，最核心的就是，怎么样赚钱，现在这种融资环境，如果自己不能赚钱，大概率是活不下去的@自己；\n3.  抓住核心矛盾，解决主要问题，业务永远是最重要的。至于说选择的开发技术、代码规范等等这些都可以往后放；\n4.  对上要及时反馈自己的工作进度，保持好沟通，老板总是站在更高一层考虑问题，肯定会有一些不一样的想法，别总自以为什么什么的；\n5.  每段经历最好都能有所收获，人生的每一步都有意义。\n\n以上只是个人见解，请指教，[个人blog](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fqiuwww%2Fblog \"https://github.com/qiuwww/blog\")。', 'public/uploads/1694329490772.png', 3, 2, 1, 495, '2023-09-10 07:05:06', 1);
INSERT INTO `article` VALUES (98, 4, '兔年了，一起用ArkTS来画兔子吧', '似曾相识的标题，没错，今年年初就发布过一篇《兔年了，一起用Compose来画兔子吧》的文章，那是我刚开始学习Compose发布的第一篇文章，没放链接的原因是兔子太丑就别点进去看了，辣眼睛辣眼睛，那篇文章主要是针对Compose里面的Canvas做针对性练习，了解一下如何绘制各种形状的几何图形，而在前不久华为推出了HarmonyOS NEXT之后，对于我们Android开发者来讲，所要掌握的技术栈里面毫无疑问又多了一个开发语言，那就是ArkTS,所以跟Compose一样，我学习ArkTS的第一步也从学习它的Canvas开始，今天我也用ArkTS来画一只跟年初差不多画风的兔子，眼睛就再辣一次吧，学习基础知识最重要\n\n## 准备工作\n\n首先来创建我们的自定义组件，命名为`Rabbit`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ab4fed08274c65bfee2103880df845~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n`@Entry`、`@Component`都是装饰器，`@Component`表示这个是自定义组件，`@Entry`表示该组件为入口组件，在`build()`方法中我们就可以写主要的UI代码，这一点与Flutter类似，至于如何选择我们界面上的父组件，由于最后这里只会有一个`Canvas`，所以父组件如何选择没有太大要求，我直接将官方api文档里面的样式代码复制过来了\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e14367ed2944a68a607b24631d8b09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n父组件用的是弹性组件`Flex`，这里设置的是主轴方向是`FlexDirection.Column`，`alignItems`表示里面子组件在交叉轴方向上的对齐方式，这里设置的是`ItemAlign.Center`居中对齐，`justifyContent`表示子组件在主轴方向上的对齐方式，这里设置的是`FlexAlign.Center`居中对齐，然后在组件后面是设置的组件本身的一些属性，这里设置的是宽高，都是占满全屏，这种属性的设置方式类似于Compose里面的`Modifier`，创建好父组件之后，我们接下来就是创建我们子组件`Canvas`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/726c038eed6c4e6ea2451800641e59f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里`Canvas`的创建方式不得不让我有点槽点不吐不快\n\n-   **槽点一**：这里创建了一个`RenderingContextSettings`对象和一个`CanvasRenderingContext2D`，可以理解为就是`Canvas`的画布对象，但是对于`Canvas`来说最主要的东西为什么不在`Canvas`组件内部创建完成以后通过`onReady`函数回调出来呢，非得让开发者手动new出来再传到`Canvas`里面去，这个声明式ui也不是特别的“声明”\n-   **槽点二**：在槽点一里面说了`Canvas`的创建过程需要new一个`CanvasRenderingContext2D`对象后传到`Canvas`的构造函数里面去，但是我发现如果不传参数的话，也不会编译报错，甚至可以run起来，那会我还没看`Canvas`源码，琢磨着难道`Canvas`里面还有一个默认的`CanvasRenderingContext2D`对象吗，结果一看模拟器界面，一片空白。。。好吧，我知道了，必须传～\n-   **槽点三**：在组件内部使用组件的局部变量时候，一定要用`this`去指向这个变量，不然编译器会报错，说找不到它了，反正最后整只兔子画完我是`this`麻了\n\n创建完`Canvas`之后，由于绘制的过程基本上是计算各种坐标的过程，所以需要知道整个画布的宽和高，我们在增加两个变量来表示画布的宽高\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db601c9791f4113813f5618b53854ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里`screenX`与`screenY`分别表示画布的宽和高，我们看到在这俩变量前面也有一个装饰器`@State`修饰，被这个装饰器修饰的变量我们叫它状态变量，当它的值发生变化的时候会触发ui刷新，类似于Flutter的`setState`,Compose的`remember`,所以我们在`onReader`函数里面将画布的宽高设置到`screenX`与`screenY`里面去\n\n## 开始绘制\n\n## 头\n\n这里的头部我们就用一个圆圈来表示，在ArkTS里面使用`arc`函数来绘制圆圈,这个函数既可以绘制圆圈，也可以画圆弧，提供如下几个参数\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142cb5c1da5440e59c63afbd1f2a3f7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n前两个参数代表圆心坐标，`radius`表示圆弧或者圆的半径大小，最后一个参数`couterclockwise`表示绘制圆弧的方向，默认是逆时针，最关键的是`startAngle`和`endAngle`这俩个参数，我们注意看这俩参数后面的描述写的是弧线的起始弧度于终止弧度，单位是弧度而不是角度，所以你如果想画个半圆，传的是0和180的话，出来的依然还是个圆，正确的做法是利用计算弧度的公式来做\n\n```\n弧度=度数*π/180\n```\n\n知道关键点以后就要开始画这个圆了，先设置一下画笔的粗细与颜色\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9e61ca52dcc4cfba05faca08265ace9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n接着就调用`arc`函数来画这个圆，我们圆的中心点就定在了画布的中心点位置，也就是`screenX/2`与`screenY/2`\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e6240fd516e4210bf62dbf897ddfcc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n绘制圆弧的代码就这一行结束了，但是我们运行一遍代码后发现模拟器上什么都没有，原因是我们少加了一行代码，在ArkTS中你需要显式的表明你画的图形是空心的还是实心的，分别用下面两个函数来表明\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4990358a9344f3e89780becee30100d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这看似是一句配置类型的代码，但你在后面会发现每调用一次绘制函数就要写一下`stroke()`或者`fill()`,不调用的话绘制的效果就不出来，如果你不信我们接下来就做个试验，来画两个圆，一个在调用好`arc`函数以后调用了`stroke`,另一个没有调用，代码是这个样子的\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e00f1a78abd4611911f0e5c689b959b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我们在原本兔头的圆心位置下面又增加了一个略小一点的圆，我们运行下代码看看实际效果如何\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3ce604f7f9e4476a5b08859740bcbea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n可以看见屏幕上确实只有一个圆，只有当我们把下面那个圆的`stroke`函数补充好，那个略小一点的圆才出现了\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe8034dc83f4484a8042cf78e678a00e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92556d21e6734c658792e2c4e5dc1cd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n一个好消息，一个坏消息，好消息是俩圆都出来了，坏消息是，咋俩圆之间还有根黑线呢？咱也没画啥多余的线啊，查了下api文档才知道，我们又少加代码了，文档里面说，如果一个路径画完了要开始下一个路径了，需要调用`beginPath`函数,不然就是像我们这俩圆一样，两个路径还有一处相连的地方，它认为你第一笔还没有画完，最后当我把`beginPath`函数加到代码里面之后，最终效果才正常了\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36fcf82ecbe4340ad0c24d00c24bb41~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f1ca68c9fd4c5f96c5ab1cc0421801~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n好了，槽点再多，这个也毕竟是语法，我们将小一点的圆去调继续来画兔子\n\n## 鼻子\n\n现在开始画兔子的鼻子，这里我打算使用三角形来表示鼻子，但是在现有的api中没有现成的函数来画三角，我们只能通过画path来实现，画path同我们以前在Android里面画path基本相同,先调用`moveTo`确定起点，然后调用`lineTo`来画路径，最终画完以后调用`closePath`结束当前路径形成一个封闭路径，代码如下所示\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8510e6d8594f65b58f79c275984321~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ed4f98b9ce4ad4bca0d520253200b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n鼻子很简单，我们接下来画兔唇\n\n## 兔唇\n\n兔唇分左兔唇与右兔唇，其实就是两个圆弧，我们可以使用之前用过的`arc`函数来实现，但是我们这里使用另一个函数来画圆弧，那个就是`arcTo`,用法如下所示\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa755de07f4f46049b0ec328755e887e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个函数是根据圆弧经过的点和半径大小来确定整个圆弧的样式，在调用这个函数之前还必须调用`moveTo`来确定圆弧的起点，所以画一个圆弧需要确定好三个点，至于如何找出这三个点，这个同绘制二阶贝塞尔曲线的思路是一样的，`moveTo`是第一个固定点，`arcTo`函数前两个参数表示曲线控制点的xy坐标，后面两个参数表示曲线终止固定点的xy坐标，这样子应该理解起来会方便一些，所以我们左右兔唇的绘制代码和效果图如下所示\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236542f0936e40988090b62b956ed84d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c4a01973454b23bdbec679f0875959~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 眼珠与眼眶\n\n然后我们在兔子脑袋偏上位置画眼珠，眼珠就是两个实心圆，圆的绘制方法已经知道了，这里是需要注意一下如果希望兔子眼珠的颜色同线条颜色不一样，就需要设置一下画笔实心的颜色，同时绘制结束需要调用`fill`函数来表明当前绘制的是实心图形，下面就是绘制左右眼珠的代码\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce66d5958b474649bce0a34b46d9541a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n运行一下看看效果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3219d6955399450c8bac276d52c74804~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n只有眼珠子的话看起来较显呆滞，所以需要在眼珠子上面画上眼眶，眼眶现在画起来就容易多了，那就是个半圆，起点与终点的y坐标与眼珠子一致，然后x坐标左右各加上点偏移量就好了，中间的控制点的x坐标与眼珠子的x坐标一致，y坐标向上偏移一点就好，代码如下\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdded63d432d475993b05de7a3312b4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n现在再看看效果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b5f2e7fe9884516b66a1198bc7f616e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n现在看起来有神了，我们接着下一步\n\n## 耳朵\n\n记得在之前用Compose画兔子的时候，耳朵是用两个椭圆来完成的，然后椭圆的底部反复调整才跟脑袋连在一起，方式有点太sa了，这次不打算这么做，首先兔子耳朵不可能直溜溜的竖在脑袋上的，肯定会倾斜一点，其次兔子的耳朵严格来讲并不能用椭圆来表示，毕竟贴近脑袋部分并不相连在一起，如果连在一起了，我们拽兔子耳朵的时候，就很容易拽断了。。。更形象的应该是兔子脑袋上找出两个点，然后各自向上画曲线，最终在一个点连在一起形成一只耳朵,所以一只耳朵其实是由两根三阶贝塞尔曲线构成，那么第一步需要先找出两根曲线的起点，这个起点在脑袋上，那么就需要根据半径与角度计算出一个圆周上某一个点的坐标，下面是左耳的两个起点坐标的计算代码\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c168e5e18ed440f8778f1d10f8f431b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里就是利用数学公式sin与cos来计算xy坐标，从传值上就能看出，sin与cos函数接收的也是以弧度为单位的数值，至于这里的取值，sin与cos函数里面的角度是按照顺时针来计算的，起点在圆的最左侧，而我们之前在使用`arc`函数画圆弧的时候，里面传的角度默认按照逆时针方向旋转的，起点在圆的最右侧，这里是存在差异的，要注意一下，所以在代码中，`leftx`与`lefty`是比较靠近脑袋顶部的点，而`leftOutX`与`leftOutY`是比较靠外侧的点，然后我们以这两个点为参照点，就能将贝塞尔曲线其余几个点找出来，最终左耳朵的绘制代码如下所示\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b4aa6995de74ca0bf1346961be477d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n运行一下代码，左耳朵就有了\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f1fa0981ef407caaa6f45bbfee79d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我们再以同样的方式将右耳的坐标算出来，代码与效果图如下所示\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c730be81cfde46b9a296d6908aa72552~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61d6587ed9fd47d687ffefe5f8145035~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这只兔子可算开始萌起来了～\n\n## 身体\n\n兔子的身体在之前Compose的文章里面也是用椭圆来表示的，但是同样感觉好像一拽兔子就能把兔子拽断一样，所以这里身体的绘制同耳朵一样，也是用一个三阶贝塞尔曲线从兔子脑袋下边的一头连到另一头，剩下两个点就选择画布靠下一点的位置，代码如下\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab7e28575b774190bd2dddcbac20659a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a688922fe954ee3a6547194c6b75295~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n效果图就是上面这个样子了，算是达到预期要的效果了吧，然后给兔子加上两只爪子\n\n## 兔爪\n\n兔爪我们用两个椭圆型表示，在ArkTS里面绘制椭圆的api我们使用`ellipse`函数来实现，它需要的参数如下所示\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b509bb820b8c4e78977afea1d9b768e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba7cc7e518d4caca1f7e9d50559bff3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n前两个参数同绘制圆弧一样，是中心点坐标，第三个参数`radiusX`是x轴的半径，`radiusY`是y轴半径，`rotation`是旋转角度，`startAngle`与`endAngle`是起始点与终止点坐标，最后一个参数同样也是绘制的方向，默认是`fasle`，逆时针，都是比较容易填的参数，其中中心点的x坐标我们参考之前画身体时候第二，三个点的x坐标，再往里偏移一些，而椭圆的y坐标我们就选择`screenY * 3/4`的高度，这样绘制两只爪子的代码就有了\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7d458c1ec34e72921ecf6082c4a6e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n我们看到这里还将爪子设置成实心的，实心填充颜色设置成纯黑，由于之前兔子眼珠是红色的，所以这里要注意下眼珠与爪子的绘制顺序，如果眼珠在爪子的下面绘制，那么眼珠也变成黑色的了，除非在绘制眼珠之前重新设置下`fillStyle`，再更改下填充色值，现在我们运行下代码，两个爪子就出来了\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd45643e44f14f0bbc5f047adcc1758a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n## 尾巴\n\n最后一个就是画尾巴，尾巴打算用一个圆来表示，圆的话我们上面已经讲过如何绘制了，主要还是寻找中心点坐标，这边中心点的x坐标就用之前画身体用到的第三个控制点的x坐标，也就是变量`endX`,y坐标的高度就确定为四分之三的画布高度，代码如下所示\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962d342dbc70476d926a8b46f1d27f66~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里圆的半径经过反复调试最终确定为20，我们现在跑下代码，尾巴就有了\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1bd8411aa254102af4925f21f1213da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n现在我们在优化下，给这个圆加点分割线，让它看起来毛茸茸一点，分割线我们使用`setLineDash`函数来完成\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7d37a37d5e54063b4ec47f89de71848~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这个函数接收一个数组，数组里面第一个值表示实线长度，第二个值表示间隙长度，我们随意设置两个值来看看效果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/365d8c9e4dcd4012ae9a2ac2e5f8f5d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a497e3637d4a8680d88ee91b435d3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n现在看起来是不是更像一只毛茸茸的尾巴\n\n## 总结\n\n到这里我们已经完成了使用ArkTS来绘制一只兔子的整个过程，其实兔子本身颜值如何到不是很重要，这篇文章的关键主要还是熟悉一下ArkTS里面的`Canvas`组件，以及这个组件里面提供的api，虽说仅仅一个组件就有不少槽点，但每个语言都有每个语言的特性，作为一个技术人，对新出来的技术，尤其这个还是国内自己的技术，应该更多的是去挖掘这个技术的优点，以及它与其他语言都有什么异同，这个才是应该做的事情。', 'public/uploads/1694330101859.png', 4, 3, 0, 628, '2023-09-10 07:15:02', 1);
INSERT INTO `article` VALUES (99, 5, 'Mr.', 'Always keep your eyes open. Keep watching. Because whatever you see can inspire you. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. A comfort zone is a beautiful place, but nothing ever grows there. If you wait, all that happens is you get older. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. Difficult circumstances serve as a textbook of life for people. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. Navicat Data Modeler is a powerful and cost-effective database design tool which helps you build high-quality conceptual, logical and physical data models. If opportunity doesn’t knock, build a door. I destroy my enemies when I make them my friends. After logged in the Navicat Cloud feature, the Navigation pane will be divided into Navicat Cloud and My Connections sections. The past has no power over the present moment. SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. Anyone who has never made a mistake has never tried anything new. In the Objects tab, you can use the List List, Detail Detail and ER Diagram ER Diagram buttons to change the object view. You will succeed because most people are lazy. Optimism is the one quality more associated with success and happiness than any other.', '', 1, 0, 2, 183, '2023-09-05 09:00:15', 0);
INSERT INTO `article` VALUES (100, 1, 'Ms.', 'The repository database can be an existing MySQL, MariaDB, PostgreSQL, SQL Server, or Amazon RDS instance. Navicat Monitor requires a repository to store alerts and metrics for historical analysis. Difficult circumstances serve as a textbook of life for people. The reason why a great man is great is that he resolves to be a great man. In the middle of winter I at last discovered that there was in me an invincible summer. Secure SHell (SSH) is a program to log in into another computer over a network, execute commands on a remote server, and move files from one machine to another. Flexible settings enable you to set up a custom key for comparison and synchronization. Navicat Cloud could not connect and access your databases. By which it means, it could only store your connection settings, queries, model files, and virtual group; your database passwords and data (e.g. tables, views, etc) will not be stored to Navicat Cloud. SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. SSH serves to prevent such vulnerabilities and allows you to access a remote server\'s shell without compromising security. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. The first step is as good as half over. Typically, it is employed as an encrypted version of Telnet. The reason why a great man is great is that he resolves to be a great man. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. Import Wizard allows you to import data to tables/collections from CSV, TXT, XML, DBF and more. Navicat allows you to transfer data from one database and/or schema to another with detailed analytical process. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. The On Startup feature allows you to control what tabs appear when you launch Navicat. Optimism is the one quality more associated with success and happiness than any other. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. If it scares you, it might be a good thing to try. Export Wizard allows you to export data from tables, collections, views, or query results to any available formats. Navicat authorizes you to make connection to remote servers running on different platforms (i.e. Windows, macOS, Linux and UNIX), and supports PAM and GSSAPI authentication. Navicat Monitor can be installed on any local computer or virtual machine and does not require any software installation on the servers being monitored. A man’s best friends are his ten fingers. You cannot save people, you can just love them. Remember that failure is an event, not a person. The past has no power over the present moment. The On Startup feature allows you to control what tabs appear when you launch Navicat. Remember that failure is an event, not a person. How we spend our days is, of course, how we spend our lives. The Synchronize to Database function will give you a full picture of all database differences. To connect to a database or schema, simply double-click it in the pane. Typically, it is employed as an encrypted version of Telnet. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. The past has no power over the present moment. SQL Editor allows you to create and edit SQL text, prepare and execute selected queries. What you get by achieving your goals is not as important as what you become by achieving your goals. If opportunity doesn’t knock, build a door. If opportunity doesn’t knock, build a door. I may not have gone where I intended to go, but I think I have ended up where I needed to be. A man’s best friends are his ten fingers. In other words, Navicat provides the ability for data in different databases and/or schemas to be kept up-to-date so that each repository contains the same information. You cannot save people, you can just love them. Always keep your eyes open. Keep watching. Because whatever you see can inspire you. Remember that failure is an event, not a person. The Synchronize to Database function will give you a full picture of all database differences. You will succeed because most people are lazy. A man’s best friends are his ten fingers. All the Navicat Cloud objects are located under different projects. You can share the project to other Navicat Cloud accounts for collaboration. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. Typically, it is employed as an encrypted version of Telnet. HTTP Tunneling is a method for connecting to a server that uses the same protocol (http://) and the same port (port 80) as a web server does. Sometimes you win, sometimes you learn. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. Navicat is a multi-connections Database Administration tool allowing you to connect to MySQL, Oracle, PostgreSQL, SQLite, SQL Server, MariaDB and/or MongoDB databases, making database administration to multiple kinds of database so easy. To successfully establish a new connection to local/remote server - no matter via SSL, SSH or HTTP, set the database login information in the General tab. In a Telnet session, all communications, including username and password, are transmitted in plain-text, allowing anyone to listen-in on your session and steal passwords and other information. You can select any connections, objects or projects, and then select the corresponding buttons on the Information Pane. With its well-designed Graphical User Interface(GUI), Navicat lets you quickly and easily create, organize, access and share information in a secure and easy way. A query is used to extract data from the database in a readable format according to the user\'s request. You cannot save people, you can just love them. Actually it is just in an idea when feel oneself can achieve and cannot achieve. To clear or reload various internal caches, flush tables, or acquire locks, control-click your connection in the Navigation pane and select Flush and choose the flush option. You must have the reload privilege to use this feature. The Navigation pane employs tree structure which allows you to take action upon the database and their objects through their pop-up menus quickly and easily. Success consists of going from failure to failure without loss of enthusiasm.', '', 1, 3, 1, 712, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (101, 7, '他真的试图教会我用Nest.js写接口耶', '> 前言：学习一下用Nest.js写接口\n\n## 一.项目初始化\n\n```\n1.安装脚手架\nnpm i -g @nestjs/cli\n\n2.创建项目\nnest new 项目名称\n\n3. cd 到项目\n\n4.安装依赖\nnpm i\n\n5.启动项目，监视文件，自动重新编译和重新加载服务器\nnpm run start:dev\n\n6.查看启动项目启动端口号，进入程序入口文件 src/main.ts 查看\n浏览器打开 http://localhost:3000/\n```\n\n## 二.核心文件介绍\n\n`app.controller.spec.ts` 控制器的单元测试，也不知道怎么用的。  \n`app.controller.ts` 路由的基本控制器，就是操作逻辑的地方，处理请求响应。  \n`app.module.ts` 应用程序的根模块。  \n`app.service.ts` 写数据库查询语句的地方。  \n`main.ts` 应用程序的入口文件，它使用核心函数`NestFactory`创建一个 Nest 应用程序实例。\n\n## 三.创建一个接口模块，处理请求\n\n为了快速创建内置[验证的 CRUD 控制器，您可以使用 CLI 的](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.nestjs.com%2Ftechniques%2Fvalidation \"https://docs.nestjs.com/techniques/validation\")[CRUD 生成器](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.nestjs.com%2Frecipes%2Fcrud-generator%23crud-generator \"https://docs.nestjs.com/recipes/crud-generator#crud-generator\")：`nest g resource [name]`。\n\n这里根据官方文档提示创建cats模块\n\n```\nnest g resource cats\n```\n\n选择 REST API风格。\n\n好了，现在src文件目录下多了cats目录，赶紧看看吧。\n\n诶，我们是创建了cats模块了，我们有使用吗，有的，在哪里使用了呢？在`应用程序的根模块里`使用了啊，哦，原来使用`nest g resource cats`命令创建时，同时使用了，真方便，ok快去看看吧。\n\n## 四.看看cats模块有啥吧\n\n### 1.先看controller吧，请求方法都在这了\n\n首先，映入眼帘的是头部引入了很多很多......啥，不知道是啥。  \n接下去看吧，有一个`@Controller(\'cats\')`，这是个装饰器，里面有个参数喔，估计是路由前缀吧，接着看有几个@开头的 post、get、delete的东东，应该是接口方法，嗯，是的，我们去用APIFox请求一下\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/014b45651170439cb2e577b50805f1eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 我这个get请求返回了“This action returns all cats”，这不是我写的啊，在哪里的，走，去看看。\n\n```\n@Get()\nfindAll() {\n    return this.catsService.findAll();\n}\n```\n\n大哥，我在controller找到这么个玩意，是个service方法耶，让我按着我的Ctrl键点击findAll进去看看先。进到了`cats.service.ts`文件，里面有一个`findAll`方法，返回了一串英文，我不懂英文喔，改改才行，`我是个大帅b！！！`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd69f6e59124ab2ac55b90a25027d67~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n### 2.你这地址有点单调啊，能不能接收query参数的？\n\n肯定能啊  \n那行，我给你传个?sex=1，你返回个`女`字给我。  \n这还不简单？ 先在controller头顶哪里的`@nestjs/common`导入 `Req`  \n然后使用\n\n```\n// 导入类型\nimport { Request } from \'express\';\n\n@Get()\n  findAll(@Req() req: Request): string {\n    console.log(\'req:\', req.query);\n\n    return this.catsService.findAll(req.query.sex as string);\n  }\n  \n ps: 这里获取参数其实可以用 @Query，不知道咋的用了上面这种，哈哈哈\n```\n\n这时候，我打印出了所有的query参数。就差给他返回`女`字了。\n\n```\ncats.service.ts\n\nfindAll(sex: string) {\n    const sexObj = {\n      \'0\': \'男\',\n      \'1\': \'女\',\n    };\n    return sexObj[sex];\n  }\n```\n\n写好了，赶紧在APIFox看看结果。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdea6ffab0144c9d9aed2cc356c9509d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n返回结果正确，我还想在post请求传param参数给你，传传传，传你个头头，好吧，那我想查数据库，总行了吧。\n\n## 五.连接mysql数据库\n\n先安装管理数据库`typeorm`和连接数据库`mysql2`库\n\n```\nnpm install --save @nestjs/typeorm typeorm mysql2\n```\n\n然后在`app.module.ts`添加配置\n\n```\nimport { Module } from \'@nestjs/common\';\nimport { TypeOrmModule } from \'@nestjs/typeorm\';\nimport { AppController } from \'./app.controller\';\nimport { AppService } from \'./app.service\';\nimport { CatsModule } from \'./cats/cats.module\';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: \'mysql\',\n      host: \'127.0.0.1\',\n      port: 3306,\n      username: \'root\',\n      password: \'root\',\n      database: \'blog\',\n      entities: [\'dist/**/*.entity{.ts,.js}\'],\n      synchronize: true,\n    }),\n    CatsModule,\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n```\n\n好了，数据库连接成功。  \n我们现在是用`typeorm`来管理数据库，这个库是通过实体来映射到数据库表的，建表我们以前是直接在数据库中创建表结构，现在我们通过实体来创建库。什么意识呢？接下来一起尝试。  \n在cats文件夹下，有一个`entities`文件夹，用来放实体的，点开，发现有个ts文件，没错我们就是在这个ts文件来写实体，也就是数据库表结构。\n\n我写了这些东西：\n\n```\nimport { Column, Entity, PrimaryGeneratedColumn } from \'typeorm\';\n\n// 建立一个实体映射到数据库表\n@Entity(\'cats\')\nexport class Cat {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ length: 10 })\n  name: string;\n}\n```\n\n@Entity(\'cats\')用来修饰说，我这个类是一个实体啊，名字叫`cats`，其中有字段：id、name，你按照这个结构，在mysql中创建一个表吧。我们打开数据库，看下是不是创建了一个叫cats的表呢。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b5ded505e742a39e55180d315a3007~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 好，没什么问题，可以映射。我们再添加一个`desc`字段试试\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c44e364349cf43a691a7f5bc758bd3f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 没毛病。\n\n## 六.操作数据库\n\n实体有了，怎么使用呢？  \n我们操作数据库正常情况下都是在service中，那么就是去service中使用即可，直接贴代码，我们向数据库中插入一条数据\n\n```\nimport { Injectable } from \'@nestjs/common\';\nimport { InjectRepository } from \'@nestjs/typeorm\';\nimport { Repository } from \'typeorm\';\nimport { CreateCatDto } from \'./dto/create-cat.dto\';\nimport { UpdateCatDto } from \'./dto/update-cat.dto\';\nimport { Cat } from \'./entities/cat.entity\';\n\n@Injectable()\nexport class CatsService {\n  constructor(\n    @InjectRepository(Cat)\n    private readonly catRepository: Repository<Cat>,\n  ) {}\n\n  async create(createCatDto: Partial<CreateCatDto>): Promise<Cat> {\n    console.log(createCatDto);\n    return this.catRepository.save(createCatDto);\n  }\n}\n```\n\n啊哈，保存的时候报错了，说什么实体没有引用，那么我们就引用它，在`cats.module.ts`\n\n```\nimport { Module } from \'@nestjs/common\';\nimport { CatsService } from \'./cats.service\';\nimport { CatsController } from \'./cats.controller\';\nimport { TypeOrmModule } from \'@nestjs/typeorm\';\nimport { Cat } from \'./entities/cat.entity\';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([Cat])],\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class CatsModule {}\n\n```\n\nservice写好了，但是还没调用它呢，去哪里调用啊，controller啊，这么快就忘记了吗。\n\n```\nimport {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  Req,\n} from \'@nestjs/common\';\nimport { CatsService } from \'./cats.service\';\nimport { CreateCatDto } from \'./dto/create-cat.dto\';\nimport { UpdateCatDto } from \'./dto/update-cat.dto\';\nimport { Request } from \'express\';\n\n@Controller(\'cats\')\nexport class CatsController {\n  constructor(private readonly catsService: CatsService) {}\n\n  @Post(\'/create\')\n  create(@Body() createCatDto: CreateCatDto) {\n    console.log(createCatDto);\n    return this.catsService.create(createCatDto);\n  }\n}\n```\n\n细心的盆友发现了，说你这`CreateCatDto`哪里来的？你看看cats目录下有一个dto文件夹，有个`create-cat.dto.ts`，它就是从这里来的，哈哈哈\n\n```\nexport class CreateCatDto {\n  name: string;\n  desc: string;\n}\n```\n\n好啦好啦，去ApiFox看下结果\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f67692b28164837b53c3458d5940ef5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n发送请求，OK，没报错，我们去数据库瞧瞧，有没有数据\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eab4fc784784742ba171595191008f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n牛逼啊，大哥，原来写接口这么简单啊！！！  \n感谢观看！！！\n\n## 七.中间件你应该了解过吧，在这里应该怎么用呢\n\n老规矩先创建对应的文件，nestjs有快捷创建中间件的命令呢\n\n```\nnest g middleware middleware/reqMi\n```\n\n我创建了一个middleware目录下的叫`reqMi`中间件，命名吗，简单了点。  \n好，看看中间件现在有什么\n\n```\nimport { Injectable, NestMiddleware } from \'@nestjs/common\';\n\n@Injectable()\nexport class ReqMiMiddleware implements NestMiddleware {\n  use(req: any, res: any, next: () => void) {\n    console.log(\'你好，我是中间件\');\n    next();\n  }\n}\n```\n\n我这里打印了一句话。 那么怎么调用呢？调用中间件有很多种方式，可以参考官方文档哦。  \n我现在是在`app.module.ts`调用\n\n```\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(ReqMiMiddleware).forRoutes(\'cats\');\n  }\n}\n```\n\n`ReqMiMiddleware`被调用啦，forRoutes(\'cats\')，表示为路由为cats前缀的路由添加这个中间件，nestjs中间件，都是通过匹配路由路径来调用的，[官方有比较详细的介绍](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.nestjs.com%2Fmiddleware \"https://docs.nestjs.com/middleware\")。 我们现在去看看，是不是调用成功了呀。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b7127d29c4f481889d1ecbc8bef92de~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n控制台打印\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff9d5c3d2e3e4efea2cd64e009dcd18e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\nok，中间件应用成功啦。\n\n## 八.当我们的程序出现异常的时候，该怎么办呢？\n\n> 那么就轮到异常过滤器（Exception filters）出场了。\n\nNest附带了一个内置`异常层`，负责处理整个应用程序中所有未处理的异常。当您的应用程序代码不处理异常时，它会被此层捕获，然后该层会自动发送适当的响应给客户端。  \n我们现在抛出一个异常看看，会发生什么\n\n```\nimport { HttpException, HttpStatus } from \'@nestjs/common\';\n\ncreate(@Body() createCatDto: CreateCatDto) {\n    console.log(createCatDto);\n    // 抛出 http异常\n    throw new HttpException(\'Forbidden\', HttpStatus.FORBIDDEN);\n    return this.catsService.create(createCatDto);\n  }\n```\n\n客户端请求，返回\n\n```\n{\n    \"statusCode\": 403,\n    \"message\": \"Forbidden\"\n}\n```\n\n接下来我们创建一个通用的异常过滤器\n\n```\nnest g filter filter/http-exception\n```\n\n那么现在src文件夹下，就多了一个filter文件夹，里面有一个`http-exception.filter.ts`文件，就是接下来要操作的文件了。\n\n```\nimport {\n  ArgumentsHost,\n  Catch,\n  ExceptionFilter,\n  HttpException,\n} from \'@nestjs/common\';\n\nimport { Request, Response } from \'express\';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n    \n    // 响应给客户端的结构,你也可以自定义结构,像这种 { code: 1, msg: \"\" }\n    // 我通常用0和1来判断请求是否正确，可以判断status是否等于200 来返回status = 1或0\n    response.status(status).json({\n      status: status,\n      msg: \'\',\n      timestamp: new Date().toISOString(),\n      path: request.url,\n    });\n  }\n}\n```\n\n官方文档给出了上面这个示例，好了，异常过滤器有了，怎么用呢？\n\n1.给某个路由使用\n\n```\ncats.controller.ts\n\n@Get()\n@UseFilters(new HttpExceptionFilter())\nfindAll() {\n    throw new UnauthorizedException();\n    return this.catsService.findAll();\n}\n```\n\n2.为整个controller使用\n\n```\n@Controller(\'cats\')\n@UseFilters(new HttpExceptionFilter())\nexport class CatsController {}\n```\n\n3.全局范围内使用\n\n```\nimport { NestFactory } from \'@nestjs/core\';\nimport { AppModule } from \'./app.module\';\nimport { HttpExceptionFilter } from \'./filter/http-exception.filter\';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // 全局异常过滤器\n  app.useGlobalFilters(new HttpExceptionFilter());\n  await app.listen(3000);\n}\nbootstrap();\n```\n\n好了，异常过滤器，我们会用啦，就是有异常（比如：客户端参数传错了，空参数，类型错误...）我们就用 `throw`抛出一个响应值给客户端。细心的盆友发现了，说，你这个`throw`后面跟着的是啥啊？  \n这个其实是 Nest 提供的标准异常继承自`HttpException`。这些是从`@nestjs/common`包中公开的，代表了许多最常见的 HTTP 异常：401，403...这些，官方文档有提到，[点这里查看](https://link.juejin.cn/?target=https%3A%2F%2Fnestjs.bootcss.com%2Fexception-filters \"https://nestjs.bootcss.com/exception-filters\")去到文档，向下滚动就能看到了。\n\n## 九.管道(参数验证)\n\n快捷创建管道文件\n\n```\n nest g pipe validation pipe\n```\n\n安装相关包\n\n```\nnpm i --save class-validator class-transformer\n```\n\n使用\n\n```\ncreate-cat.dto.ts\n\nimport { IsString } from \'class-validator\';\n\nexport class CreateCatDto {\n  @IsString()\n  name: string;\n\n  @IsString()\n  desc: string;\n}\n\n```\n\n```\nvalidation.pipe.ts\n\nimport {\n  PipeTransform,\n  Injectable,\n  ArgumentMetadata,\n  BadRequestException,\n} from \'@nestjs/common\';\nimport { validate } from \'class-validator\';\nimport { plainToInstance } from \'class-transformer\';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    console.log(\'----\');\n\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException(\'Validation failed\');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n\n```\n\n全局使用\n\n```\nmain.ts\n\nimport { ValidationPipe } from \'@nestjs/common\';\nimport { NestFactory } from \'@nestjs/core\';\nimport { AppModule } from \'./app.module\';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(new ValidationPipe());\n  await app.listen(3000);\n}\nbootstrap();\n\n```\n\n## 十.拦截器 Interceptors\n\n拦截器具有一组有用的功能，这些功能的灵感来自[面向方面的编程](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAspect-oriented_programming \"https://en.wikipedia.org/wiki/Aspect-oriented_programming\")（AOP）技术。它们使以下几点成为可能：\n\n-   在方法执行之前/之后绑定额外的逻辑\n-   转换从函数返回的结果\n-   转换从函数引发的异常\n-   扩展基本函数行为\n-   根据特定条件完全覆盖函数（例如，用于缓存目的）\n\n快捷创建拦截器，创建一个名为`transform`的拦截器\n\n```\nnest g interceptor interceptor/transform\n```\n\n## 十一.Websocket\n\n要开始构建基于 WebSockets 的应用程序，首先安装所需的包：\n\n```\n$ npm i --save @nestjs/websockets @nestjs/platform-socket.io\n$ npm i --save-dev @types/socket.io\n或者\n$ npm i --save @nestjs/websockets @nestjs/platform-socket.io\n```\n\n执行命令创建相应文件\n\n```\nnest g gateway  gateway/chat\n```\n\n## 十二.表关联查询\n\n比如我有一个category表和emoticon表\n\n```\nimport { Emoticon } from \'src/emoticon/entities/emoticon.entity\';\nimport { Column, Entity, OneToMany, PrimaryGeneratedColumn } from \'typeorm\';\n\n@Entity(\'category\')\nexport class Category {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  // 类目名称\n  @Column({ length: 5 })\n  name: string;\n\n  @OneToMany(() => Emoticon, (emoticon) => emoticon.category)\n  emoticon: Emoticon[];\n}\n```\n\n```\nimport { Category } from \'src/category/entities/category.entity\';\nimport { Column, Entity, ManyToOne, PrimaryGeneratedColumn } from \'typeorm\';\n\n@Entity(\'emoticon\')\nexport class Emoticon {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  // 图片名称\n  @Column({ length: 10 })\n  name: string;\n\n  // 图片地址\n  @Column()\n  imgUrl: string;\n\n  @ManyToOne(() => Category, (category) => category.emoticon)\n  category: Category;\n}\n```\n\n查询分类\n\n```\nfindAll() {\n    return this.categoryRepository.find({ relations: [\'emoticon\'] });\n}\n```\n\n结果\n\n```\n[\n    {\n        \"id\": 2,\n        \"name\": \"眼睛\",\n        \"emoticon\": [\n            {\n                \"id\": 7,\n                \"name\": \"测试\",\n                \"imgUrl\": \"https://gz.bcebos.com/te/hello-1670471717579.jpeg\"\n            }\n        ]\n    },\n]\n```', 'public/uploads/1694355066534.png', 3, 4, 1, 475, '2023-09-10 14:11:21', 1);
INSERT INTO `article` VALUES (102, 3, '外国大佬如何看待前端将“死”？', '像这样现象级的能力出现，都会对于Web开发者带来很多的关注和危机感。2000年代是WordPress，2010年代是Webflow，2020年代是”no code“工具。\r\n\r\n确实，Web开发人员已经开始过时了，现在很多简单的网站建设都不再需要Web开发者了，例如一个实体行业想要自己做个网站，他们不再需要自己找开发做，直接在SquareSpace上面定期付费使用其中的某个模版即可。\r\n\r\n但是，即使这样Web开发者到如今还是存在着。', NULL, 1, 3, 0, 1001, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (103, 1, '11', '21', '31', 4, 5, 1, 2, '2023-05-06 15:44:04', 0);
INSERT INTO `article` VALUES (104, 2, NULL, NULL, NULL, 1, 4, 1, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (105, 3, NULL, NULL, NULL, 1, 3, 0, 1, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (106, 3, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (107, 5, NULL, NULL, NULL, 1, 1, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (108, 2, NULL, NULL, NULL, 1, 1, 3, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (109, 2, NULL, NULL, NULL, 1, 8, 2, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (110, 2, NULL, NULL, NULL, 1, 4, 0, 2, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (111, 2, NULL, NULL, NULL, 1, 3, 2, 1, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (112, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (113, 2, NULL, NULL, NULL, 1, 2, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (114, 2, NULL, NULL, NULL, 1, 6, 1, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (115, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (116, 2, NULL, NULL, NULL, 1, 4, 3, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (117, 2, NULL, NULL, NULL, 1, 5, 2, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (118, 2, NULL, NULL, NULL, 1, 7, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (119, 2, NULL, NULL, NULL, 1, 6, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (120, 2, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (121, 2, NULL, NULL, NULL, 1, 2, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (122, 2, NULL, NULL, NULL, 1, 7, 1, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (123, 2, '这么装13的TS用法，我还是第一次见！', '这么装13的 TS 用法，我劝你别在项目里面使用，除非你够皮。\n\n废话不多说，直接看题目\n\n> 将给定字符串类型 `QueryStr` 类型通过 `Split` 解析为键值结构类型。\n\n![](http://127.0.0.1:3000/public/uploads/1697706391281.png)\n\n\n## 分析\n\n### js\n\n如果这是面试题，我可能会突然肚子有点不舒服，TS 类型搞不定，换成 js 应该没什么问题吧？\n\n```\nconst queryStr = \'name=kn&sex=f&language=ts\';\n\nconst splitStr = queryStr.split(\'&\');\n\nconst queryKeyValue = {};\n\nsplitStr.forEach( str =>{\n  const [key, value] = str.split(\'=\');\n  queryKeyValue[key] = value;\n})\nconsole.log(queryKeyValue); // {name: \'kn\', sex: \'f\', language: \'ts\'}\n```\n\n### TS type\n\n从 js 的实现来看，里面主要用到了 `split` 和遍历，TS 如何实现呢？\n\n这里会引入一个日常开发中很少见的 TS 用法 infer，infer 最早出现在这个 [PR](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FTypeScript%2Fpull%2F21496 \"https://github.com/Microsoft/TypeScript/pull/21496\") 中，表示在 extends 条件语句中待推断的类型变量，`如果对泛型还不理解的同学，建议先去看下 TS 基础再回来` 。\n\n```\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : T;\n```\n\n作者给的示例是用于获取返回值类型，如何使用呢？先分析类型定义，当我们传入的 T 满足 (...args: any\\[\\]) => type 时，我们得到的类型就是 type。\n\n如下，因为我们传入的 T `(params: string) => number`，是满足需求的，所以最终推断出来的 count 类型是 type，也即是 number。\n\n```\nconst count: ReturnType<(params: string) => number> = 1\n```\n\n再看个简单的示例：\n\n```\ntype IType<T> = T extends Array<infer S> ? S[] :T  \n\nconst str: IType<string> = \'a\'; // string\nconst arr: IType<Array<string>> = [\'a\', \'b\']; // string[]\n```\n\n回到正题，我们逐步分解：\n\n```\n  type QueryStr = \'name=kn&sex=f&language=ts\';\n  \n  type Split<T> = T extends `${infer Left}&${infer Right}` ? [Left, ...Split<Right>] : [T]\n  \n  type QueryKeyValue = Split<QueryStr>; //[\"name=kn\", \"sex=f\", \"language=ts\"]\n```\n\n通过这步，我们得到了类似 js `str.split(\'&\')` 的效果，细心的你也许已经注意到，我们在里面用到了递归的思想。\n\n下一步是如何将 `[\"name=kn\", \"sex=f\", \"language=ts\"]` 转换为 `[{name: \"kn\";},xx]`？\n\n```\n\n  type StrToKeyValue<T> = T  extends `${infer Left}=${infer Right}` ? {[key in Left]: Right} : T\n\n  type KeyValueTuple<T> = T extends [infer Left, ...infer Right] ? [StrToKeyValue<Left>, ...KeyValueTuple<Right>] : T\n  \n  type QueryKeyValue = KeyValueTuple<Split<QueryStr>>; // [{name: \"kn\";},{sex: \"f\";},{language: \"ts\";}]\n```\n\n这步完成之后，其实剩下的就简单了，这里提醒大家一个点，`type IQuery = {name: string; age: number}` 和 `type IQuery = {name: string} & {age: number}` 是等价的。\n\n```\ntype TupleToIntersection<T> = T extends [infer Left, ...infer Right] ? Left & TupleToIntersection<Right>  : unknown\ntype QueryKeyValue = TupleToIntersection<KeyValueTuple<Split<QueryStr>>>\n```\n\n至此，如此复杂（变态）的类型转换完成，我们验证一下。\n\n```\n  const queryKeyValue: QueryKeyValue  = {\n    name: \'kn\',\n    sex: \'f\',\n    language: \'ts\'\n  }\n```\n\n发现并没有 TS 语法错误，鼠标移动到 `QueryKeyValue` 上也能看到对应类型\n\n![](http://127.0.0.1:3000/public/uploads/1697706411990.png)\n\n\n## 总结\n\n看完有没有后背发凉，赶紧手写试试吧，上面为了分解步骤，写的有点复杂了，我们看下优化后的代码。\n\n```\n/**\n * TS 装13用法\n *\n * eg：\n *  type QueryStr = \'name=kn&sex=f&language=ts\'\n *\n *  ........ split 解析 .......\n *\n *  type QueryKeyValue = Split<QueryStr>\n *\n *  ........ res .........\n *\n *  type QueryKeyValue = {\n *    name: \'kn\';\n *    sex: \'f\';\n *    language: \'ts\';\n *  }\n */\n\ntype QueryStr = \'name=kn&sex=f&language=ts\';\n\ntype Split<T> = T extends `${infer Left}&${infer Right}` ? [Left, ...Split<Right>] : [T];\n\ntype TupleStrToIntersection<T> = T extends [`${infer Left}=${infer Right}`, ...infer Rest]\n  ? { [key in Left]: Right } & TupleStrToIntersection<Rest>\n  : unknown;\n\ntype QueryKeyValue = TupleStrToIntersection<Split<QueryStr>>;\n```', '', 2, 2, 0, 6, '2023-10-19 09:07:39', 1);
INSERT INTO `article` VALUES (124, 2, NULL, NULL, NULL, 1, 5, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (125, 2, NULL, NULL, NULL, 1, 5, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (126, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (127, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (128, 2, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (129, 2, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (130, 2, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (131, 2, NULL, NULL, NULL, 1, 2, 2, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (132, 2, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (133, 2, NULL, NULL, NULL, 1, 1, 2, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (134, 2, NULL, NULL, NULL, 1, 2, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (135, 2, '1', '## 前言\r\n\r\n下面20道题是笔者最近在面试里遇到的和在牛客看到的，希望对大家有帮助~\r\n\r\n## 1\\. LRU算法（快手）\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b1c8a53b83142328f7777e6ed538b76~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)\r\n\r\n```\r\nvar LRUCache = function (capacity) {\r\n  this.catch = new Map()  //初始化map数据结构\r\n  this.capacity = capacity  //容量\r\n};\r\n\r\nLRUCache.prototype.get = function (key) {\r\n  if (this.catch.has(key)) {   //map中有这个元素\r\n    let value = this.catch.get(key);  //调用map的get方法获取元素\r\n    //更新key=>value\r\n    this.catch.delete(key);  //删除之前的元素\r\n    this.catch.set(key, value);  //将新获取的相同的元素以键值对推入map中\r\n\r\n    return value   //返回关键字的值\r\n  }\r\n  return -1  //map中没有这个元素返回-1\r\n};\r\n\r\nLRUCache.prototype.put = function (key, value) {\r\n  if (this.catch.has(key)) {  //有这个元素\r\n    this.catch.delete(key);  //删除\r\n  }\r\n\r\n  //判断有没有达到存储的阈值\r\n  if (this.catch.size >= this.capacity) {\r\n    //移除谁 再放新值  \r\n    //m.keys().next()拿到首位的键值对\r\n    this.catch.delete(this.catch.keys().next().value)\r\n  }\r\n  this.catch.set(key, value);\r\n};\r\n\r\n//验证\r\nlet lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // 缓存是 {1=1}\r\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\r\nlRUCache.get(1);    // 返回 1\r\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\r\n```\r\n\r\n实现思路：\r\n\r\n-   构造函数内定义一个`Map`数据类型存放catch和`capacity`设置最大存放数\r\n-   `put`方法是进行存放，如果已经存放了这个`key`和`value`，那么进行删除，再判断有没有超过阈值，如果超出了，进行删除首个元素，再存放，没有超过，那么进行直接存放\r\n-   `get`方法是进行catch的获取，如果有这个元素，那么进行先删除后存放，如果没有，直接返回-1表示不存在\r\n\r\n## 2\\. 版本号排序（字节）\r\n\r\n```\r\nconst versions = [\"1.2.1\", \"1.0.2\", \"1.3.2\", \"1.1\", \"1.2\", \"1\", \"1.10.0\"]; \r\n// 升序排序 \r\nversions.sort(compareVersion); \r\nconsole.log(versions); // [\"1\", \"1.0.2\", \"1.1\", \"1.2\", \"1.2.1\", \"1.3.2\", \"1.10.0\"] \r\n// 降序排序 \r\nversions.sort((a, b) => compareVersion(b, a)); \r\nconsole.log(versions); // [\"1.10.0\", \"1.3.2\", \"1.2.1\", \"1.2\", \"1.1\", \"1.0.2\", \"1\"]\r\n\r\nconst compareVersion = function(version1, version2){\r\n    const arr1 = version1.split(\'.\');// 得到的是字符串数组\r\n    const arr2 = version2.split(\'.\');\r\n    // 获取最大长度，进行比较\r\n    const len = Math.max(arr1.length, arr2.length);\r\n    for(let i = 0; i < len; i++){\r\n        // 要进行长度的比较判断\r\n        const num1 = i > arr1.length ? 0 : parseInt(arr1[i]);\r\n        const num2 = i > arr2.length ? 0 : parseInt(arr2[i]);\r\n        if(num1 > num2){\r\n            return 1;\r\n        }else if(num1 < num2){\r\n            return -1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n实现思路：\r\n\r\n-   进行sort方法的重构，升序还是降序，调换参数的顺序即可\r\n\r\n## 3\\. 最长公共前缀（快手）\r\n\r\n[最长公共前缀 - 力扣（LeetCode）](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flongest-common-prefix%2Fdescription%2F \"https://leetcode.cn/problems/longest-common-prefix/description/\")\r\n\r\n```\r\nfunction longestCommonPrefix(strs){\r\n    if(strs.length === \'\') return \'\';\r\n    // 先赋值，后不断缩小\r\n    const prefix = strs[0];\r\n    for(let i = 0; i < strs.length; i++) {\r\n        while(strs[i].indexOf(prefix) !== 0){\r\n            prefix.slice(0, prefix.length - 1);\r\n            if(prefix = \'\') return \'\';\r\n        }\r\n    }\r\n    return prefix;\r\n}\r\n```\r\n\r\n-   关键在于`String.prototype.indexOf()`的理解，如果在其中，则返回0\r\n\r\n## 4.大数相加（快手）\r\n\r\n```\r\nfunction addStrings(num1, num2){\r\n  let i = num1.length - 1; // 初始化指向 num1 的末位的指针 i\r\n  let j = num2.length - 1; // 初始化指向 num2 的末位的指针 j\r\n  let carry = 0; // 初始化进位为 0\r\n  let result = \'\'; // 初始化结果字符串为空字符串\r\n  while (i >= 0 || j >= 0 || carry !== 0) { // 当还有数字或者存在进位时，继续执行循环\r\n    // parseInt() 函数来将字符串转换为数字\r\n    const digit1 = i >= 0 ? parseInt(num1[i]) : 0; // 取出 num1 当前位上的数字，如果越界了就用 0 补齐\r\n    const digit2 = j >= 0 ? parseInt(num2[j]) : 0; // 取出 num2 当前位上的数字，如果越界了就用 0 补齐\r\n    const sum = digit1 + digit2 + carry; // 计算当前位上的数字和\r\n    result = (sum % 10).toString() + result; // 将该位上的数字插入到结果字符串的最前面\r\n    carry = Math.floor(sum / 10); // 计算进位\r\n    i--; // 将指针 i 向前移动一位\r\n    j--; // 将指针 j 向前移动一位\r\n  }\r\n  return result; // 返回结果字符串\r\n}\r\n```\r\n\r\n思路：\r\n\r\n-   处理两个字符串相加后的结果\r\n-   需要两个指针i,j进行指向，对每一位的字符进行加减，carry变量进行处理进位，res存储结果\r\n-   进入循环，当存在进位或者指针存在则继续循环\r\n    -   拿到字符(可能已经超出了，给0)\r\n    -   进行相加并且要带上上次的进位数字\r\n    -   将个位数进行插入到前面（记得toString()）\r\n    -   更新进位数，移动指针\r\n\r\n## 5.手撕开平方（商汤科技）\r\n\r\n```\r\nfunction sqrt(s, precision = 16){\r\n    if(s === 0 || s === 1){\r\n        return s;\r\n    }\r\n    // 计算精度值\r\n    const percisionValue = Math.pow(10, -precision)\r\n    // 二分查找进行匹配\r\n    let low = 0;\r\n    let hight = s;\r\n    while(hight - low >= precisionValue){\r\n        let mid = (hight + low) / 2;\r\n        if(mid * mid === s){\r\n            // 当可以开整数平方时\r\n            return mid;\r\n        }else if(mid * mid < hight){\r\n            hight = mid;\r\n        }else {\r\n            low = mid;\r\n        }\r\n    }\r\n    // 当无法开整数平方时\r\n    return low.toFixed(precision);\r\n}\r\n```\r\n\r\n实现关键：\r\n\r\n-   计算精度：Math.pow(10, -n)\r\n-   处理小数：.toFixed(n)\r\n\r\n## 6.前k个频率高的元素（滴滴）\r\n\r\n[前 K 个高频元素 - 力扣（LeetCode）](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Ftop-k-frequent-elements%2F \"https://leetcode.cn/problems/top-k-frequent-elements/\")\r\n\r\n```\r\nconst toKFrequent = function(nums, k){\r\n    const Map = new Map();\r\n    for(let num of nums){\r\n        Map.set(num, (Map.get(num) || 0) + 1)\r\n    }\r\n    // 插入桶里\r\n    const bucket = [];\r\n    for(let [key, value] of Map){\r\n        if(!bucket[value]){\r\n            bucket[value] = [];\r\n        }\r\n        bucket[value].push(num);\r\n    }\r\n    // 从桶里拔出来\r\n    const res = [];\r\n    for(let i = bucket.length - 1; i > 0 && res.length < k; i++){\r\n        if(bucket[i]){\r\n            res.push(...bucket[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n## 7.三数之和（字节）\r\n\r\n```\r\nfunction threeSum(nums) {\r\n  const result = [];\r\n\r\n  if (nums.length < 3) {\r\n    return result;\r\n  }\r\n\r\n  nums.sort((a, b) => a - b); // 排序\r\n\r\n  for (let i = 0; i < nums.length - 2; i++) {\r\nif(nums[i] > 0) return result;\r\n    if (i > 0 && nums[i] === nums[i - 1]) {\r\n      continue; // 跳过重复的元素\r\n    }\r\n\r\n    let left = i + 1;\r\n    let right = nums.length - 1;\r\n\r\n    while (left < right) {\r\n      const sum = nums[i] + nums[left] + nums[right];\r\n\r\n      if (sum === 0) {\r\n        result.push([nums[i], nums[left], nums[right]]);\r\n        left++;\r\n        right--;\r\n\r\n        while (left < right && nums[left] === nums[left - 1]) {\r\n          left++; // 跳过重复的元素\r\n        }\r\n        while (left < right && nums[right] === nums[right + 1]) {\r\n          right--; // 跳过重复的元素\r\n        }\r\n      } else if (sum < 0) {\r\n        left++;\r\n      } else {\r\n        right--;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n```\r\n\r\n## 8.用栈实现队列\r\n\r\n```\r\nfunction MyQueue(){\r\n// 定义的两个栈\r\nthis.stackIn = [];\r\nthis.stackOut = [];\r\n}\r\n// 入列\r\nMyQueue.prototype.push = function(x){\r\nthis.stackIn.push(x);\r\n}\r\n// 出列\r\nMyQueue.prototype.pop = function(x){\r\n// 检测出栈的内容\r\nconst size = this.stackOut.length;\r\nif(size) return this.stack.pop();\r\nwhile(this.stackIn.length){\r\n// 把入栈的元素都放入出栈里面\r\nthis.stackOut.push(this.stackIn.pop());\r\n}\r\n// 返回出栈的元素\r\nreturn this.stackOut.pop()\r\n}\r\n// 获取列首位置\r\nMyQueue.prototype.peek = function(){\r\nconst x = this.pop();\r\nthis.stackOut.push(x);\r\nreturn x;\r\n}\r\n// 判断是否为空\r\nMyQueue.prototype.empty(){\r\nreturn !this.stackIn.length && !this.stackOut.length;\r\n}\r\n```\r\n\r\n## 9.用队列实现栈\r\n\r\n```\r\nfunction MyStack(){\r\nthis.queue = [];\r\n}\r\n// 入栈\r\nMyStack.prototype.push = function(){\r\nthis.queue.push(x);\r\n}\r\n// 出栈\r\nMyStack.prototype.pop = function(){\r\nlet size = this.queue.length;\r\n  // 倒转过来\r\nwhile(size-- > 1){\r\n     this.queue.push(this.queue.shift())\r\n}\r\nreturn this.queue.shift();\r\n}\r\n// 拿到栈顶元素\r\nMyStack.prototype.top = function() {\r\n    // 弹出再压进去\r\n    const x = this.pop();\r\n    this.queue.push(x);\r\n    return x;\r\n};\r\nMyStack.prototype.empty = function() {\r\n    return !this.queue.length;\r\n};\r\n```\r\n\r\n## 10.队列的最大值（蔚来）\r\n\r\n```\r\nclass MaxQueue{\r\nconstuctor(){\r\nthis.queue = [];\r\nthis.max = [];\r\n}\r\nenqueue(el){\r\nthis.queue.push(el);\r\nwhile(this.max.length && this.max[this.length - 1] < el){\r\nthis.max.pop()\r\n}\r\nthis.max.push(el);\r\n}\r\ndequeue(){\r\nif(this.queue.length === 0) return -1;\r\nconst el = this.queue.shift();\r\nif(el === this.max[0]){\r\nthis.max.shift();\r\n}\r\nreturn el;\r\n}\r\ngetMax(){\r\nreturn max.length > 0 ? max[0] : -1\r\n}\r\n}\r\n```\r\n\r\n## 11.千分位分隔（字节）\r\n\r\n```\r\n// input：-123456.123\r\n// output：-123,456.123\r\n\r\nfunction thousandSeparator(n) {\r\n    let nStr = n.toString();\r\n    let [integerPart, decimalPart = \'\'] = nStr.split(\'.\');\r\n    if(integerPart[0] === \'-\'){\r\n        integerPart = integerPart.slice(1);// 切割索引为1后面的字符串，并返回，slice是不会改动原来字符串的\r\n    }\r\n    // 定义变量，进行存储添加,后的结果\r\n    let formattedIntegerPart = \'\';\r\n    // 进行反转添加\r\n    for (let i = integerPart.length - 1, count = 0; i >= 0; i--, count++) {\r\n      if (count === 3) {\r\n        formattedIntegerPart = \',\' + formattedIntegerPart;\r\n        count = 0;\r\n      }\r\n      formattedIntegerPart = integerPart[i] + formattedIntegerPart;\r\n    }\r\n    return (n < 0 ? \'-\' : \'\') + formattedIntegerPart + (decimalPart ? \'.\' + decimalPart : \'\');\r\n\r\n}\r\n\r\n```\r\n\r\n## 12.带并发限制的异步调度器Scheduler（百度）\r\n\r\n```\r\n// JS实现一个带并发限制的异步调度器Scheduler\r\n// 保证同时运行的任务最多有两个\r\n// 完善代码中Scheduler类\r\n// 使得以下程序能正确输出\r\n\r\nclass Scheduler {\r\n  constructor() {\r\n   this.count = 2\r\n   this.queue = []\r\n   this.run = []\r\n  }\r\n\r\n  add(task) {\r\n    \r\n  }\r\n  \r\n }\r\n \r\n const timeout = (time) => new Promise(resolve => {\r\n  setTimeout(resolve, time)\r\n })\r\n \r\n const scheduler = new Scheduler()\r\n const addTask = (time, order) => {\r\n  scheduler.add(() => timeout(time)).then(() => console.log(order))\r\n }\r\n \r\n addTask(1000, \'1\')\r\n addTask(500, \'2\')\r\n addTask(300, \'3\')\r\n addTask(400, \'4\')\r\n // output: 2 3 1 4\r\n \r\n // 一开始，1、2两个任务进入队列\r\n // 500ms时，2完成，输出2，任务3进队\r\n // 800ms时，3完成，输出3，任务4进队\r\n // 1000ms时，1完成，输出1\r\n // 1200ms时，4完成，输出4\r\n```\r\n\r\n解答：\r\n\r\n```\r\nclass Scheduler {\r\n  constructor() {\r\n   this.count = 0\r\n   this.queue = []\r\n  }\r\n\r\n  add(task) {\r\n    return new Promise((resolve) => {\r\n        const runTask = async() => {\r\n            this.count++;\r\n            await task();\r\n            reslove();// 任务完成，执行下面的\r\n            this.count--;\r\n            if(this.queue.length > 0){\r\n                const nextTask = this.queue.shift();\r\n                nextTask();\r\n            }\r\n        };\r\n        if(this.count < 2){\r\n            runtask();\r\n        }esle{\r\n            this.queue.push(runTask);\r\n        }\r\n    })\r\n  }\r\n }\r\n\r\n```\r\n\r\n## 13.BFS和DFS实现document.querySelectAll(\'.a\')(百度)\r\n\r\nDFS:\r\n\r\n```\r\nconst dfsFindNode = () => {\r\n    const res = [];\r\n    if(node && node.nodeType === 1){ // 判断当前节点是否为元素节点\r\n        if(/\\ba\\b/.test(node.className)){\r\n            res.push(node);\r\n        }\r\n        const children = node.children;// 获取当前节点的子节点元素列表\r\n        for(let i = 0; i < children.length; i++){\r\n            const child = children[i];\r\n            res.push(...dfsFindNode(child))\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nconst Nodes = dfsFindNode(document.body); // 查找 document.body 下所有 class 为 a 的元素节点\r\n\r\n```\r\n\r\nBFS:\r\n\r\n```\r\nfunction bfsFindNode(node) {\r\n  const res = []; // 存放符合条件的节点的数组\r\n  const queue = [node]; // 定义一个队列，初始值为根节点\r\n  while (queue.length > 0) { // 当队列不为空时进行遍历\r\n    const cur = queue.shift(); // 取出队头元素，并作为当前处理的节点\r\n    if (cur.nodeType === 1 && /\\ba\\b/.test(cur.className)) { // 判断当前节点是否为元素节点，并且其 class 属性是否包含 a\r\n      res.push(cur); // 如果符合条件，则将当前节点加入结果数组中\r\n    }\r\n    const children = cur.children; // 获取当前节点的所有子元素\r\n    for (let i = 0; i < children.length; i++) { // 遍历每个子元素\r\n      const child = children[i];\r\n      queue.push(child); // 将子元素加入队列尾部，等待被处理\r\n    }\r\n  }\r\n  return res; // 返回所有符合条件的节点组成的数组\r\n}\r\n\r\nconst Nodes = bfsFindNode(document.body); // 查找 document.body 下所有 class 为 a 的元素节点\r\n\r\n```\r\n\r\n## 14.数组去重(百度)\r\n\r\n```\r\n// api方法\r\nconst arr = [1,2,2,6,6]\r\nconst uniqueArr = [...new Set(arr)];\r\nconst uniqueArr = arr.filter((index, item) => {\r\n    return arr.indexOf(item) === index\r\n})\r\n// 原生实现\r\nfunction deduplicateArray(arr) {\r\n    const res = [];\r\n    for(let i = 0;i < arr.length;i++){\r\n        let isDuplicate = false;// 标记是否重复\r\n        for(let j = 0; j < arr.length; j++){\r\n            if(arr[i] === res[j]){\r\n                isDuplicate = ture;\r\n                break;\r\n            }\r\n        }\r\n        if(!isDuplicate){\r\n            res.push(arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n```\r\n\r\n## 15.两数相加（快手）\r\n\r\n[两数相加 - 力扣（LeetCode）](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fadd-two-numbers%2F%3FenvType%3Dfeatured-list%26envId%3D2cktkvj \"https://leetcode.cn/problems/add-two-numbers/?envType=featured-list&envId=2cktkvj\")\r\n\r\n本地idle实现所有功能：\r\n\r\n```\r\nclass Node {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nfunction arrayToLinkedList(arr) {\r\n  if (!Array.isArray(arr)) {\r\n    console.log(\"Input is not an array.\");\r\n    return null;\r\n  }\r\n\r\n  if (arr.length === 0) {\r\n    console.log(\"Array is empty.\");\r\n    return null;\r\n  }\r\n\r\n  let head = new Node(arr[0]);\r\n  let currentNode = head;\r\n\r\n  for (let i = 1; i < arr.length; i++) {\r\n    const newNode = new Node(arr[i]);\r\n    currentNode.next = newNode;\r\n    currentNode = newNode;\r\n  }\r\n\r\n  return head;\r\n}\r\nvar addTwoNumbers = function (l1, l2) { \r\n    // 创建虚拟头结点\r\n    const dummy = new Node(0);\r\n    let cur = dummy;\r\n\r\n    let carry = 0;\r\n    while (l1 || l2) {\r\n        const value1 = l1 ? l1.value : 0;\r\n        const value2 = l2 ? l2.value : 0;\r\n        // 相加\r\n        let sum = value1 + value2 + carry;\r\n        carry = Math.floor(sum / 10);\r\n        sum %= 10;\r\n        cur.next = new Node(sum);\r\n        cur = cur.next;\r\n        if (l1) l1 = l1.next;\r\n        if (l2) l2 = l2.next;\r\n    }\r\n    if (carry) {\r\n        cur.next = new Node(carry);\r\n    }\r\n    return dummy.next;\r\n}\r\n\r\n```\r\n\r\n16.  最长回文子序列 （小米）\r\n\r\n[最长回文子序列 - 力扣（LeetCode）](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flongest-palindromic-subsequence%2F \"https://leetcode.cn/problems/longest-palindromic-subsequence/\")\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst longestPalindromeSubseq = (s) => {\r\n    const strLen = s.length;\r\n    let dp = Array.from(Array(strLen), () => Array(strLen).fill(0));\r\n\r\n    for(let i = 0; i < strLen; i++) {\r\n        dp[i][i] = 1;\r\n    }\r\n\r\n    for(let i = strLen - 1; i >= 0; i--) {\r\n        for(let j = i + 1; j < strLen; j++) {\r\n            if(s[i] === s[j]) {\r\n                dp[i][j] = dp[i+1][j-1] + 2;\r\n            } else {\r\n                dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return dp[0][strLen - 1];\r\n};\r\n```\r\n\r\n17.  实现 promise.all （滴滴、蔚来）\r\n\r\n```\r\nconst promiseAll = (promises) => {\r\nif(typeof promises[Symbol.interator] === \'function\'){\r\nlet count = 0;\r\nlet result = [];\r\nreturn new Promise((reslove, reject) => {\r\nfor(const [index, item] of promises){\r\n// 保存每次执行的结果\r\nPromise.resolve(item).then((res) => {\r\nresult[index] = res;\r\ncount++;\r\nif(count === promises.lenth){\r\nreturn reslove(result);\r\n}\r\n}).catch(err => {\r\nreject(err);\r\n})\r\n}\r\n})\r\n}\r\n}\r\n```\r\n\r\n18.  实现 Promise.allSettled （快手）\r\n\r\n```\r\nfunction allSettled(promises){\r\nreturn new Promise((reslove, reject) => {\r\nconst result = [];\r\nlet count = 0;\r\nif(promises.length === 0){\r\nresolve(result);\r\nreturn;\r\n}\r\npromises.forEach((promise, index) => {\r\nPromise.resolve(promise)\r\n.then((value) => {\r\nresult[index] = { status: \'fulfilled\', value }\r\n})\r\n.catch((reson) => {\r\nresult[index] = { status: \'rejected\', reason }\r\n})\r\n.fianlly(() => {\r\ncount++;\r\nif(count === promise.length){\r\nresolve(results)\r\n}\r\n})\r\n})\r\n})\r\n}\r\n```\r\n\r\n19.  call、apply、bind（快手）\r\n\r\n```\r\n// call 方法的参数：对象，多个参数\r\nFunction.prototype.call = function(context, ...args){\r\nif(typeof this !== \'function\')\r\nreturn new TypeError(\'error\');\r\n// 确保不为空\r\ncontext = context || window;\r\nconst fn = Symbol(\'fn\');\r\ncontext[fn] = this;\r\nconst res = context[fn](...args);\r\ndelete context[fn];\r\nreturn res;\r\n}\r\n// apply方法的参数：对象，一个参数数组\r\nFunction.prototype.apply = (context, args) => {\r\nif(typeof this !== \'function\'){\r\nreturn new TypeError(\'error\');\r\n}\r\ncontext = context || window;\r\nconst fn = Symbol(\'fn\');\r\ncontext[fn] = this;\r\nconst res = context[fn](...args);\r\ndelete context[fn]\r\nreturn res;\r\n}\r\n// bind 是会返回一个函数,考虑到可能多次调用，那么就不进行删除\r\nFunction.prototype.bind = function(target, ...outArgs) {\r\nif(typeof this !== \'function\'){\r\nreturn new TypeError(\'error\');\r\n}\r\ntarget = target || window;\r\nconst fn = Symbol();\r\ntarget[fn] = this;\r\nreturn function(...moreArgs) {\r\nconst res = target[fn](...outArgs, ...moreArgs);\r\nreturn res;\r\n}\r\n}\r\n```\r\n\r\n20.  将下划线或中划线命名转换为驼峰命名（字节）\r\n\r\n```\r\nfunction toCamelCase(str){\r\n// 首先对于一个字符串的下划线或者中划线进行split(/[-_]/)分割成数组\r\nlet words = str.split(/[-_]/);\r\nlet res = str[0];// 给个初始值\r\nfor(let i = 1; i < words.length; i++){// 从 i = 1开始遍历即可\r\n// 拿到每个单词的第一个值，后面的切一刀连起来\r\n// toUpperCase()\r\nres += word[i][0].toUpperCase() + word[i].slice(1);\r\n}\r\nreturn res;\r\n}\r\n```', 'public/uploads/1693573274188.jpg', 4, 1, 0, 2, '2023-09-06 15:44:04', 1);
INSERT INTO `article` VALUES (136, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (137, 2, NULL, NULL, NULL, 1, 2, 1, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (138, 2, NULL, NULL, NULL, 1, 6, 2, 0, '2023-09-06 15:44:04', 0);
INSERT INTO `article` VALUES (139, 2, '1', '1', 'public/uploads/1693540266258.png', 2, 3, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (140, 3, NULL, NULL, NULL, 1, 4, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (141, 3, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (142, 3, NULL, NULL, NULL, 1, 3, 0, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (143, 3, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (144, 3, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-05 08:54:07', 0);
INSERT INTO `article` VALUES (145, 3, NULL, NULL, NULL, 1, 5, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (146, 2, NULL, NULL, NULL, 1, 4, 0, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (147, 2, NULL, NULL, NULL, 1, 2, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (148, 2, NULL, NULL, NULL, 1, 5, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (149, 2, NULL, NULL, NULL, 2, 2, 0, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (150, 2, NULL, NULL, NULL, 1, 3, 1, 0, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (151, 2, '1', '111', NULL, 3, 2, 0, 1, '2023-09-06 15:44:05', 0);
INSERT INTO `article` VALUES (152, 2, NULL, NULL, NULL, 1, 0, 1, 0, '2023-09-05 08:54:07', 0);
INSERT INTO `article` VALUES (153, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-05 08:54:07', 0);
INSERT INTO `article` VALUES (154, 2, NULL, NULL, NULL, 1, 0, 1, 0, '2023-09-05 08:54:07', 0);
INSERT INTO `article` VALUES (155, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-05 14:57:36', 0);
INSERT INTO `article` VALUES (156, 2, 'Swift 周报 第三十期', '## 前言\n\n**本期是 Swift 编辑组自主整理周报的第二十一期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。\n\n欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。\n\n求人不如求己，你多一样本领，就少一点啊乞求；**Swift社区**让你多一样技能，少一些嘲讽！\n\n> **周报精选**\n> \n> 新闻和社区：码出新宇宙，WWDC23 就在眼前\n> \n> 提案：有 4 个提案通过，本期没有产生新的提案\n> \n> Swift 论坛：PermutableCollection 协议\n> \n> 推荐博文：SwiftUI 中 LinearGradient的用法\n> \n> **话题讨论：**\n> \n> 有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？\n\n**上期话题结果**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d53ee4f26a64570ae323f12ef947028~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n上期话题讨论结果表明，**社交隔阂**和**个人选择标准的提高**是导致男女群体互不干涉的主要原因，而**社会观念的变化**也起到了一定的影响。这些因素共同作用导致了男群体和女群体相互独立地寻找伴侣的现象。\n\n## 新闻和社区\n\n### App、App 内购买项目和订阅即将实行税率调整\n\nApp Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的商店中，以 44 种货币为你的产品和服务便捷地进行定价与销售。Apple 会为开发者管理其中 70 多个国家和地区的税收，而且你还能够为 App 和 App 内购买项目分配税务类别。我们会根据税务法规的变化，定期更新你在某些地区的收益。\n\n从 5 月 31 日起，你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将进行调整，以反映以下税率调整。请注意，相关内容的价格将保持不变。\n\n加纳：增值税率从 12.5% 上调至 15%。 立陶宛：对于符合条件的电子书和有声书，增值税率从 21% 下调至 9%。 摩尔多瓦：对于符合条件的电子书和期刊，增值税率从 20% 下调至 0%。 西班牙：收取 3% 的数字服务税。 由于巴西税务法规的变化，在巴西开展的所有 App Store 销售现由 Apple 代扣税款。我们会按月代扣代缴应向相应税务机关缴纳的税款。自 2023 年 6 月开始，你可以在 5 月份的收入中查看从你的收益中扣除的税款金额。巴西境内的开发者不会受到这一变化的影响。\n\n以上调整生效后，App Store Connect 中“我的 App”的“价格与销售范围”部分会随即更新。一如既往，你可以随时更改你的 App 和 App 内购买项目的价格 (包括自动续期订阅)。现在，你可以从 900 个价格点中选择，为任何店面更改定价。\n\n### 码出新宇宙\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01050c3c551942fbb7214b96b090b2af~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nWWDC23 就在眼前。太平洋夏令时间 6 月 5 日上午 10 点，Apple 主题演讲将在 apple.com 和 Apple Developer App 线上提供，为本次大会拉开序幕。你还可以通过同播共享，邀请朋友一起观看。\n\n现在，符合条件的开发者可以开始报名参加活动了。相关活动包括 Q&A、“会见演讲者”以及社区暖场活动等线上聊天室活动，旨在促进你与开发者社区和 Apple 专家的沟通和交流。\n\n### Apple 公证服务更新\n\n正如去年在 WWDC (简体中文字幕) 上宣布的那样，如果你目前使用 altool 命令行工具或者 Xcode 13 或更早版本通过 Apple 公证服务对 Mac 软件进行公证，则需要改为使用 notarytool 命令行工具，或者升级到 Xcode 14 或更高版本。自 2023 年 11 月 1 日起，Apple 公证服务将不再接受从 altool 或者 Xcode 13 或更早版本上传的内容。已经过公证的现有软件可以继续正常工作。\n\nApple 公证服务是一个自动化系统，它会扫描 Mac 软件中有没有恶意内容，检查有没有代码签名问题，并快速返回结果。对软件进行公证可向用户保证，Apple 已检查且未发现软件中包含恶意软件。\n\n为改进 Apple 平台的安全性和隐私保护，用于验证 App 和关联 App 内购买项目销售的 App Store 收据签名媒介证书将更新为使用 SHA-256 加密算法。此更新将分多个阶段完成，新的 App 和 App 更新可能会受影响，具体取决于它们验证收据的方式。\n\n### Apple 设计大奖入围名单公布\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6c43f7417cd4e48a230628478de095c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\nApple 设计大奖旨在表彰在多元包容、乐趣横生、出色互动、社会影响、视觉图像，以及创新思维等类别中表现出色的 App 和游戏。马上一睹今年的入围作品，我们将在太平洋夏令时间 6 月 5 日下午 6:30 揭晓获奖者，敬请关注。\n\n## 提案\n\n### 通过的提案\n\n[SE-0399](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0399-tuple-of-value-pack-expansion.md \"https://github.com/apple/swift-evolution/blob/main/proposals/0399-tuple-of-value-pack-expansion.md\") **value 包展开的元组** 提案通过审查。该提案已在 **二十九期周报** 正在审查的提案模块做了详细介绍。\n\n[SE-0397](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0397-freestanding-declaration-macros.md \"https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md\") **独立声明 Macros** 提案通过审查。该提案已在 **二十八期周报** 正在审查的提案模块做了详细介绍。\n\n[SE-0392](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0392-custom-actor-executors.md \"https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md\") **自定义 Actor 执行器** 提案通过审查。该提案已在 **二十五期周报** 正在审查的提案模块做了详细介绍。\n\n[SE-0390](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapple%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0390-noncopyable-structs-and-enums.md \"https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md\") \\*\\*引入 @noncopyable \\*\\* 提案通过审查。该提案已在 **二十四期周报** 正在审查的提案模块做了详细介绍。\n\n## Swift论坛\n\n1.  讨论[从 Realm 数据库迁移提示？](https://link.juejin.cn/?target=https%3A%2F%2Ftranslate.google.com%2F%3Fsl%3Den%26tl%3Dzh-CN%26text%3DMigrating%2Bfrom%2BRealm%2BDatabase%2BTips%253F%26op%3Dtranslate \"https://translate.google.com/?sl=en&tl=zh-CN&text=Migrating+from+Realm+Database+Tips%3F&op=translate\")\n\n**提问**\n\n目前正在寻求迁移到更轻量级的解决方案（realm 目前对我的用例来说太过分了）并且想迁移到 grdb，但不必将 realm 作为依赖项持续一年或更长时间......\n\n**回答**\n\n在没有 Realm 库的情况下，您是否能够读取 Realm 数据库文件的内容？ 否则，您必须将 Realm 作为依赖项保留，直到您的用户迁移完毕。\n\n您可以通过发布能够要求用户升级的应用程序版本来缩短时间跨度。 这将允许您使用 “Realm-only”、“Realm-to-GRDB” 和最终的 “GRDB-only” 版本进行过渡。\n\n2.  提议[允许 protocol 嵌套在非通用上下文中](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fpitch-allow-protocols-to-be-nested-in-non-generic-contexts%2F65285 \"https://forums.swift.org/t/pitch-allow-protocols-to-be-nested-in-non-generic-contexts/65285\")\n\n**介绍**\n\n允许协议嵌套在非通用 struct/class/enum/actors 和函数中。\n\n**动机**\n\n将标称类型嵌套在其他标称类型中允许开发人员表达内部类型的自然范围——例如，String.UTF8View 是嵌套在 struct String 中的 struct UTF8View，它的名称清楚地传达了它作为 UTF-8 代码接口的用途 - 字符串值的单位。\n\n但是，嵌套目前仅限于在其他 struct/class/enum/actors 中的 struct/class/enum/actors； 协议根本不能嵌套，因此必须始终是模块中的顶级类型。 这很不幸，我们应该放宽此限制，以便开发人员可以表达自然作用于某些外部类型的协议。\n\n**建议的解决方案**\n\n我们将允许在非泛型 struct/class/enum/actors 中以及在不属于泛型上下文的函数中嵌套协议。\n\n例如，TableView.Delegate 自然是与表视图相关的委托协议。 开发人员应该这样声明它——嵌套在他们的 TableView 类中：\n\n```\nclass TableView {\n  protocol Delegate: AnyObject {\n    func tableView(_: TableView, didSelectRowAtIndex: Int)\n  }\n}\n\nclass DelegateConformer: TableView.Delegate {\n  func tableView(_: TableView, didSelectRowAtIndex: Int) {\n    // ...\n  }\n}\n```\n\n目前，开发人员采用复合名称（例如 TableViewDelegate）来表达可以通过嵌套表达的相同自然范围。\n\n作为一个额外的好处，在 TableView 的上下文中，可以使用更短的名称来引用嵌套协议委托（与所有其他嵌套类型一样）：\n\n```\nclass TableView {\n  weak var delegate: Delegate?\n  \n  protocol Delegate { /* ... */ }\n}\n```\n\n协议也可以嵌套在非泛型函数和闭包中。 不可否认，这在某种程度上是有限的实用性，因为对此类协议的所有一致性也必须在同一功能内。 但是，也没有理由人为地限制开发人员在函数中创建的模型的复杂性。 一些代码库（值得注意的是，Swift 编译器本身）使用带有嵌套类型的大型闭包，并且它们受益于使用协议的抽象。\n\n```\nfunc doSomething() {\n\n   protocol Abstraction {\n     associatedtype ResultType\n     func requirement() -> ResultType\n   }\n   struct SomeConformance: Abstraction {\n     func requirement() -> Int { ... }\n   }\n   struct AnotherConformance: Abstraction {\n     func requirement() -> String { ... }\n   }\n   \n   func impl<T: Abstraction>(_ input: T) -> T.ResultType {\n     // ...\n   }\n   \n   let _: Int = impl(SomeConformance())\n   let _: String = impl(AnotherConformance())\n}\n```\n\n3.  提议[PermutableCollection 协议](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fpermutablecollection-protocol%2F65314 \"https://forums.swift.org/t/permutablecollection-protocol/65314\")\n\n**简介**\n\n该提案旨在添加一个 PermutableCollection 协议，该协议将位于集合协议层次结构中的 Collection 和 MutableCollection 之间。\n\n**动机**\n\n在某些情况下，人们希望能够移动和排序元素，同时不允许（或限制）元素的突变。 鉴于大量不太重要的收集协议，这是一个值得注意的遗漏。 创建自定义集合类型时，PermutableCollection 协议在任何强制元素唯一性和/或身份的有序集合中都是首选。 用例将包括即将推出的 OrderedDictionary 和 OrderedSet。 对于不可变和可变集合，它还可以提供对 Swift 使用的底层（并且可能是高度优化的）排序算法的统一访问。\n\n**设计**\n\n协议设计简单，只需一个 swapAt 要求\n\n```\n/// A collection that supports sorting.\nprotocol PermutableCollection<Element> : Collection where Self.SubSequence : PermutableCollection {\n\n  mutable func swapAt(_ i: Index, _ j: Index)\n  \n}\n```\n\n通过 swapAt 函数，通过扩展添加额外的排序函数实现。\n\n```\nextension PermutableCollection {\n\n  mutating func move(fromOffsets source: IndexSet, toOffset destination: Int) {\n    // move algorithm enacts changes via swapAt()\n  }\n    \n  mutating func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index {\n    // partition algorithm enacts changes via swapAt()\n  }\n  \n  mutating func sort() where Self: RandomAccessCollection, Self.Element: Comparable {\n    // partition algorithm enacts changes via swapAt()\n  }\n  \n  // ... more permutation operations that mimic those available for MutableCollection\n  \n}\n```\n\n4.  讨论 [Vapor 和 query 缓存？](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fvapor-and-query-caching%2F65278 \"https://forums.swift.org/t/vapor-and-query-caching/65278\")\n    \n5.  讨论[在 Swift 系统中，如何将文件内容读取为字符串？](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fin-swift-system-how-does-one-read-a-files-contents-to-a-string%2F65294 \"https://forums.swift.org/t/in-swift-system-how-does-one-read-a-files-contents-to-a-string/65294\")\n    \n\n**提问**\n\n我有一个文件的 FileDescriptor：\n\nlet fd = try FileDescriptor.open(<#filepath#>, .readOnly) 我可以使用 fd.read(into:) 将文件内容加载到 UnsafeMutableRawBufferPointer，但这是将文件内容加载到字符串中的正确第一步吗？ 如果是这样，\n\n在将它传递给 fd.read(into:) 之前，\n\n1.  我需要使用 .allocate(byteCount:alignment:) 分配 UnsafeMutableRawBufferPointer。 正确的 byteCount 取决于文件的大小。那么如何使用 Swift System 获取文件的大小呢？\n2.  如何从 UnsafeMutableRawBufferPointer 获取字符串？\n\n**回答**\n\n可以参考这个Git库：[github.com/tayloraswif…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftayloraswift%2Fswift-unidoc%2Fblob%2Fmaster%2FSources%2FSystem%2FFileDescriptor.swift \"https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift\")\n\n6.  讨论[为什么我不能使用 @dynamicMemberLookup 转发 enum cases？](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fwhy-can-t-i-forward-enum-cases-with-dynamicmemberlookup%2F65290 \"https://forums.swift.org/t/why-can-t-i-forward-enum-cases-with-dynamicmemberlookup/65290\")\n    \n7.  讨论[如何在 swift-foundation 中正确地进行性能测试？](https://link.juejin.cn/?target=https%3A%2F%2Fforums.swift.org%2Ft%2Fhow-to-do-performance-testing-properly-in-swift-foundation%2F65282 \"https://forums.swift.org/t/how-to-do-performance-testing-properly-in-swift-foundation/65282\")\n    \n\n**提问**\n\n我想对比一下swift-foundation 和 Xcode 自带的 JSONDecoder 解码的速度。\n\n我在一个新项目中使用单元测试和 measureBlock 以及在 swift-foundation 中使用 JSONEncoderTests 对其进行了测试。\n\nswift-foundation 中的 JSONDecoder 看起来太慢了，我认为这是因为 swift-foundation 还没有作为一个库被引入。\n\n## 推荐博文\n\n[iOS crash 报告分析系列 - 看懂 crash 报告的内容](https://juejin.cn/post/7238802590661476412/ \"https://juejin.cn/post/7238802590661476412/\")\n\n**摘要：** 本篇文章主要介绍了iOS崩溃报告的解读方法，从报告的 Header、Exception information、Diagnostic messages、Backtraces、Thread state 和 Binary images 六个部分详细讲解了各字段含义，并提供示例代码帮助读者更好地理解。同时也引导读者去深入学习符号化的相关知识来获得更多信息。通过阅读本文，开发者可轻松看懂代码中产生的崩溃报告，并进行问题定位和处理。\n\n[SwiftUI 中 LinearGradient的用法](https://link.juejin.cn/?target=https%3A%2F%2Fswdevnotes.com%2Fswift%2F2023%2Flineargradient-in-swiftui%2F \"https://swdevnotes.com/swift/2023/lineargradient-in-swiftui/\")\n\n**摘要：** 这篇博文探讨了在 SwiftUI 中使用 LinearGradient 为对象创建渐变颜色效果。它展示了如何定义颜色数组、使用标准和自定义起点和终点，以及设置坐标以改进铅笔对象上的颜色笔尖。本文还包括用于创建具有各种起点终点组合的不同线性渐变的示例代码。文章以示例结束，展示了如何使用这些技术来自定义一支蓝色铅笔或整套铅笔的外观。\n\n[Swift 中的动态成员查找](https://link.juejin.cn/?target=https%3A%2F%2Fswiftwithmajid.com%2F2023%2F05%2F23%2Fdynamic-member-lookup-in-swift%2F \"https://swiftwithmajid.com/2023/05/23/dynamic-member-lookup-in-swift/\")\n\n**摘要：** 本文介绍了 Swift 语言中的动态成员查找（Dynamic Member Lookup）特性。通过在类型上使用 @dynamicMemberLookup 属性，我们可以重载该类型的 subscript 方法来更方便地访问其数据。但是，这也意味着缺乏编译时安全性。为了解决这个问题，本文提到了使用 KeyPath 作为参数的 subscript 方法来实现编译时安全检查。最后，作者建议我们可以谨慎地使用 `@dynamicMemberLookup` 特性来改进 API 设计。\n\n## 话题讨论\n\n**有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？**\n\n1.是的。确实已经经济危机了，今年工作很难找，同事比以前更卷啦，各种裁员消息不断。\n\n2.经济危机不可能。五一淄博接待游客超过了100万人次，人挤人的旅游景象依然常在。\n\n3.经济危机应该是相对的。对于大多数上班族来说，2023年很难，奉劝大家且行且珍惜。\n\n## 关于我们\n\n**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。\n\n特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。', 'public/uploads/1694329652955.png', 5, 0, 0, 2, '2023-09-10 07:07:47', 1);
INSERT INTO `article` VALUES (157, 2, '', '1', NULL, 1, 0, 0, 0, '2023-09-05 14:58:59', 0);
INSERT INTO `article` VALUES (158, 2, NULL, NULL, NULL, 2, 0, 2, 0, '2023-09-07 15:21:38', 0);
INSERT INTO `article` VALUES (159, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-09 16:15:09', 0);
INSERT INTO `article` VALUES (160, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-09 16:15:27', 0);
INSERT INTO `article` VALUES (161, 2, '11111111111111111111111111111111111111111111111111111111111111111111111111111111', '', NULL, 1, 0, 2, 0, '2023-09-09 08:22:18', 0);
INSERT INTO `article` VALUES (162, 7, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-10 21:58:33', 0);
INSERT INTO `article` VALUES (163, 5, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-12 21:01:51', 0);
INSERT INTO `article` VALUES (164, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-13 00:14:33', 0);
INSERT INTO `article` VALUES (165, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-13 22:11:47', 0);
INSERT INTO `article` VALUES (166, 2, NULL, NULL, NULL, 1, 0, 0, 0, '2023-09-16 15:24:57', 0);
INSERT INTO `article` VALUES (167, 58962735, '使用 queueMicrotask 创建微任务！', '![699b0dee881e0c95adfe3793fd4a3f52.gif](https://img-blog.csdnimg.cn/img_convert/699b0dee881e0c95adfe3793fd4a3f52.gif)\n\n整理 | 郑丽媛  \n\n出品 | CSDN（ID：CSDNnews）\n\n凭借卓越的内存效率、速度与[安全性](https://so.csdn.net/so/search?q=%E5%AE%89%E5%85%A8%E6%80%A7&spm=1001.2101.3001.7020)等特点，近几年 Rust 可谓深受大厂青睐：\n\n-   2019 年，[AWS](https://so.csdn.net/so/search?q=AWS&spm=1001.2101.3001.7020) 表示开始在其基础架构中越来越多地使用 Rust 后，决定赞助 Rust，即 Rust 团队可以优惠租用 AWS 基础设施以进行语言开发。\n    \n-   2021 年 2 月 9 日，[Rust](https://so.csdn.net/so/search?q=Rust&spm=1001.2101.3001.7020) 基金会成立，Mozilla、亚马逊、华为、谷歌和微软作为创始白金成员，承诺在两年时间里每年投入不少于 100 万美元的预算，以用于 Rust 项目的开发、维护和推广。\n    \n-   2022 年，Meta 宣布将 Rust [语言](https://so.csdn.net/so/search?q=%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020)纳入其服务器端编程语言。\n    \n-   2022 年 12 月，Linux 内核 6.1 发布，包含了初始 Rust 支持。\n    \n-   今年年初，谷歌宣布支持使用 Rust 开发 Chromium。\n    \n-   ……\n    \n\n在这众多大厂之中，微软对于 Rust 的重视与支持力度也一直未减。继 5 月效仿 Linux 用 Rust 重写部分 Windows 内核后，近来微软在拥抱 Rust 上又进了一步：微软在 GitHub 中发布了一系列开发工具包，让开发者可以使用 Rust 语言来编写 Windows 驱动程序。\n\n对此，不少开发者在感慨：没想到啊，Windows 在拥抱 Rust 方面居然走在了 Linux 前面！\n\n![f739307eaf2814338d07096955f0790d.png](https://img-blog.csdnimg.cn/img_convert/f739307eaf2814338d07096955f0790d.png)\n\n![9e2252a18fb43144dafb6b7cbd1658d2.png](https://img-blog.csdnimg.cn/img_convert/9e2252a18fb43144dafb6b7cbd1658d2.png)\n\n**在拥抱 Rust 的路上，微软曾遭到反对**\n\n事实上，早在 2019 年 2 月，微软工程师 Matt Miller 在以色列举行的安全会议 BlueHat 上曾透露：从 2006 年到 2018 年，微软旗下产品过去 12 年修复的所有漏洞中，有七成涉及的都是内存安全问题。\n\n![3e8b5279f64cb41b8ac41ed036963a50.png](https://img-blog.csdnimg.cn/img_convert/3e8b5279f64cb41b8ac41ed036963a50.png)\n\n内存安全问题占比高的原因，主要是因为 Windows 大多是以 C 和 C++ 编写的——著名的“内存不安全”语言。内存管理代码只要有一个漏洞，就会导致大量的内存安全错误，从而可能引发远程代码执行或权限提升漏洞等攻击。\n\n对于这些潜在风险，同年 7 月微软研究院发布了一份声明，希望“在漏洞发生之前消除一整类漏洞”，并表示“满足这些要求的最有前途的新系统编程语言之一，就是最初由 Mozilla 发明的 Rust”。从这份声明可以看出，至少自 2019 年开始，微软已打算在拥抱 Rust 上积极布局。\n\n到了去年 9 月，微软 Azure 首席技术官 Mark Russinovich 在 X（前推特）上发文，正式呼吁业界淘汰 C / C++，应改用更加安全的 Rust 语言：\n\n> 说到语言，现在是时候停止用 C/C++ 启动任何新项目了，在需要使用非 GC 语言的情况下使用 Rust。为了安全性和可靠性，业界应该宣布这些语言已被淘汰。\n\n![c532da88b380e0dc286f4a0cb488b8cb.png](https://img-blog.csdnimg.cn/img_convert/c532da88b380e0dc286f4a0cb488b8cb.png)\n\n可不同于 Mark Russinovich 对 Rust 的支持和青睐，当时他的这则帖子下多是反对和质疑的声音：“这完全是一个与显示脱节、不切实际的想法。”\n\n-   “这听起来像是在指责语言本身而不是程序员。C++ 是门好语言，只是许多使用它的人基本上不懂编程，而换一种语言并不能解决这个问题。”\n    \n-   “Rust 是一种不错的语言，但它甚至还未达到 1.0 版本，我认为我们不应该为了尚未经过实战检验的语言而放弃久经考验的语言。”\n    \n\n尽管不被看好，但微软转向 Rust 的决心依旧坚定。今年 5 月 Mark Russinovich 宣布微软已用 Rust 重写部分 Windows 内核：“如果你在 Windows 11 Insider ring 上，那么将首次感受到 Rust 在 Windows 内核中带来的魔力。”\n\n![dbe180594065e72d51019f99524ef8e8.png](https://img-blog.csdnimg.cn/img_convert/dbe180594065e72d51019f99524ef8e8.png)\n\n当时，或许是网友对微软拥抱 Rust 的决定已逐渐接受，也或许是微软解释过并非是用 Rust 替换内核中 C/C++ 的整个“40 年工作”，而是将其中一些内部的 C++ 数据类型替换成 Rust，因此在这则帖子下大多是正面留言。\n\n从 2019 年放出风声，到已用 Rust 重写部分 Windows 11 内核代码，如今微软拥抱 Rust 的程度仍在继续加深：在 Github 上发布工具包，让开发者能用 Rust 编写 Windows 驱动程序——这无疑是为操作系统实现内存安全编程的关键一步。\n\n![5d4f10224d9c9d3bf9e91b279ec21013.png](https://img-blog.csdnimg.cn/img_convert/5d4f10224d9c9d3bf9e91b279ec21013.png)\n\n**仍处于早期开发阶段，不建议“用于商业用途”**\n\n从 Mark Russinovich 在 X 上分享的 Github 链接来看，这个由微软 Surface 团队开发的新项目名为 windows-drivers-rs，是一个由多个 Rust 组件（Crates）组成的项目，可帮助开发人员用 Rust 开发 Windows 驱动程序。\n\n该项目同时支持 WDM（Windows Driver Model）和 WDF（Windows Driver Foundation）两种不同的驱动程序开发模型：WDM 驱动程序级别较低，与操作系统紧密相连，而 WDF 驱动程序则通过框架库与系统交互。\n\n据介绍，windows-drivers-rs 具体包含以下板块：\n\n-   wdk-build：一个用于配置 Cargo 构建脚本的库，可用于绑定生成和 WDK（Windows Developer Kit）的下游链接。\n    \n-   wdk-sys：将 FFI 直接绑定到 WDK 中提供的 API。\n    \n-   wdk：与 WDK 中的 API 安全绑定。\n    \n-   wdk-panic：使用 WDK 构建的程序的默认 panic 处理程序实现。\n    \n-   wdk-alloc：为使用 WDK 编译的二进制文件提供分配支持。\n    \n-   wdk-macros：宏集合，有助于更轻松地与 wdk-sys 的直接绑定进行交互。\n    \n\n如需查看 windows-drivers-rs 用于创建驱动程序的示例，开发者可前往：https://github.com/microsoft/Windows-rust-driver-samples。\n\n值得注意的是，微软补充：虽然该项目的计划灵活运用不同的 WDK 版本和不同的 WDF 版本，但目前“仅针对 NI eWDK、KMDF 1.33、UMDF 2.33 和 WDM 驱动程序进行了测试”，对于“较旧的 DDK 可能会缺少链接器选项”。\n\n此外，微软还表示 windows-drivers-rs 目前仍处于早期开发阶段，因此“不建议用于商业用途”，但鼓励社区和开发者对其进行试验、建议和反馈，并将利用 GitHub 论坛作为与社区互动的主要形式。\n\n![af8bd0ebb040023d895182936d94fe8d.png](https://img-blog.csdnimg.cn/img_convert/af8bd0ebb040023d895182936d94fe8d.png)\n\n**开发者提问：Rust 如何处理异常？**\n\n就目前而言，已有少数开发者提出了当前这个旨在助力开发者用 Rust 开发 Windows 驱动程序的新工具平台存在的一些问题，其中一个引起讨论的问题就是 Rust 如何处理异常。\n\n一位开发者指出：“对于 Windows 内核（以及整个操作系统）来说，结构化异常处理是 Windows 开发不可或缺的一部分，也是让 Rust 成为 Windows 内核开发现实的真正障碍。”\n\n![ad77cbbc6386f532b7b86df492a6d5c7.png](https://img-blog.csdnimg.cn/img_convert/ad77cbbc6386f532b7b86df492a6d5c7.png)\n\n但与其他编程语言不同，在 Rust 语言中没有异常这一说，它通常用 Result 类型来处理可恢复的错误，而在遇到不可恢复的错误时，Rust 会提供一个特殊的宏 panic!。当执行这个宏时，程序会打印一段错误提示信息，展开（unwind）并清理当前的栈（Stack），然后退出程序的执行。\n\n正如另一位开发者所说，“Windows 内核中的 Panic 往往是最后的手段，只应保留给内核已损坏且无法恢复的情况”，因此不少人认为 Rust 调用 Panic 的方式“在内核代码中是不可取的，这可能会导致系统崩溃”。\n\n那么，你对于 Rust 进一步入驻 Windows 的趋势又有何看法呢？  \n\n参考链接：\n\nhttps://github.com/microsoft/windows-drivers-rs\n\nhttps://devclass.com/2023/09/25/microsoft-posts-early-stages-code-for-developing-windows-drivers-in-rust/\n\n![bd2a27af6aff58a2b59d4e948c66d808.gif](https://img-blog.csdnimg.cn/img_convert/bd2a27af6aff58a2b59d4e948c66d808.gif)\n\n**欢迎参与 CSDN 重磅发起的《2023 AI 开发者生态调查问卷》，分享您真实的 AI 使用体验，更有精美好礼等你拿！**\n\n![71c57ab11aeb6621682979cfa1d3b5db.jpeg](https://img-blog.csdnimg.cn/img_convert/71c57ab11aeb6621682979cfa1d3b5db.jpeg)\n\n**推荐阅读：**\n\n▶让 AI 取代人类工作 3 个月，公司 CEO 夸赞：“复制粘贴的工作完全消失了！”\n\n▶代码别拿来就用！中国研究者14页论文预警：Copilot生成代码35.8%有漏洞、C++成“重灾区”\n\n▶苹果 App Store 现黄色软件伪装成学习软件；微软或推出自家首款AI芯片；Rails 7.1 发布|极客头条', 'public/uploads/1695461960776.png', 2, 0, 0, 5, '2023-10-10 00:23:41', 1);
INSERT INTO `article` VALUES (168, 2, '11', '## 123\n*123*\n1. 1234\n2. 34123\n3. 34123\n4. ', NULL, 1, 0, 0, 0, '2023-10-17 12:48:16', 0);
INSERT INTO `article` VALUES (169, 2, '这个300万下载量的VSCode插件竟是这样开发的', '今天，我准备在 VSCode 插件市场上寻找一个 PDF 阅读插件。找到一个下载量最高的插件，点击进去查看了详细信息，发现界面给我一种似曾相识的感觉。我查看了一下插件的源代码，果然发现它直接嵌入了 pdf.js 的 web 界面。开发这样一个插件其实并不复杂，只需要了解一些插件开发的知识，就能够实现它。接下来，我会分享一下我是如何开发这个插件的，虽然与源代码可能有一些不同，但基本原理是相同的。\n\n![](http://127.0.0.1:3000/public/uploads/1697706668036.png)\n\n\n前面的文章已经详细介绍了如何创建插件项目，因此我们直接进入功能实现部分，重点是实现点击 PDF 文件后能够直接在插件中进行浏览。\n\n## 定义自定义编辑器\n\n默认情况下，VSCode 并不直接支持某些特殊文件类型的查看，但是您可以通过使用自定义编辑器 `customEditors` 来扩展其功能。\n\n通过 `customEditors`，您可以创建完全可自定义的读/写编辑器，以取代 VSCode 的标准文本编辑器，用于处理特定类型的资源。举例来说，在编辑 Markdown 文件时，您可以创建一个自定义编辑器，用于实时预览 Markdown 渲染的效果。\n\n对于 PDF 文件的预览，我们也可以使用 `customEditors` 功能。首先，在您的插件的 package.json 文件中进行定义：\n\n```\n\"contributes\": {\n  \"customEditors\": [\n    {\n      \"viewType\": \"dodo-reader.pdfEditor\",\n      \"displayName\": \"PDF Viewer\",\n      \"selector\": [\n        {\n          \"filenamePattern\": \"*.pdf\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## 注册自定义编辑器\n\n1.  创建一个实现了 vscode.CustomEditorProvider 接口的类。这个接口包含了用于管理自定义编辑器的方法，包括打开、保存等操作。例如：\n    \n    ```\n    class PdfEditorProvider implements Partial<CustomEditorProvider> {\n        constructor() {\n            // 在这里可以进行一些初始化操作\n        }\n    \n        resolveCustomEditor(document: CustomDocument, webviewPanel: WebviewPanel, _token: CancellationToken) {\n            // 根据 URI 创建自定义文档，并返回一个自定义文档对象\n        }\n    \n        openCustomDocument(uri: vscode.Uri, openContext: vscode.CustomDocumentOpenContext, token: vscode.CancellationToken) {\n            // 将自定义文档与 Webview 面板关联，处理编辑器内容与 Webview 之间的交互\n        }\n    }\n    ```\n    \n2.  在类中实现完 CustomEditorProvider 接口后，注册您的提供程序：\n    \n    ```\n    const myProvider = new PdfEditorProvider();\n    const disposable = vscode.window.registerCustomEditorProvider(\'dodo-reader.pdfEditor\', myProvider); // 注册提供程序，dodo-reader.pdfEditor 对应上面定义标识\n    context.subscriptions.push(disposable); // 将提供程序添加到订阅中\n    ```\n    \n\n## 完善视图提供程序\n\n在上述自定义编辑器的注册后，接下来的重点是完善 `PdfEditorProvider` 接口，以定义视图的显示。视图的显示将涉及使用 webview，而你将要使用的是 pdf.js 的 web 视图程序。首先去下载程序[Prebuilt (modern browsers)](https://link.juejin.cn/?target=https%3A%2F%2Fmozilla.github.io%2Fpdf.js%2Fgetting_started%2F \"https://mozilla.github.io/pdf.js/getting_started/\")，然后解压到项目目录。这个程序其实是可以直接浏览器访问的，在目录下启动一个服务，然后可以直接打开地址：\n\n\n\n你可以在网址上添加 query 参数 `?file=fileUrl` 打开你的 PDF 文件。\n\n### openCustomDocument\n\n打开 PDF 文件时，首先会调用 `openCustomDocument`，你可以根据传入的 URI 创建自定义文档对象，该文档对象将包含您要编辑的内容，在这个程序里不做任何处理，直接返回包含 URI 的对象，这个对象将会传递到下面 `resolveCustomEditor` 方法的 document 参数。\n\n```\nopenCustomDocument(uri: vscode.Uri, openContext: vscode.CustomDocumentOpenContext, token: vscode.CancellationToken) {\n  return {\n    uri,\n    dispose: () => { }\n  }\n}\n```\n\n### resolveCustomEditor\n\n在 `resolveCustomEditor` 方法中，你可以定义显示的视图，程序如下：\n\n```\nresolveCustomEditor(document: CustomDocument, webviewPanel: WebviewPanel, _token: CancellationToken) {\n  webviewPanel.webview.html = \'Hello World!\';\n}\n```\n\n显示如图：\n![](http://127.0.0.1:3000/public/uploads/1697706682803.png)\n\n\n那么要显示 PDF 文件就只需要把下载的 PDF 程序 html 内容替换为当前 `webviewPanel.webview.html` 的值。本来以为可以改成：\n\n```\n// 嵌套一个 PDF 视图浏览的 iframe\nwebviewPanel.webview.html = `\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n  </head>\n  <body>\n    <iframe src=\"\"></iframe>\n  </body>\n</html>\n`;\n```\n\n这种方法是最简单，但出乎我的意料，iframe 并没有显示出内容。这可能是由于 VSCode 的安全策略限制所导致的。因此，我考虑了另一种方法：通过读取 PDF 视图首页的 HTML 内容，并将其赋值给 `webviewPanel.webview.html`。然而，这种方法可能会遇到一个问题：如何向 PDF 视图程序提供要打开的文件链接。\n\nPDF 视图程序上面提到会通过查询参数 \"file\" 来获取要显示的文件链接。如果没有提供这个参数，它会读取默认的链接。以下是相关的源代码示例：\n\n```\nfile = params.get(\"file\") ?? _app_options.AppOptions.get(\"defaultUrl\");\n```\n\n然而，直接赋值 HTML 文本的操作并不能通过网址提供 \"file\" 值。这可能需要修改源代码。虽然修改源代码可能会带来一些不便，但一开始看来似乎没有其他办法，只能尝试一下。一种思路是将获取 \"file\" 值的方式改为直接从全局变量中获取，可以在读取的 HTML 内容中添加 \"file\" 值：\n\n```\nwindow.file = \'https://...\'\n```\n\n然后将上述源代码修改为：\n\n```\nfile = window.file ?? _app_options.AppOptions.get(\"defaultUrl\");\n```\n\n然而，就在以为即将成功的时候，又出现了红色的报错：_加载 PDF 时发生错误，file origin does not match viewer\'s_，实在让人抓狂。接着找到对应源码，发现源码在打开 PDF 前会比较当前页面的 url origin 跟文件的 url origin 是否相同，这怎么可能相同嘛，一个是开头`vscode-webview://`的链接，一个是开头`https://`的链接。虽然去除此校验可能行得通，但总体来看，这种方式似乎并不可行，修改内容太过繁琐。那么，是否有一种方法可以在不修改 PDF 视图源代码的情况下解决问题呢？继续从源代码入手，后来发现了一个\"fileinputchange\"事件监听处理程序，代码如下：\n\n```\nvar webViewerFileInputChange = function (evt) {\n  if (PDFViewerApplication.pdfViewer?.isInPresentationMode) {\n    return;\n  }\n  const file = evt.fileInput.files[0];\n  PDFViewerApplication.open({\n    url: URL.createObjectURL(file),\n    originalUrl: file.name\n  });\n};\n```\n\n通过代码，很容易看出，一旦检测到文件有变动，会立即调用 open 方法进行打开。需要注意的是，这个 open 方法并不会验证 URL 是否与当前 origin 相同，当前是在 blob 链接。鉴于这种情况，我们是否可以在初始化完成后直接调用 open 方法来打开文件呢？通过一番改造，最终证明这是可行的。以下是修改后的代码示例：\n\n```\nresolveCustomEditor(document: CustomDocument, webviewPanel: WebviewPanel, _token: CancellationToken) {\n  webviewPanel.webview.options = {\n    enableScripts: true,\n    localResourceRoots: [vscode.Uri.file(path.dirname(document.uri.fsPath)), this.context.extensionUri]\n  };\n  const base = vscode.Uri.joinPath(this.context.extensionUri, \'dist/web/pdf/web/\')\n  webviewPanel.webview.html = readFileSync(path.join(base.fsPath, \'viewer.html\'), \'utf8\').replace(\'<head>\', `<head>\n    <base href=\"${webviewPanel.webview.asWebviewUri(base).toString()}\">\n    <script>\n    window.addEventListener(\'load\', async function () {\n      PDFViewerApplication.initializedPromise.then(() => {\n        setTimeout(() => {\n          PDFViewerApplication.open({url: \"${webviewPanel.webview.asWebviewUri(document.uri)}\"})\n        })\n      })\n    })\n    </script>\n    <style>\n      body {\n        padding: 0;\n      }\n    </style>\n  `)\n}\n```\n\n对上述关键代码进行分析如下：\n\n1.  `localResourceRoots` 参数：该参数的作用是定义允许通过 web URL 访问的目录。在这里，你需要明确定义两个目录：一是用于打开 PDF 文件的当前目录，二是插件所在的目录。确保两者都定义正确，否则在访问时可能会遇到 401 错误。\n    \n2.  `<base href=\"...\">` 标签：通过设置 `<base>` 标签，可以为网页内加载资源提供基本路径。确保资源能够正确加载。\n    \n3.  `setTimeout` 函数：在调用程序打开文件时，使用 setTimeout 的目的是在打开默认 PDF 文件后，再执行打开当前所需的 PDF 文件。这样做是防止后面执行的打开默认 PDF 覆盖你所要打开的 PDF（实际默认文件不存在会报错，但不会产生实质影响）。\n    \n\n这种实现方式相比前面提到的 PDF 插件实现要简单得多，但是原理是基本相同的。让我们来看一下最终的效果如何：\n\n![](http://127.0.0.1:3000/public/uploads/1697706695937.png)\n\n\n-   源码：[github.com/wenyikun/do…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwenyikun%2Fdodo-reader.git \"https://github.com/wenyikun/dodo-reader.git\")\n-   VSCode 插件：[marketplace.visualstudio.com/items?itemN…](https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dwenyikun.dodo-reader \"https://marketplace.visualstudio.com/items?itemName=wenyikun.dodo-reader\")', 'public/uploads/1697706730236.png', 2, 0, 0, 6, '2023-10-19 17:27:31', 1);
INSERT INTO `article` VALUES (170, 2, '前端性能优化 ｜ 防抖与节流 ', '## 一. 前言\n\n**为什么要做性能优化？性能优化到底有多重要？**  性能优是为了提供更好的**用户体验**、**加快网站加载速度**、**提高搜索引擎排名**、**节省服务器资源**、**适应多种设备和网络环境**等方面的需求。通过不断优化性能，可以提高用户满意度、增加网站流量提高业务效果。\n\n同时**性能优化**是把双刃剑，有好的一面也有坏的一面。好的一面就是可以能提升网站性能，坏的一面就是配置多，代码复杂，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，所以也并不是一味的追求性能优化，而是需要谨慎使用。\n\n**防抖和节流**是`JavaScript` 中常用的两种性能优化方式。面试中我们也会经常碰到。它们的作用是减少函数的执行次数，以提高代码的性能。本文将详细介绍**防抖**和**节流**的定义、原理和实现方法，并讨论如何在具体功能中使用它们。\n\n## 二. 对防抖与节流的理解\n\n### 什么是防抖（Debounce）\n\n如下图所示，防抖（`Debounce`）是指在事件被触发 `delay` 时间后再执行回调 `function` 函数，如果在这设置的 `delay` 时间内事件又被触发，则重新计时。这可以使用在些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n\n![](http://127.0.0.1:3000/public/uploads/1697707876538.png)\n\n\n### 什么是节流（Throttle）\n\n如下图所示，节流（`Throttle`）是指规定一个单位时间（延迟 `delay` 时间），在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 `scroll` 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n![](http://127.0.0.1:3000/public/uploads/1697707882260.png)\n\n\n## 三. 防抖函数的应用场景\n\n1.  **搜索框实时搜索**：当用户在搜索框中输入内容时，通常需要实时进行搜索。使用防抖函数可以延迟搜索请求的发送，只在用户停止输入一段时间后才真正发送请求，避免频繁的请求操作。\n    \n2.  **表单输入验证**：在表单输入过程中，每次用户输入都可能触发验证操作。使用防抖函数可以延迟触发验证操作，只在用户输入完毕一段时间后进行验证，避免频繁的验证操作。\n    \n3.  **浏览器窗口调整事件**：当用户调整浏览器窗口大小时，会触发`resize`事件。使用防抖函数可以延迟`resize`事件的触发，只在用户停止调整窗口一段时间后才执行对应的操作，避免频繁的计算和布局操作。\n    \n4.  **鼠标移动事件**：在一些特定的交互场景中，需要根据鼠标的移动位置做出相应的交互。使用防抖函数可以延迟鼠标移动事件的触发，只在用户停止移鼠标一段时间后才执行相应的操作，避免过度频繁的操作。\n    \n\n> 以用户搜索框实时搜索请求后台为例，我们来详细看一下：\n\n### 原始代码，未进行防抖优化\n\n```\n<div class=\"box\">\n  输入事件没有进行防抖处理：<input type=\"text\" id=\"demo\" name=\"demo\">\n</div>\n<script>\n  // 模拟请求\n  function req(value){\n    console.warn(\"request: \" + value + \", time: \" + new Date());\n  }\n\n  const inputBox = document.getElementById(\"demo\");\n  inputBox.addEventListener(\"keyup\",e=>{\n    req(e.target.value);\n  })\n</script>\n```\n\n![](http://127.0.0.1:3000/public/uploads/1697707908393.png)\n\n\n上面结果所示，只要我们在输入框中每次输入文字，那么就会触发一次模拟请求，这对于用户和开发者而言都是不好的体验和资源的浪费。\n\n**思考：** 我们想到每次用户输入文字都是需要一定时间的，那么我们可以定义在规定时间进行完整输入才能进行请求，这样我们可以减轻对后台的压力。\n\n### 使用防抖函数优化后\n\n> 防抖规则：`500ms`内输入文字按下键盘都不会触发请求事件，而是在输入框的定时器`500ms`停止输入后发送请求\n\n**优化：** 我们改造一下上述的代码，监听我们的输入框，在`500ms`内连续输入，不进行任何操作，`500ms`后发送一次请求。\n\n```\n<div class=\"box\">\n  输入事件进行防抖处理：<input type=\"text\" id=\"demo\" name=\"demo\">\n</div>\n<script>\n  // 模拟请求\n  function req(value){\n    console.warn(\"request: \" + value + \", time: \" + new Date());\n  }\n\n  const inputBox = document.getElementById(\"demo\");\n  inputBox.addEventListener(\"keyup\",e=>{\n    debounce(() => req(e.target.value), 500);\n  })\n</script>\n```\n\n![](http://127.0.0.1:3000/public/uploads/1697707926935.png)\n\n\n从上面的运行结果可以看出，在`500ms`内在输入框中连续输入文字都不会触发请求事件，而是在输入框的定时器`500ms`停止输入后发送请求。\n\n实现原理很简单，就是对于频繁输入的输入框请求事件添加定时器进行计数，在指定时间内进行频繁输入并不会进行请求，而是在指定时间间隔内停止输入才会执行函数。\n\n当停止输入但在此定时器计数时间内，会重新进行触发请求事件。\n\n## 四. 节流函数的应用场景\n\n1.  **页面滚动事件**：当用户滚动页面时，会频繁触发滚动事件。使用节流函数可以控制滚动事件的触发频率，避免过多的计算和渲染操作，提高页面的性能和流畅度。\n    \n2.  **窗口大小调整**：当用户调整浏览器窗口大小时，会不断触发`resize`事件。使用节流函数可以限制`resize`事件的触发频率，以避免过度计算和布局操作。\n    \n3.  **频繁点击按钮**：在某些场景下，点击按钮可能会触发重复的提交操作。使用节流函数可以限制按钮点击的触发频率，防止重复的提交。\n    \n4.  **动画场景:** 避免短时间内多次触发动画引起性能问题\n    \n5.  **拖拽场景:** 在某些场景下，频繁触发位置变动会造成性能问题，固定时间内只执行一次，防止超高频次触发位置变动\n    \n\n> 以频繁点击按钮防止重复提交为例子，我们来详细看一下：\n\n### 原始代码，未进行节流优化\n\n```\n<button id=\"demo\" style=\"margin: 50px;\">点击按钮</button></button>\n<script>\n    let value = 1\n    // 模拟请求\n    function req(){\n        console.warn(\"request: \" + value++ + \", time: \" + new Date());\n    }\n    const ele = document.getElementById(\"demo\");\n    ele.addEventListener(\"click\", (e) => {\n        req()\n    });\n</script>\n```\n\n![](http://127.0.0.1:3000/public/uploads/1697707938235.png)\n\n\n上面结果所示，只要我们点击按钮，那么就会触发一次模拟请求，这除了对于服务器的压力以外，还会造成多次数据提交，有可能会造成数据重复的风险。\n\n### 使用节流函数优化后\n\n> 节流规则：`1000ms`内频繁点击按钮，只能成功一次\n\n**优化：** 按钮频繁多次点击时，为了避免用户多次请求，做了节流限制，在规定一个`1000ms`时间内，只能有一次点击成功的触发动作。\n\n```\n<button id=\"demo\" style=\"margin: 50px;\">点击按钮</button></button>\n<script>\n    let value = 1\n    // 模拟请求\n    function req(){\n        console.warn(\"request: \" + value++ + \", time: \" + new Date());\n    }\n    const ele = document.getElementById(\"demo\");\n    ele.addEventListener(\"click\", (e) => {\n        throttle(() => req(), 1000)\n    });\n</script>\n```\n\n![](http://127.0.0.1:3000/public/uploads/1697707956258.png)\n\n\n从上面的运行结果可以看出，在`1000ms`内按钮连续多次点击，只有一次成功。\n\n## 五. 实现防抖函数和节流函数\n\n### 实现防抖函数\n\n**实现思路**\n\n1.  定义一个计时器变量，默认为null。\n2.  当事件触发时，清除之前的计时器。\n3.  创建一个新的计时器，延迟执行目标函数。\n4.  在在此时间内，如果再次触了事件，则重复步骤2和3。\n5.  在延迟时间内没有再次触发事件时，执行目标函数。\n\n```\n/**\n * @desc 防抖函数：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数\n * @param {Function} func 函数\n * @param {Number} wait 延迟执行毫秒数\n * @param {Boolean} immediate true 表示立即执行，false 表示非立即执行\n */\nlet timeout\n\nfunction debounce(func, wait = 500, immediate = false) {\n  // 清除定时器\n  if (timeout) clearTimeout(timeout)\n  // 立即执行，此类情况一般用不到\n  if (immediate) {\n    let callNow = !timeout\n    timeout = setTimeout(() => {\n      timeout = null\n    }, wait)\n    if (callNow) typeof func === \'function\' && func()\n  } else {\n    // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法\n    timeout = setTimeout(() => {\n      typeof func === \'function\' && func()\n    }, wait)\n  }\n}\n\n```\n\n### 实现节流函数\n\n**实现思路**\n\n1.  定义一个标记变量来表示是否允许执行目标函数，默认为0。\n2.  当事件触发时，检查当前的时间戳与标记变量的差值，如果差值大于设定的延迟时间，则执行函数并将标记变量设为当前的时间戳。如果差值小于设定的延迟时间，则不执行。\n3.  在指定时间间隔内再次触发事件时，则重复2步骤。\n\n```\n/**\n * @desc 节流函数：在一定时间内，只能触发一次\n * @param {Function} func 函数\n * @param {Number} wait 延迟执行毫秒数\n */\nlet previous = 0\nfunction throttle(func, wait = 500) {\n  let now = Date.now()\n  if (now - previous > wait) {\n    typeof func === \'function\' && func()\n    previous = now\n  }\n}\n\n\n```\n\n## 总结\n\n在本篇文章中，我们了解了JavaScript中的防抖和节流优化技术。这两种技术都是为了解决频繁触发的事件而产生的性能问题，通过限制事件触发的频率，提升页面性能和用户体验。\n\n我们首先介绍了防抖和节流的定义和区别，防抖是指在一段时间内，只执行最后一次触发的事件，而节流是指一段时间内，固定间隔触发事件。然后，我们详细阐述了防抖和节流的原理和实现方式。\n\n在实际应用中，我们经常遇到需要使用防抖和节流来优化用户交互、滚动事件、输入框输入等场景。通过合理地防抖和节流，我们可以减少冗余的计算和渲染，提高页面的流畅性和响应速度。\n\n在文章的结尾，提供了一些常见的优化库和工具，方便开发者快速应用于实际开发中。\n\n通过本文的学习，希望大家能够充分理解防抖和节流的原理，并且能够根实际情况合理应用于自己的项目，提升页面的性能和用户体验。\n\n## 第三方库\n\n1.  [Lodash - 防抖](https://link.juejin.cn/?target=https%3A%2F%2Flodash.com%2Fdocs%2F4.17.15%23debounce \"https://lodash.com/docs/4.17.15#debounce\")\n2.  [Lodash - 节流](https://link.juejin.cn/?target=https%3A%2F%2Flodash.com%2Fdocs%2F4.17.15%23throttle \"https://lodash.com/docs/4.17.15#throttle\")', 'public/uploads/1697707854682.png', 2, 0, 0, 3, '2023-10-19 17:32:39', 1);
INSERT INTO `article` VALUES (171, 2, '完全免费白嫖 GPT-4 的终极方案！', '> 原文链接：[icloudnative.io/posts/compl…](https://link.juejin.cn/?target=https%3A%2F%2Ficloudnative.io%2Fposts%2Fcompletely-free-to-use-gpt4%2F \"https://icloudnative.io/posts/completely-free-to-use-gpt4/\")\n\n![](http://127.0.0.1:3000/public/uploads/1697719780118.png)\n\n\nGPT-4 目前是世界上最强的多模态大模型，能力甩 GPT-3.5 好几条街。\n\n大家都希望早日用上 GPT-4，不过目前体验 GPT-4 的渠道非常有限，要么就是开通 ChatGPT 尊贵的 Plus 会员，即使你开了会员，也是有限制的，**每 3 小时只能发送 25 条消息。。。**\n\n要么就去 OpenAI 官网申请 GPT-4 的 API，但是目前申请到 API 的小伙伴非常少，你以为申请到 API 就可以用了吗？GPT-4 的 API 价格超级无敌贵，**是 GPT-3.5 价格的 30 倍**，你敢用吗？😄\n\n然而，但是，既然我写了这篇文章，肯定是要告诉那一个**惊天大幂幂**的！\n\n现在完全免费白嫖 GPT-4 的机会来了，不仅可以白嫖，还可以直接作为 API 来调用！\n\n不仅能够作为 API 调用，我还接入了公众号给大家白嫖，你说气人不气人？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39714008599646edb562805cc0a002c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n下面言归正传，开始**手把手教大家如何免费白嫖 GPT-4**。\n\n## gpt4free-ts 介绍\n\n[GPT4Free](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxtekky%2Fgpt4free \"https://github.com/xtekky/gpt4free\") 大家应该都知道吧？它上线几周就在 GitHub 上揽收了接近 4w 的 Star。原因就在于其提供了对 GPT-4 及 GPT-3.5 免费且几乎无限制的访问。该项目通过对各种调用了 OpenAI API 网站的第三方 API 进行逆向工程，达到使任何人都可以免费访问该流行 AI 模型的目的。\n\n这就相当于什么？**假设地主家有一个粮仓，你往他家的粮仓偷偷插了一根管子，不停地向外抽米，他全然不知，所以你也不用交钱，一切费用由地主承担**。\n\n现在**接入 GPT-4 的第三方网站就相当于那个地主**，懂了吧？\n\n但是这个项目并没有封装 API，而且目前也不太能用了。\n\n作为开发者，我们想要的肯定是 API 啊！这就要提到今天的主角了：[gpt4free-ts](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxiangsx%2Fgpt4free-ts \"https://github.com/xiangsx/gpt4free-ts\")\n\n这个项目是用 TypeScript 写的，相当于 GPT4Free 的 TypeScript 版本，但是更方便部署，而且封装了 API，简直就是开发者的福音，就他了！\n\n这个项目向多个地主家的粮仓插了管子，其中最强大的地主就是 [forefront.ai](https://link.juejin.cn/?target=https%3A%2F%2Fchat.forefront.ai%2F \"https://chat.forefront.ai/\")，这个地主家的粮仓里就包含了 GPT-4 这个香饽饽，而且还有 Claude，就嫖他了！\n\n除了 forefront 之外，它接的粮仓还挺多的。。\n\n\n## 大批量注册临时邮箱\n\nforefront 的 GPT-4 模型是有限制的，**每个账号每 3 小时内只能发送 5 条消息**。\n\n所以接下来需要用到一个非常神奇的服务叫 [RapidAPI](https://link.juejin.cn/?target=https%3A%2F%2Frapidapi.com%2Fcalvinloveland335703-0p6BxLYIH8f%2Fapi%2Ftemp-mail44 \"https://rapidapi.com/calvinloveland335703-0p6BxLYIH8f/api/temp-mail44\")。**你可以通过这个 API 来获取无穷无尽的临时邮箱，然后再用这些无穷无尽的临时邮箱去注册无穷无尽的 forefront 账号。**\n\n这么一说，你是不是就悟了？哈哈哈\n\n首先你需要在这里注册一个账号并登录：**[rapidapi.com/calvinlovel…](https://link.juejin.cn/?target=https%3A%2F%2Frapidapi.com%2Fcalvinloveland335703-0p6BxLYIH8f%2Fapi%2Ftemp-mail44 \"https://rapidapi.com/calvinloveland335703-0p6BxLYIH8f/api/temp-mail44\")**\n\n然后需要在 Pricing 页面开启订阅：\n\n![](http://127.0.0.1:3000/public/uploads/1697719801207.png)\n\n\n一般情况下订阅免费套餐即可，一天可以调用 100 次。\n\n如果你有更高的需求，可以考虑订阅更高级的套餐（比如你的用户数量特别多）。\n\n订阅完了之后，你就能看到 API Key 了。这个 Key 我们后面会用到。\n![](http://127.0.0.1:3000/public/uploads/1697719811799.png)\n\n\n## Sealos 云操作系统介绍\n\n单机操作系统大家应该都知道吧？Windows、macOS、Linux 这些都属于单机操作系统，为什么叫单机操作系统呢？因为他的内存啊，CPU 啊，都在一台机器上，你不可能用其他机器的内存和 CPU。\n\n那么什么是云操作系统呢？就是**把一群机器的 CPU 和内存看成一个整体**，然后给用户提供一个交互界面，用户可以通过这个交互界面来操作所有的资源。\n\n懂 K8s 的玩家可能要说了：这个我懂，K8s 就可以！\n\n如果我们的目标愿景是一个云操作系统，**K8s 充其量只能是这个云操作系统的内核**，就像 Linux 内核一样。完整的云操作系统需要一个像 Windows 和 Ubuntu 操作系统那样的交互界面，也就是**操作系统发行版**。\n\n**对于云操作系统来说，Sealos 就是那个发行版。**\n\n> 链接：**[cloud.sealos.io](https://link.juejin.cn/?target=https%3A%2F%2Fcloud.sealos.io \"https://cloud.sealos.io\")**\n\n![](http://127.0.0.1:3000/public/uploads/1697719819870.png)\n\n\n有人可能会把云操作系统理解成“**Web 界面**”，但其实不是，Sealos 云操作系统完全是类似于 Windows 和 macOS 桌面的那种逻辑，并不是 Web 界面。我只需要点几下鼠标，一个应用就装好了，老夫并不知道什么容器什么 K8s。\n\n数据库也一样，小鼠标一点，一个分布式数据库就装好了。\n\n我知道，这时候云原生玩家要坐不住了，您别着急，看到桌面上的终端了没？\n\n![](http://127.0.0.1:3000/public/uploads/1697719829963.png)\n\n\n终端只是这个云操作系统中的一个 App 而已。同理，**容器管理界面仍然可以作为云操作系统的 App，我管你是 Kubernetes Dashboard、Rancher、KubeSphere 还是 Kuboard，都可以作为 App 装在这个云操作系统中**。这时候对于云原生专家而言，仍然可以命令行咔咔秀操作，也可以通过各种管理界面来管理容器。\n\n云操作系统嘛，就是要什么人都能用才行，**不管你是什么角色，都能在这个操作系统里找到你想要的 App 去完成你的使命**。\n\n## 安装 gpt4free-ts\n\n接下来才是这篇文章的重头戏。\n\n我要教大家如何**在 Sealos 中点几下鼠标就能安装一个 gpt4free-ts 集群**。\n\n没错，就是 gpt4free-ts 集群。\n\n什么叫集群？就是说我要运行一群 gpt4free-ts 实例，然后前面加一个负载均衡作为对外的 API 入口。\n\n下面的步骤非常简单，**楼下的老奶奶都会，是真的，当时我就在楼下看她操作**。\n\n首先进入 Sealos 云操作系统的界面：\\*\\*[cloud.sealos.io\\*\\*。](https://link.juejin.cn/?target=https%3A%2F%2Fcloud.sealos.io**%25E3%2580%2582 \"https://cloud.sealos.io**%E3%80%82\")\n\n然后打开桌面上的应用管理 App：\n\n![](http://127.0.0.1:3000/public/uploads/1697719841237.png)\n\n\n点击「新建应用」：\n\n![](http://127.0.0.1:3000/public/uploads/1697719861477.png)\n\n\n在启动参数中，按照以下方式进行设置：\n\n-   应用名称随便写，比如 gpt4free。\n-   镜像名称是：**xiangsx/gpt4free-ts:latest**\n-   CPU 和内存需要根据应用的实际情况来填写。这个应用运行之后默认会启动两个 Chrome 浏览器来模拟登录 forefront，每次对话会从里面取一个账号来使用，次数用完了会自动注册新账号（因为每个账号每 3 小时只能发送 5 条信息）。**我们可以通过环境变量来修改启动的浏览器数量，所以需要根据你的浏览器数量来确定 CPU 和内存。** 我自己把浏览器数量设置为 3，所以需要的内存和 CPU 比较多（后面会告诉你怎么设置环境变量）。\n-   实例数根据自己的实际需求填写，我需要接入公众号，粉丝比较多，一个实例才 3 个账号（因为我一个实例跑了 3 个浏览器），根本不够用，所以我开了 3 个实例。\n-   容器暴露端口指定为 3000。\n-   打开外网访问。\n\n![](http://127.0.0.1:3000/public/uploads/1697719894946.png)\n\n\n继续往下，展开高级设置，点击「编辑环境变量」：\n\n![](http://127.0.0.1:3000/public/uploads/1697719900777.png)\n\n\n填入以下环境变量：\n\n```\nrapid_api_key=<rapid_api_key>\nDEBUG=0\nPOOL_SIZE=3\n```\n\n> ⚠️注意：请将 <rapid\\_api\\_key> 替换为你自己的 key。\n\n其中 POOL\\_SIZE 就是浏览器数量，每个浏览器会登录一个 forefront 账号。你可以根据自己的需要调整浏览器数量，并根据浏览器数量调整 CPU 和内存。**如果你不知道怎么调整合适，建议无脑跟着本文操作。**\n\n![](http://127.0.0.1:3000/public/uploads/1697719913836.png)\n\n\n继续，点击「新增存储卷」：\n\n![](http://127.0.0.1:3000/public/uploads/1697719920552.png)\n\n\n容量只需 1G，挂载路径设置为 `/usr/src/app/run`：\n\n![](http://127.0.0.1:3000/public/uploads/1697719927113.png)\n\n\n> 这个存储的作用是为了保存已登录的账号。已经注册的账号 3 个小时以后还可以重新使用，不用再浪费邮箱去注册新账号。\n\n最终点击右上角的「部署应用」，即可完成部署：\n\n![](http://127.0.0.1:3000/public/uploads/1697719936301.png)\n\n\n最终要等待所有的实例都处于 Running 状态，才算是启动成功了。\n\n![](http://127.0.0.1:3000/public/uploads/1697719948857.png)\n\n\n点击右边的复制按钮，便可复制 API 的外网地址：\n\n![](http://127.0.0.1:3000/public/uploads/1697719960569.png)\n\n我们来测一下这个 API：\n\n![](http://127.0.0.1:3000/public/uploads/1697719966617.png)\n\n\n完美！打完收工！\n\n## 接入微信公众号\n\n什么？你想将这个 API 接入自己的公众号？换个形式吧！直接来看直播吧，我们会通过直播活动手把手教你如何将 GPT-4 免费接入公众号、网页等各种前端。\n\n活动链接：**[forum.laf.run/d/684](https://link.juejin.cn/?target=https%3A%2F%2Fforum.laf.run%2Fd%2F684 \"https://forum.laf.run/d/684\")**\n\n当然，直播过程不会直接教你如何接入公众号，而是“**授你🫵以渔**”，告诉你如何使用 [Laf](https://link.juejin.cn/?target=https%3A%2F%2Flaf.run \"https://laf.run\") 来通过各种姿势调用这个 API，最终你也接入公众号也罢，网页前端也罢，那都不是事儿~', NULL, 4, 0, 0, 2, '2023-10-19 20:53:52', 1);

-- ----------------------------
-- Table structure for article_tag_merge
-- ----------------------------
DROP TABLE IF EXISTS `article_tag_merge`;
CREATE TABLE `article_tag_merge`  (
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE,
  CONSTRAINT `article_tag_merge_ibfk_1` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `article_tag_merge_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of article_tag_merge
-- ----------------------------
INSERT INTO `article_tag_merge` VALUES (76, 1);
INSERT INTO `article_tag_merge` VALUES (57, 2);
INSERT INTO `article_tag_merge` VALUES (54, 9);
INSERT INTO `article_tag_merge` VALUES (64, 11);
INSERT INTO `article_tag_merge` VALUES (7, 7);
INSERT INTO `article_tag_merge` VALUES (37, 10);
INSERT INTO `article_tag_merge` VALUES (56, 6);
INSERT INTO `article_tag_merge` VALUES (48, 10);
INSERT INTO `article_tag_merge` VALUES (17, 2);
INSERT INTO `article_tag_merge` VALUES (3, 1);
INSERT INTO `article_tag_merge` VALUES (6, 11);
INSERT INTO `article_tag_merge` VALUES (4, 3);
INSERT INTO `article_tag_merge` VALUES (35, 1);
INSERT INTO `article_tag_merge` VALUES (67, 1);
INSERT INTO `article_tag_merge` VALUES (102, 11);
INSERT INTO `article_tag_merge` VALUES (2, 9);
INSERT INTO `article_tag_merge` VALUES (92, 8);
INSERT INTO `article_tag_merge` VALUES (100, 8);
INSERT INTO `article_tag_merge` VALUES (58, 10);
INSERT INTO `article_tag_merge` VALUES (12, 7);
INSERT INTO `article_tag_merge` VALUES (89, 8);
INSERT INTO `article_tag_merge` VALUES (18, 7);
INSERT INTO `article_tag_merge` VALUES (41, 9);
INSERT INTO `article_tag_merge` VALUES (3, 9);
INSERT INTO `article_tag_merge` VALUES (18, 3);
INSERT INTO `article_tag_merge` VALUES (54, 8);
INSERT INTO `article_tag_merge` VALUES (3, 3);
INSERT INTO `article_tag_merge` VALUES (102, 5);
INSERT INTO `article_tag_merge` VALUES (84, 8);
INSERT INTO `article_tag_merge` VALUES (102, 8);
INSERT INTO `article_tag_merge` VALUES (67, 11);
INSERT INTO `article_tag_merge` VALUES (12, 1);
INSERT INTO `article_tag_merge` VALUES (99, 3);
INSERT INTO `article_tag_merge` VALUES (37, 7);
INSERT INTO `article_tag_merge` VALUES (35, 10);
INSERT INTO `article_tag_merge` VALUES (18, 10);
INSERT INTO `article_tag_merge` VALUES (92, 5);
INSERT INTO `article_tag_merge` VALUES (64, 6);
INSERT INTO `article_tag_merge` VALUES (37, 1);
INSERT INTO `article_tag_merge` VALUES (48, 11);
INSERT INTO `article_tag_merge` VALUES (62, 6);
INSERT INTO `article_tag_merge` VALUES (1, 2);
INSERT INTO `article_tag_merge` VALUES (62, 5);
INSERT INTO `article_tag_merge` VALUES (27, 5);
INSERT INTO `article_tag_merge` VALUES (99, 6);
INSERT INTO `article_tag_merge` VALUES (41, 7);
INSERT INTO `article_tag_merge` VALUES (54, 11);
INSERT INTO `article_tag_merge` VALUES (48, 2);
INSERT INTO `article_tag_merge` VALUES (89, 11);
INSERT INTO `article_tag_merge` VALUES (64, 3);
INSERT INTO `article_tag_merge` VALUES (41, 10);
INSERT INTO `article_tag_merge` VALUES (1, 6);
INSERT INTO `article_tag_merge` VALUES (27, 8);
INSERT INTO `article_tag_merge` VALUES (76, 8);
INSERT INTO `article_tag_merge` VALUES (58, 1);
INSERT INTO `article_tag_merge` VALUES (4, 7);
INSERT INTO `article_tag_merge` VALUES (100, 7);
INSERT INTO `article_tag_merge` VALUES (7, 10);
INSERT INTO `article_tag_merge` VALUES (100, 5);
INSERT INTO `article_tag_merge` VALUES (58, 6);
INSERT INTO `article_tag_merge` VALUES (84, 7);
INSERT INTO `article_tag_merge` VALUES (6, 6);
INSERT INTO `article_tag_merge` VALUES (6, 9);
INSERT INTO `article_tag_merge` VALUES (92, 9);
INSERT INTO `article_tag_merge` VALUES (17, 7);
INSERT INTO `article_tag_merge` VALUES (76, 5);
INSERT INTO `article_tag_merge` VALUES (12, 5);
INSERT INTO `article_tag_merge` VALUES (57, 11);
INSERT INTO `article_tag_merge` VALUES (2, 5);
INSERT INTO `article_tag_merge` VALUES (2, 6);
INSERT INTO `article_tag_merge` VALUES (57, 6);
INSERT INTO `article_tag_merge` VALUES (103, 1);
INSERT INTO `article_tag_merge` VALUES (103, 3);
INSERT INTO `article_tag_merge` VALUES (135, 1);
INSERT INTO `article_tag_merge` VALUES (135, 9);
INSERT INTO `article_tag_merge` VALUES (149, 2);
INSERT INTO `article_tag_merge` VALUES (53, 1);
INSERT INTO `article_tag_merge` VALUES (53, 2);
INSERT INTO `article_tag_merge` VALUES (71, 11);
INSERT INTO `article_tag_merge` VALUES (71, 8);
INSERT INTO `article_tag_merge` VALUES (71, 6);
INSERT INTO `article_tag_merge` VALUES (8, 1);
INSERT INTO `article_tag_merge` VALUES (15, 10);
INSERT INTO `article_tag_merge` VALUES (15, 7);
INSERT INTO `article_tag_merge` VALUES (15, 8);
INSERT INTO `article_tag_merge` VALUES (20, 5);
INSERT INTO `article_tag_merge` VALUES (20, 7);
INSERT INTO `article_tag_merge` VALUES (20, 2);
INSERT INTO `article_tag_merge` VALUES (22, 9);
INSERT INTO `article_tag_merge` VALUES (22, 3);
INSERT INTO `article_tag_merge` VALUES (22, 10);
INSERT INTO `article_tag_merge` VALUES (23, 6);
INSERT INTO `article_tag_merge` VALUES (23, 9);
INSERT INTO `article_tag_merge` VALUES (23, 3);
INSERT INTO `article_tag_merge` VALUES (24, 8);
INSERT INTO `article_tag_merge` VALUES (24, 1);
INSERT INTO `article_tag_merge` VALUES (25, 3);
INSERT INTO `article_tag_merge` VALUES (25, 11);
INSERT INTO `article_tag_merge` VALUES (25, 6);
INSERT INTO `article_tag_merge` VALUES (31, 8);
INSERT INTO `article_tag_merge` VALUES (31, 1);
INSERT INTO `article_tag_merge` VALUES (31, 11);
INSERT INTO `article_tag_merge` VALUES (86, 11);
INSERT INTO `article_tag_merge` VALUES (86, 5);
INSERT INTO `article_tag_merge` VALUES (86, 10);
INSERT INTO `article_tag_merge` VALUES (87, 12);
INSERT INTO `article_tag_merge` VALUES (87, 5);
INSERT INTO `article_tag_merge` VALUES (95, 6);
INSERT INTO `article_tag_merge` VALUES (95, 10);
INSERT INTO `article_tag_merge` VALUES (95, 15);
INSERT INTO `article_tag_merge` VALUES (44, 1);
INSERT INTO `article_tag_merge` VALUES (44, 11);
INSERT INTO `article_tag_merge` VALUES (46, 6);
INSERT INTO `article_tag_merge` VALUES (46, 9);
INSERT INTO `article_tag_merge` VALUES (46, 5);
INSERT INTO `article_tag_merge` VALUES (47, 10);
INSERT INTO `article_tag_merge` VALUES (47, 3);
INSERT INTO `article_tag_merge` VALUES (47, 5);
INSERT INTO `article_tag_merge` VALUES (51, 11);
INSERT INTO `article_tag_merge` VALUES (51, 9);
INSERT INTO `article_tag_merge` VALUES (75, 14);
INSERT INTO `article_tag_merge` VALUES (75, 7);
INSERT INTO `article_tag_merge` VALUES (97, 5);
INSERT INTO `article_tag_merge` VALUES (97, 3);
INSERT INTO `article_tag_merge` VALUES (156, 2);
INSERT INTO `article_tag_merge` VALUES (156, 7);
INSERT INTO `article_tag_merge` VALUES (79, 8);
INSERT INTO `article_tag_merge` VALUES (79, 1);
INSERT INTO `article_tag_merge` VALUES (79, 2);
INSERT INTO `article_tag_merge` VALUES (68, 10);
INSERT INTO `article_tag_merge` VALUES (68, 1);
INSERT INTO `article_tag_merge` VALUES (38, 11);
INSERT INTO `article_tag_merge` VALUES (38, 9);
INSERT INTO `article_tag_merge` VALUES (38, 8);
INSERT INTO `article_tag_merge` VALUES (10, 8);
INSERT INTO `article_tag_merge` VALUES (10, 3);
INSERT INTO `article_tag_merge` VALUES (42, 6);
INSERT INTO `article_tag_merge` VALUES (42, 1);
INSERT INTO `article_tag_merge` VALUES (42, 5);
INSERT INTO `article_tag_merge` VALUES (98, 10);
INSERT INTO `article_tag_merge` VALUES (98, 5);
INSERT INTO `article_tag_merge` VALUES (98, 2);
INSERT INTO `article_tag_merge` VALUES (96, 9);
INSERT INTO `article_tag_merge` VALUES (96, 5);
INSERT INTO `article_tag_merge` VALUES (96, 2);
INSERT INTO `article_tag_merge` VALUES (73, 7);
INSERT INTO `article_tag_merge` VALUES (70, 10);
INSERT INTO `article_tag_merge` VALUES (69, 2);
INSERT INTO `article_tag_merge` VALUES (69, 5);
INSERT INTO `article_tag_merge` VALUES (69, 1);
INSERT INTO `article_tag_merge` VALUES (55, 10);
INSERT INTO `article_tag_merge` VALUES (55, 9);
INSERT INTO `article_tag_merge` VALUES (11, 1);
INSERT INTO `article_tag_merge` VALUES (11, 3);
INSERT INTO `article_tag_merge` VALUES (11, 9);
INSERT INTO `article_tag_merge` VALUES (14, 9);
INSERT INTO `article_tag_merge` VALUES (14, 2);
INSERT INTO `article_tag_merge` VALUES (14, 7);
INSERT INTO `article_tag_merge` VALUES (19, 11);
INSERT INTO `article_tag_merge` VALUES (19, 5);
INSERT INTO `article_tag_merge` VALUES (19, 2);
INSERT INTO `article_tag_merge` VALUES (30, 10);
INSERT INTO `article_tag_merge` VALUES (30, 7);
INSERT INTO `article_tag_merge` VALUES (30, 8);
INSERT INTO `article_tag_merge` VALUES (36, 9);
INSERT INTO `article_tag_merge` VALUES (36, 5);
INSERT INTO `article_tag_merge` VALUES (36, 1);
INSERT INTO `article_tag_merge` VALUES (72, 3);
INSERT INTO `article_tag_merge` VALUES (72, 5);
INSERT INTO `article_tag_merge` VALUES (72, 6);
INSERT INTO `article_tag_merge` VALUES (88, 11);
INSERT INTO `article_tag_merge` VALUES (88, 7);
INSERT INTO `article_tag_merge` VALUES (39, 7);
INSERT INTO `article_tag_merge` VALUES (39, 11);
INSERT INTO `article_tag_merge` VALUES (34, 5);
INSERT INTO `article_tag_merge` VALUES (34, 11);
INSERT INTO `article_tag_merge` VALUES (34, 7);
INSERT INTO `article_tag_merge` VALUES (66, 5);
INSERT INTO `article_tag_merge` VALUES (66, 3);
INSERT INTO `article_tag_merge` VALUES (66, 2);
INSERT INTO `article_tag_merge` VALUES (9, 7);
INSERT INTO `article_tag_merge` VALUES (9, 3);
INSERT INTO `article_tag_merge` VALUES (9, 5);
INSERT INTO `article_tag_merge` VALUES (13, 3);
INSERT INTO `article_tag_merge` VALUES (13, 2);
INSERT INTO `article_tag_merge` VALUES (13, 1);
INSERT INTO `article_tag_merge` VALUES (26, 8);
INSERT INTO `article_tag_merge` VALUES (26, 3);
INSERT INTO `article_tag_merge` VALUES (28, 1);
INSERT INTO `article_tag_merge` VALUES (28, 9);
INSERT INTO `article_tag_merge` VALUES (49, 7);
INSERT INTO `article_tag_merge` VALUES (49, 10);
INSERT INTO `article_tag_merge` VALUES (49, 5);
INSERT INTO `article_tag_merge` VALUES (63, 10);
INSERT INTO `article_tag_merge` VALUES (63, 1);
INSERT INTO `article_tag_merge` VALUES (65, 9);
INSERT INTO `article_tag_merge` VALUES (65, 8);
INSERT INTO `article_tag_merge` VALUES (65, 6);
INSERT INTO `article_tag_merge` VALUES (78, 3);
INSERT INTO `article_tag_merge` VALUES (78, 5);
INSERT INTO `article_tag_merge` VALUES (5, 11);
INSERT INTO `article_tag_merge` VALUES (5, 3);
INSERT INTO `article_tag_merge` VALUES (21, 2);
INSERT INTO `article_tag_merge` VALUES (21, 7);
INSERT INTO `article_tag_merge` VALUES (21, 1);
INSERT INTO `article_tag_merge` VALUES (29, 8);
INSERT INTO `article_tag_merge` VALUES (29, 3);
INSERT INTO `article_tag_merge` VALUES (32, 11);
INSERT INTO `article_tag_merge` VALUES (32, 10);
INSERT INTO `article_tag_merge` VALUES (32, 2);
INSERT INTO `article_tag_merge` VALUES (43, 11);
INSERT INTO `article_tag_merge` VALUES (43, 8);
INSERT INTO `article_tag_merge` VALUES (43, 5);
INSERT INTO `article_tag_merge` VALUES (77, 8);
INSERT INTO `article_tag_merge` VALUES (77, 6);
INSERT INTO `article_tag_merge` VALUES (82, 10);
INSERT INTO `article_tag_merge` VALUES (82, 9);
INSERT INTO `article_tag_merge` VALUES (82, 2);
INSERT INTO `article_tag_merge` VALUES (90, 14);
INSERT INTO `article_tag_merge` VALUES (91, 3);
INSERT INTO `article_tag_merge` VALUES (91, 5);
INSERT INTO `article_tag_merge` VALUES (91, 7);
INSERT INTO `article_tag_merge` VALUES (93, 11);
INSERT INTO `article_tag_merge` VALUES (93, 6);
INSERT INTO `article_tag_merge` VALUES (101, 9);
INSERT INTO `article_tag_merge` VALUES (101, 2);
INSERT INTO `article_tag_merge` VALUES (83, 8);
INSERT INTO `article_tag_merge` VALUES (83, 9);
INSERT INTO `article_tag_merge` VALUES (94, 9);
INSERT INTO `article_tag_merge` VALUES (94, 10);
INSERT INTO `article_tag_merge` VALUES (94, 1);
INSERT INTO `article_tag_merge` VALUES (80, 1);
INSERT INTO `article_tag_merge` VALUES (80, 8);
INSERT INTO `article_tag_merge` VALUES (80, 3);
INSERT INTO `article_tag_merge` VALUES (52, 9);
INSERT INTO `article_tag_merge` VALUES (52, 5);
INSERT INTO `article_tag_merge` VALUES (52, 3);
INSERT INTO `article_tag_merge` VALUES (74, 9);
INSERT INTO `article_tag_merge` VALUES (74, 5);
INSERT INTO `article_tag_merge` VALUES (59, 5);
INSERT INTO `article_tag_merge` VALUES (59, 14);
INSERT INTO `article_tag_merge` VALUES (85, 11);
INSERT INTO `article_tag_merge` VALUES (85, 1);
INSERT INTO `article_tag_merge` VALUES (85, 3);
INSERT INTO `article_tag_merge` VALUES (61, 11);
INSERT INTO `article_tag_merge` VALUES (61, 15);
INSERT INTO `article_tag_merge` VALUES (61, 9);
INSERT INTO `article_tag_merge` VALUES (40, 8);
INSERT INTO `article_tag_merge` VALUES (40, 7);
INSERT INTO `article_tag_merge` VALUES (40, 9);
INSERT INTO `article_tag_merge` VALUES (167, 9);
INSERT INTO `article_tag_merge` VALUES (33, 1);
INSERT INTO `article_tag_merge` VALUES (33, 3);
INSERT INTO `article_tag_merge` VALUES (16, 8);
INSERT INTO `article_tag_merge` VALUES (16, 11);
INSERT INTO `article_tag_merge` VALUES (60, 5);
INSERT INTO `article_tag_merge` VALUES (60, 1);
INSERT INTO `article_tag_merge` VALUES (81, 10);
INSERT INTO `article_tag_merge` VALUES (81, 1);
INSERT INTO `article_tag_merge` VALUES (81, 9);
INSERT INTO `article_tag_merge` VALUES (123, 2);
INSERT INTO `article_tag_merge` VALUES (169, 2);
INSERT INTO `article_tag_merge` VALUES (169, 5);
INSERT INTO `article_tag_merge` VALUES (169, 6);
INSERT INTO `article_tag_merge` VALUES (170, 3);
INSERT INTO `article_tag_merge` VALUES (171, 7);
INSERT INTO `article_tag_merge` VALUES (171, 6);
INSERT INTO `article_tag_merge` VALUES (45, 6);
INSERT INTO `article_tag_merge` VALUES (45, 8);
INSERT INTO `article_tag_merge` VALUES (45, 11);
INSERT INTO `article_tag_merge` VALUES (50, 11);
INSERT INTO `article_tag_merge` VALUES (50, 1);

-- ----------------------------
-- Table structure for article_type
-- ----------------------------
DROP TABLE IF EXISTS `article_type`;
CREATE TABLE `article_type`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of article_type
-- ----------------------------
INSERT INTO `article_type` VALUES (1, '未分类', NULL, '2023-09-05 08:56:34');
INSERT INTO `article_type` VALUES (2, '前端', 'frontend', '2023-09-05 08:50:33');
INSERT INTO `article_type` VALUES (3, '后端', 'backend', '2023-09-05 08:50:22');
INSERT INTO `article_type` VALUES (4, 'Android', 'android', '2023-09-05 08:50:17');
INSERT INTO `article_type` VALUES (5, 'iOS', 'ios', '2023-09-05 08:50:09');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '父评论的ID(如果是回复评论)',
  `reply_id` int(11) NULL DEFAULT NULL COMMENT '回复某个人的评论(如果有)',
  `like_num` int(11) NULL DEFAULT 0,
  `is_delete` int(11) NULL DEFAULT 1 COMMENT '1为未删除，0为已删除',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of comment
-- ----------------------------

-- ----------------------------
-- Table structure for follow
-- ----------------------------
DROP TABLE IF EXISTS `follow`;
CREATE TABLE `follow`  (
  `user_id` int(11) NOT NULL,
  `followed_user_id` int(11) NOT NULL,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `followed_user_id`(`followed_user_id`) USING BTREE,
  CONSTRAINT `follow_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `follow_ibfk_2` FOREIGN KEY (`followed_user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of follow
-- ----------------------------
INSERT INTO `follow` VALUES (1, 5);
INSERT INTO `follow` VALUES (3, 8);
INSERT INTO `follow` VALUES (1, 2);
INSERT INTO `follow` VALUES (1, 7);
INSERT INTO `follow` VALUES (2, 3);
INSERT INTO `follow` VALUES (2, 6);
INSERT INTO `follow` VALUES (2, 1);
INSERT INTO `follow` VALUES (2, 58962735);
INSERT INTO `follow` VALUES (58962735, 2);

-- ----------------------------
-- Table structure for like
-- ----------------------------
DROP TABLE IF EXISTS `like`;
CREATE TABLE `like`  (
  `user_id` int(11) NOT NULL,
  `content_id` int(11) NOT NULL,
  `type_id` int(11) NULL DEFAULT NULL COMMENT '0表示文章，1表示一级评论，2表示子级评论',
  INDEX `user_id`(`user_id`) USING BTREE,
  CONSTRAINT `like_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of like
-- ----------------------------
INSERT INTO `like` VALUES (6, 50, 0);
INSERT INTO `like` VALUES (2, 140, 1);
INSERT INTO `like` VALUES (6, 141, 1);
INSERT INTO `like` VALUES (7, 142, 0);
INSERT INTO `like` VALUES (5, 118, 1);
INSERT INTO `like` VALUES (6, 106, 1);
INSERT INTO `like` VALUES (1, 121, 0);
INSERT INTO `like` VALUES (5, 28, 1);
INSERT INTO `like` VALUES (3, 38, 1);
INSERT INTO `like` VALUES (5, 72, 2);
INSERT INTO `like` VALUES (3, 139, 2);
INSERT INTO `like` VALUES (8, 58, 0);
INSERT INTO `like` VALUES (5, 72, 2);
INSERT INTO `like` VALUES (2, 117, 2);
INSERT INTO `like` VALUES (4, 84, 2);
INSERT INTO `like` VALUES (6, 119, 0);
INSERT INTO `like` VALUES (7, 105, 1);
INSERT INTO `like` VALUES (7, 91, 0);
INSERT INTO `like` VALUES (3, 84, 1);
INSERT INTO `like` VALUES (1, 66, 1);
INSERT INTO `like` VALUES (7, 136, 1);
INSERT INTO `like` VALUES (3, 125, 1);
INSERT INTO `like` VALUES (5, 69, 1);
INSERT INTO `like` VALUES (1, 126, 2);
INSERT INTO `like` VALUES (7, 6, 1);
INSERT INTO `like` VALUES (6, 54, 2);
INSERT INTO `like` VALUES (4, 138, 1);
INSERT INTO `like` VALUES (7, 75, 1);
INSERT INTO `like` VALUES (8, 54, 1);
INSERT INTO `like` VALUES (4, 99, 2);
INSERT INTO `like` VALUES (5, 113, 2);
INSERT INTO `like` VALUES (2, 92, 1);
INSERT INTO `like` VALUES (4, 114, 1);
INSERT INTO `like` VALUES (6, 60, 1);
INSERT INTO `like` VALUES (1, 82, 0);
INSERT INTO `like` VALUES (4, 48, 1);
INSERT INTO `like` VALUES (2, 31, 1);
INSERT INTO `like` VALUES (7, 119, 1);
INSERT INTO `like` VALUES (6, 115, 2);
INSERT INTO `like` VALUES (2, 150, 1);
INSERT INTO `like` VALUES (5, 56, 1);
INSERT INTO `like` VALUES (1, 59, 2);
INSERT INTO `like` VALUES (7, 86, 1);
INSERT INTO `like` VALUES (1, 127, 1);
INSERT INTO `like` VALUES (4, 87, 2);
INSERT INTO `like` VALUES (7, 126, 0);
INSERT INTO `like` VALUES (1, 148, 2);
INSERT INTO `like` VALUES (7, 80, 0);
INSERT INTO `like` VALUES (4, 97, 1);
INSERT INTO `like` VALUES (1, 59, 2);
INSERT INTO `like` VALUES (3, 126, 1);
INSERT INTO `like` VALUES (8, 21, 1);
INSERT INTO `like` VALUES (5, 139, 1);
INSERT INTO `like` VALUES (4, 0, 1);
INSERT INTO `like` VALUES (5, 47, 1);
INSERT INTO `like` VALUES (2, 142, 1);
INSERT INTO `like` VALUES (6, 118, 0);
INSERT INTO `like` VALUES (2, 90, 2);
INSERT INTO `like` VALUES (7, 62, 1);
INSERT INTO `like` VALUES (8, 117, 1);
INSERT INTO `like` VALUES (1, 110, 2);
INSERT INTO `like` VALUES (5, 146, 0);
INSERT INTO `like` VALUES (7, 150, 2);
INSERT INTO `like` VALUES (2, 15, 2);
INSERT INTO `like` VALUES (3, 12, 1);
INSERT INTO `like` VALUES (8, 4, 1);
INSERT INTO `like` VALUES (8, 131, 2);
INSERT INTO `like` VALUES (2, 44, 2);
INSERT INTO `like` VALUES (8, 39, 1);
INSERT INTO `like` VALUES (1, 122, 1);
INSERT INTO `like` VALUES (5, 71, 1);
INSERT INTO `like` VALUES (8, 116, 2);
INSERT INTO `like` VALUES (6, 68, 1);
INSERT INTO `like` VALUES (8, 100, 2);
INSERT INTO `like` VALUES (1, 131, 1);
INSERT INTO `like` VALUES (1, 19, 0);
INSERT INTO `like` VALUES (3, 33, 0);
INSERT INTO `like` VALUES (5, 111, 0);
INSERT INTO `like` VALUES (7, 24, 1);
INSERT INTO `like` VALUES (7, 101, 1);
INSERT INTO `like` VALUES (8, 127, 1);
INSERT INTO `like` VALUES (3, 76, 0);
INSERT INTO `like` VALUES (7, 125, 2);
INSERT INTO `like` VALUES (5, 117, 0);
INSERT INTO `like` VALUES (2, 101, 0);
INSERT INTO `like` VALUES (5, 55, 0);
INSERT INTO `like` VALUES (2, 149, 0);
INSERT INTO `like` VALUES (5, 95, 2);
INSERT INTO `like` VALUES (8, 124, 2);
INSERT INTO `like` VALUES (3, 18, 2);
INSERT INTO `like` VALUES (8, 116, 1);
INSERT INTO `like` VALUES (7, 146, 1);
INSERT INTO `like` VALUES (3, 19, 1);
INSERT INTO `like` VALUES (7, 109, 1);
INSERT INTO `like` VALUES (4, 75, 1);
INSERT INTO `like` VALUES (1, 130, 1);
INSERT INTO `like` VALUES (4, 143, 1);
INSERT INTO `like` VALUES (3, 137, 0);
INSERT INTO `like` VALUES (2, 122, 1);
INSERT INTO `like` VALUES (3, 121, 1);
INSERT INTO `like` VALUES (1, 45, 0);
INSERT INTO `like` VALUES (4, 19, 1);
INSERT INTO `like` VALUES (4, 19, 1);
INSERT INTO `like` VALUES (2, 62, 0);
INSERT INTO `like` VALUES (7, 84, 2);
INSERT INTO `like` VALUES (2, 106, 0);
INSERT INTO `like` VALUES (4, 114, 1);
INSERT INTO `like` VALUES (3, 109, 1);
INSERT INTO `like` VALUES (8, 104, 0);
INSERT INTO `like` VALUES (7, 96, 1);
INSERT INTO `like` VALUES (8, 23, 1);
INSERT INTO `like` VALUES (7, 78, 1);
INSERT INTO `like` VALUES (8, 140, 0);
INSERT INTO `like` VALUES (7, 148, 1);
INSERT INTO `like` VALUES (1, 128, 0);
INSERT INTO `like` VALUES (4, 30, 2);
INSERT INTO `like` VALUES (5, 89, 2);
INSERT INTO `like` VALUES (6, 48, 2);
INSERT INTO `like` VALUES (2, 89, 2);
INSERT INTO `like` VALUES (6, 97, 2);
INSERT INTO `like` VALUES (3, 112, 0);
INSERT INTO `like` VALUES (5, 90, 1);
INSERT INTO `like` VALUES (3, 85, 2);
INSERT INTO `like` VALUES (8, 97, 1);
INSERT INTO `like` VALUES (1, 119, 1);
INSERT INTO `like` VALUES (3, 96, 1);
INSERT INTO `like` VALUES (5, 102, 1);
INSERT INTO `like` VALUES (6, 131, 0);
INSERT INTO `like` VALUES (5, 27, 2);
INSERT INTO `like` VALUES (8, 57, 1);
INSERT INTO `like` VALUES (3, 144, 2);
INSERT INTO `like` VALUES (8, 95, 0);
INSERT INTO `like` VALUES (6, 151, 1);
INSERT INTO `like` VALUES (8, 119, 0);
INSERT INTO `like` VALUES (7, 128, 1);
INSERT INTO `like` VALUES (8, 3, 1);
INSERT INTO `like` VALUES (6, 65, 1);
INSERT INTO `like` VALUES (2, 13, 1);
INSERT INTO `like` VALUES (1, 58, 2);
INSERT INTO `like` VALUES (6, 151, 2);
INSERT INTO `like` VALUES (3, 125, 2);
INSERT INTO `like` VALUES (2, 148, 2);
INSERT INTO `like` VALUES (5, 66, 2);
INSERT INTO `like` VALUES (6, 130, 0);
INSERT INTO `like` VALUES (5, 16, 2);
INSERT INTO `like` VALUES (7, 42, 2);
INSERT INTO `like` VALUES (5, 62, 1);
INSERT INTO `like` VALUES (6, 78, 0);
INSERT INTO `like` VALUES (8, 119, 1);
INSERT INTO `like` VALUES (8, 114, 0);
INSERT INTO `like` VALUES (4, 133, 0);
INSERT INTO `like` VALUES (6, 141, 1);
INSERT INTO `like` VALUES (3, 50, 2);
INSERT INTO `like` VALUES (5, 78, 2);
INSERT INTO `like` VALUES (4, 148, 2);
INSERT INTO `like` VALUES (5, 121, 2);
INSERT INTO `like` VALUES (4, 90, 1);
INSERT INTO `like` VALUES (4, 107, 0);
INSERT INTO `like` VALUES (5, 77, 0);
INSERT INTO `like` VALUES (3, 56, 1);
INSERT INTO `like` VALUES (7, 10, 2);
INSERT INTO `like` VALUES (5, 33, 0);
INSERT INTO `like` VALUES (3, 79, 1);
INSERT INTO `like` VALUES (7, 81, 1);
INSERT INTO `like` VALUES (2, 68, 0);
INSERT INTO `like` VALUES (3, 43, 1);
INSERT INTO `like` VALUES (1, 137, 0);
INSERT INTO `like` VALUES (1, 3, 1);
INSERT INTO `like` VALUES (4, 45, 1);
INSERT INTO `like` VALUES (2, 35, 1);
INSERT INTO `like` VALUES (5, 54, 0);
INSERT INTO `like` VALUES (4, 65, 1);
INSERT INTO `like` VALUES (6, 112, 0);
INSERT INTO `like` VALUES (1, 135, 2);
INSERT INTO `like` VALUES (4, 86, 2);
INSERT INTO `like` VALUES (1, 22, 0);
INSERT INTO `like` VALUES (2, 111, 2);
INSERT INTO `like` VALUES (5, 36, 1);
INSERT INTO `like` VALUES (1, 86, 2);
INSERT INTO `like` VALUES (2, 116, 0);
INSERT INTO `like` VALUES (6, 9, 1);
INSERT INTO `like` VALUES (5, 63, 0);
INSERT INTO `like` VALUES (1, 1, 1);
INSERT INTO `like` VALUES (2, 141, 0);
INSERT INTO `like` VALUES (8, 29, 1);
INSERT INTO `like` VALUES (3, 118, 1);
INSERT INTO `like` VALUES (1, 106, 2);
INSERT INTO `like` VALUES (8, 75, 1);
INSERT INTO `like` VALUES (4, 42, 1);
INSERT INTO `like` VALUES (1, 10, 2);
INSERT INTO `like` VALUES (3, 38, 1);
INSERT INTO `like` VALUES (7, 91, 0);
INSERT INTO `like` VALUES (5, 38, 0);
INSERT INTO `like` VALUES (6, 88, 1);
INSERT INTO `like` VALUES (7, 85, 0);
INSERT INTO `like` VALUES (2, 86, 1);
INSERT INTO `like` VALUES (5, 67, 1);
INSERT INTO `like` VALUES (4, 64, 1);
INSERT INTO `like` VALUES (1, 92, 0);
INSERT INTO `like` VALUES (7, 53, 1);
INSERT INTO `like` VALUES (3, 45, 1);
INSERT INTO `like` VALUES (2, 111, 1);
INSERT INTO `like` VALUES (8, 61, 1);
INSERT INTO `like` VALUES (4, 7, 1);
INSERT INTO `like` VALUES (4, 141, 1);
INSERT INTO `like` VALUES (6, 88, 0);
INSERT INTO `like` VALUES (7, 66, 1);
INSERT INTO `like` VALUES (8, 45, 1);
INSERT INTO `like` VALUES (2, 86, 2);
INSERT INTO `like` VALUES (1, 124, 2);
INSERT INTO `like` VALUES (2, 63, 1);
INSERT INTO `like` VALUES (1, 117, 0);
INSERT INTO `like` VALUES (7, 1, 1);
INSERT INTO `like` VALUES (4, 137, 2);
INSERT INTO `like` VALUES (3, 134, 0);
INSERT INTO `like` VALUES (2, 0, 0);
INSERT INTO `like` VALUES (5, 103, 2);
INSERT INTO `like` VALUES (6, 110, 2);
INSERT INTO `like` VALUES (1, 28, 0);
INSERT INTO `like` VALUES (2, 136, 2);
INSERT INTO `like` VALUES (8, 71, 1);
INSERT INTO `like` VALUES (1, 103, 1);
INSERT INTO `like` VALUES (3, 23, 1);
INSERT INTO `like` VALUES (8, 90, 0);
INSERT INTO `like` VALUES (1, 126, 1);
INSERT INTO `like` VALUES (3, 7, 2);
INSERT INTO `like` VALUES (5, 24, 1);
INSERT INTO `like` VALUES (6, 47, 1);
INSERT INTO `like` VALUES (3, 46, 0);
INSERT INTO `like` VALUES (6, 125, 1);
INSERT INTO `like` VALUES (3, 4, 0);
INSERT INTO `like` VALUES (3, 53, 1);
INSERT INTO `like` VALUES (1, 98, 0);
INSERT INTO `like` VALUES (3, 28, 2);
INSERT INTO `like` VALUES (3, 68, 1);
INSERT INTO `like` VALUES (8, 131, 0);
INSERT INTO `like` VALUES (2, 74, 1);
INSERT INTO `like` VALUES (4, 54, 1);
INSERT INTO `like` VALUES (6, 42, 0);
INSERT INTO `like` VALUES (6, 113, 2);
INSERT INTO `like` VALUES (4, 116, 1);
INSERT INTO `like` VALUES (3, 118, 0);
INSERT INTO `like` VALUES (3, 107, 0);
INSERT INTO `like` VALUES (3, 20, 0);
INSERT INTO `like` VALUES (1, 137, 0);
INSERT INTO `like` VALUES (8, 69, 1);
INSERT INTO `like` VALUES (6, 80, 2);
INSERT INTO `like` VALUES (4, 66, 1);
INSERT INTO `like` VALUES (1, 39, 2);
INSERT INTO `like` VALUES (8, 17, 1);
INSERT INTO `like` VALUES (7, 98, 2);
INSERT INTO `like` VALUES (5, 35, 2);
INSERT INTO `like` VALUES (1, 15, 0);
INSERT INTO `like` VALUES (3, 0, 1);
INSERT INTO `like` VALUES (8, 105, 1);
INSERT INTO `like` VALUES (7, 60, 1);
INSERT INTO `like` VALUES (2, 5, 0);
INSERT INTO `like` VALUES (3, 101, 1);
INSERT INTO `like` VALUES (4, 138, 0);
INSERT INTO `like` VALUES (1, 113, 1);
INSERT INTO `like` VALUES (7, 22, 2);
INSERT INTO `like` VALUES (6, 69, 2);
INSERT INTO `like` VALUES (1, 145, 1);
INSERT INTO `like` VALUES (3, 50, 0);
INSERT INTO `like` VALUES (8, 18, 0);
INSERT INTO `like` VALUES (4, 99, 0);
INSERT INTO `like` VALUES (3, 94, 0);
INSERT INTO `like` VALUES (1, 63, 1);
INSERT INTO `like` VALUES (2, 127, 1);
INSERT INTO `like` VALUES (6, 50, 2);
INSERT INTO `like` VALUES (2, 102, 0);
INSERT INTO `like` VALUES (6, 1, 0);
INSERT INTO `like` VALUES (7, 15, 0);
INSERT INTO `like` VALUES (3, 88, 0);
INSERT INTO `like` VALUES (2, 110, 2);
INSERT INTO `like` VALUES (8, 48, 2);
INSERT INTO `like` VALUES (6, 89, 0);
INSERT INTO `like` VALUES (5, 130, 1);
INSERT INTO `like` VALUES (2, 11, 2);
INSERT INTO `like` VALUES (2, 23, 0);
INSERT INTO `like` VALUES (6, 118, 1);
INSERT INTO `like` VALUES (6, 13, 2);
INSERT INTO `like` VALUES (6, 89, 1);
INSERT INTO `like` VALUES (3, 5, 2);
INSERT INTO `like` VALUES (1, 1, 0);
INSERT INTO `like` VALUES (5, 38, 1);
INSERT INTO `like` VALUES (4, 134, 2);
INSERT INTO `like` VALUES (7, 48, 2);
INSERT INTO `like` VALUES (3, 16, 0);
INSERT INTO `like` VALUES (8, 145, 1);
INSERT INTO `like` VALUES (1, 52, 0);
INSERT INTO `like` VALUES (6, 64, 1);
INSERT INTO `like` VALUES (3, 97, 0);
INSERT INTO `like` VALUES (8, 115, 2);
INSERT INTO `like` VALUES (6, 149, 1);
INSERT INTO `like` VALUES (3, 118, 1);
INSERT INTO `like` VALUES (1, 129, 1);
INSERT INTO `like` VALUES (6, 150, 0);
INSERT INTO `like` VALUES (4, 6, 0);
INSERT INTO `like` VALUES (4, 105, 0);
INSERT INTO `like` VALUES (4, 141, 0);
INSERT INTO `like` VALUES (7, 75, 1);
INSERT INTO `like` VALUES (5, 128, 1);
INSERT INTO `like` VALUES (3, 139, 1);
INSERT INTO `like` VALUES (3, 14, 1);
INSERT INTO `like` VALUES (6, 63, 0);
INSERT INTO `like` VALUES (5, 119, 0);
INSERT INTO `like` VALUES (5, 119, 0);
INSERT INTO `like` VALUES (6, 42, 2);
INSERT INTO `like` VALUES (4, 90, 0);
INSERT INTO `like` VALUES (1, 5, 1);
INSERT INTO `like` VALUES (1, 84, 0);
INSERT INTO `like` VALUES (1, 61, 1);
INSERT INTO `like` VALUES (3, 104, 1);
INSERT INTO `like` VALUES (3, 44, 1);
INSERT INTO `like` VALUES (1, 136, 1);
INSERT INTO `like` VALUES (8, 89, 2);
INSERT INTO `like` VALUES (7, 10, 2);
INSERT INTO `like` VALUES (3, 135, 2);
INSERT INTO `like` VALUES (4, 44, 1);
INSERT INTO `like` VALUES (7, 22, 0);
INSERT INTO `like` VALUES (2, 134, 0);
INSERT INTO `like` VALUES (3, 86, 2);
INSERT INTO `like` VALUES (4, 1, 2);
INSERT INTO `like` VALUES (8, 127, 0);
INSERT INTO `like` VALUES (5, 133, 1);
INSERT INTO `like` VALUES (3, 111, 1);
INSERT INTO `like` VALUES (2, 19, 2);
INSERT INTO `like` VALUES (5, 140, 1);
INSERT INTO `like` VALUES (3, 45, 0);
INSERT INTO `like` VALUES (5, 127, 1);
INSERT INTO `like` VALUES (6, 45, 1);
INSERT INTO `like` VALUES (4, 73, 1);
INSERT INTO `like` VALUES (1, 117, 2);
INSERT INTO `like` VALUES (7, 71, 1);
INSERT INTO `like` VALUES (2, 31, 0);
INSERT INTO `like` VALUES (4, 40, 1);
INSERT INTO `like` VALUES (6, 112, 0);
INSERT INTO `like` VALUES (8, 75, 0);
INSERT INTO `like` VALUES (2, 87, 1);
INSERT INTO `like` VALUES (7, 93, 0);
INSERT INTO `like` VALUES (4, 1, 1);
INSERT INTO `like` VALUES (8, 120, 0);
INSERT INTO `like` VALUES (6, 64, 1);
INSERT INTO `like` VALUES (4, 86, 2);
INSERT INTO `like` VALUES (2, 64, 1);
INSERT INTO `like` VALUES (2, 107, 2);
INSERT INTO `like` VALUES (8, 114, 1);
INSERT INTO `like` VALUES (7, 17, 0);
INSERT INTO `like` VALUES (4, 27, 1);
INSERT INTO `like` VALUES (7, 3, 1);
INSERT INTO `like` VALUES (6, 151, 2);
INSERT INTO `like` VALUES (7, 47, 1);
INSERT INTO `like` VALUES (4, 90, 1);
INSERT INTO `like` VALUES (1, 132, 1);
INSERT INTO `like` VALUES (5, 79, 1);
INSERT INTO `like` VALUES (8, 134, 1);
INSERT INTO `like` VALUES (4, 111, 2);
INSERT INTO `like` VALUES (4, 84, 1);
INSERT INTO `like` VALUES (4, 126, 1);
INSERT INTO `like` VALUES (7, 106, 1);
INSERT INTO `like` VALUES (2, 117, 1);
INSERT INTO `like` VALUES (2, 27, 2);
INSERT INTO `like` VALUES (2, 81, 0);
INSERT INTO `like` VALUES (2, 53, 1);
INSERT INTO `like` VALUES (5, 111, 0);
INSERT INTO `like` VALUES (7, 72, 1);
INSERT INTO `like` VALUES (1, 15, 0);
INSERT INTO `like` VALUES (6, 28, 1);
INSERT INTO `like` VALUES (5, 91, 1);
INSERT INTO `like` VALUES (7, 148, 2);
INSERT INTO `like` VALUES (5, 18, 1);
INSERT INTO `like` VALUES (8, 70, 0);
INSERT INTO `like` VALUES (7, 109, 1);
INSERT INTO `like` VALUES (4, 42, 2);
INSERT INTO `like` VALUES (1, 53, 2);
INSERT INTO `like` VALUES (4, 85, 0);
INSERT INTO `like` VALUES (1, 124, 1);
INSERT INTO `like` VALUES (7, 89, 1);
INSERT INTO `like` VALUES (2, 138, 1);
INSERT INTO `like` VALUES (6, 31, 2);
INSERT INTO `like` VALUES (7, 122, 1);
INSERT INTO `like` VALUES (8, 5, 1);
INSERT INTO `like` VALUES (7, 104, 0);
INSERT INTO `like` VALUES (4, 74, 1);
INSERT INTO `like` VALUES (2, 85, 0);
INSERT INTO `like` VALUES (6, 61, 2);
INSERT INTO `like` VALUES (6, 119, 1);
INSERT INTO `like` VALUES (6, 53, 2);
INSERT INTO `like` VALUES (8, 8, 0);
INSERT INTO `like` VALUES (3, 22, 2);
INSERT INTO `like` VALUES (5, 25, 2);
INSERT INTO `like` VALUES (7, 139, 2);
INSERT INTO `like` VALUES (6, 38, 0);
INSERT INTO `like` VALUES (3, 130, 1);
INSERT INTO `like` VALUES (7, 42, 1);
INSERT INTO `like` VALUES (4, 125, 1);
INSERT INTO `like` VALUES (6, 126, 0);
INSERT INTO `like` VALUES (1, 23, 2);
INSERT INTO `like` VALUES (6, 32, 1);
INSERT INTO `like` VALUES (4, 77, 1);
INSERT INTO `like` VALUES (4, 143, 0);
INSERT INTO `like` VALUES (3, 110, 1);
INSERT INTO `like` VALUES (7, 45, 2);
INSERT INTO `like` VALUES (8, 16, 1);
INSERT INTO `like` VALUES (4, 6, 0);
INSERT INTO `like` VALUES (7, 39, 1);
INSERT INTO `like` VALUES (1, 40, 1);
INSERT INTO `like` VALUES (4, 91, 2);
INSERT INTO `like` VALUES (8, 89, 2);
INSERT INTO `like` VALUES (8, 110, 1);
INSERT INTO `like` VALUES (7, 15, 1);
INSERT INTO `like` VALUES (5, 106, 2);
INSERT INTO `like` VALUES (1, 31, 1);
INSERT INTO `like` VALUES (8, 10, 0);
INSERT INTO `like` VALUES (3, 106, 2);
INSERT INTO `like` VALUES (1, 40, 1);
INSERT INTO `like` VALUES (8, 56, 0);
INSERT INTO `like` VALUES (4, 89, 1);
INSERT INTO `like` VALUES (6, 121, 0);
INSERT INTO `like` VALUES (5, 52, 0);
INSERT INTO `like` VALUES (7, 93, 1);
INSERT INTO `like` VALUES (5, 101, 1);
INSERT INTO `like` VALUES (7, 93, 1);
INSERT INTO `like` VALUES (5, 5, 0);
INSERT INTO `like` VALUES (8, 55, 2);
INSERT INTO `like` VALUES (5, 41, 2);
INSERT INTO `like` VALUES (3, 90, 1);
INSERT INTO `like` VALUES (5, 102, 1);
INSERT INTO `like` VALUES (2, 17, 2);
INSERT INTO `like` VALUES (8, 58, 1);
INSERT INTO `like` VALUES (4, 32, 2);
INSERT INTO `like` VALUES (2, 36, 0);
INSERT INTO `like` VALUES (6, 22, 0);
INSERT INTO `like` VALUES (7, 65, 1);
INSERT INTO `like` VALUES (6, 134, 1);
INSERT INTO `like` VALUES (4, 143, 1);
INSERT INTO `like` VALUES (3, 128, 1);
INSERT INTO `like` VALUES (1, 2, 0);
INSERT INTO `like` VALUES (7, 17, 1);
INSERT INTO `like` VALUES (4, 124, 1);
INSERT INTO `like` VALUES (6, 23, 1);
INSERT INTO `like` VALUES (2, 107, 0);
INSERT INTO `like` VALUES (1, 112, 1);
INSERT INTO `like` VALUES (6, 87, 2);
INSERT INTO `like` VALUES (4, 50, 0);
INSERT INTO `like` VALUES (2, 46, 0);
INSERT INTO `like` VALUES (5, 17, 1);
INSERT INTO `like` VALUES (5, 145, 1);
INSERT INTO `like` VALUES (3, 110, 1);
INSERT INTO `like` VALUES (3, 28, 2);
INSERT INTO `like` VALUES (4, 14, 1);
INSERT INTO `like` VALUES (7, 140, 1);
INSERT INTO `like` VALUES (3, 66, 1);
INSERT INTO `like` VALUES (1, 115, 2);
INSERT INTO `like` VALUES (4, 120, 1);
INSERT INTO `like` VALUES (8, 140, 0);
INSERT INTO `like` VALUES (5, 146, 1);
INSERT INTO `like` VALUES (5, 57, 1);
INSERT INTO `like` VALUES (6, 103, 1);
INSERT INTO `like` VALUES (1, 115, 1);
INSERT INTO `like` VALUES (4, 92, 1);
INSERT INTO `like` VALUES (7, 33, 1);
INSERT INTO `like` VALUES (3, 19, 0);
INSERT INTO `like` VALUES (7, 25, 0);
INSERT INTO `like` VALUES (1, 95, 2);
INSERT INTO `like` VALUES (6, 45, 0);
INSERT INTO `like` VALUES (5, 87, 0);
INSERT INTO `like` VALUES (8, 29, 0);
INSERT INTO `like` VALUES (3, 116, 1);
INSERT INTO `like` VALUES (4, 124, 1);
INSERT INTO `like` VALUES (1, 132, 0);
INSERT INTO `like` VALUES (6, 125, 0);
INSERT INTO `like` VALUES (2, 106, 0);
INSERT INTO `like` VALUES (6, 19, 2);
INSERT INTO `like` VALUES (3, 32, 0);
INSERT INTO `like` VALUES (1, 20, 2);
INSERT INTO `like` VALUES (3, 112, 0);
INSERT INTO `like` VALUES (8, 85, 0);
INSERT INTO `like` VALUES (2, 57, 1);
INSERT INTO `like` VALUES (8, 55, 0);
INSERT INTO `like` VALUES (1, 16, 1);
INSERT INTO `like` VALUES (7, 145, 1);
INSERT INTO `like` VALUES (6, 111, 2);
INSERT INTO `like` VALUES (2, 4, 2);
INSERT INTO `like` VALUES (5, 94, 0);
INSERT INTO `like` VALUES (2, 133, 0);
INSERT INTO `like` VALUES (1, 134, 0);
INSERT INTO `like` VALUES (1, 47, 0);
INSERT INTO `like` VALUES (2, 142, 0);
INSERT INTO `like` VALUES (3, 106, 1);
INSERT INTO `like` VALUES (7, 118, 1);
INSERT INTO `like` VALUES (4, 136, 1);
INSERT INTO `like` VALUES (3, 32, 0);
INSERT INTO `like` VALUES (4, 140, 0);
INSERT INTO `like` VALUES (7, 37, 1);
INSERT INTO `like` VALUES (1, 126, 1);
INSERT INTO `like` VALUES (8, 100, 1);
INSERT INTO `like` VALUES (1, 122, 1);
INSERT INTO `like` VALUES (4, 17, 1);
INSERT INTO `like` VALUES (6, 66, 1);
INSERT INTO `like` VALUES (1, 61, 1);
INSERT INTO `like` VALUES (8, 8, 1);
INSERT INTO `like` VALUES (7, 79, 1);
INSERT INTO `like` VALUES (8, 59, 1);
INSERT INTO `like` VALUES (2, 13, 2);
INSERT INTO `like` VALUES (1, 4, 1);
INSERT INTO `like` VALUES (6, 76, 1);
INSERT INTO `like` VALUES (5, 63, 2);
INSERT INTO `like` VALUES (8, 137, 0);
INSERT INTO `like` VALUES (2, 26, 0);
INSERT INTO `like` VALUES (2, 107, 2);
INSERT INTO `like` VALUES (7, 105, 1);
INSERT INTO `like` VALUES (1, 98, 1);
INSERT INTO `like` VALUES (2, 94, 2);
INSERT INTO `like` VALUES (3, 90, 1);
INSERT INTO `like` VALUES (2, 128, 2);
INSERT INTO `like` VALUES (6, 117, 2);
INSERT INTO `like` VALUES (4, 131, 2);
INSERT INTO `like` VALUES (6, 143, 2);
INSERT INTO `like` VALUES (2, 121, 2);
INSERT INTO `like` VALUES (2, 124, 1);
INSERT INTO `like` VALUES (3, 24, 0);
INSERT INTO `like` VALUES (2, 132, 2);
INSERT INTO `like` VALUES (4, 100, 1);
INSERT INTO `like` VALUES (2, 2, 1);
INSERT INTO `like` VALUES (5, 112, 1);
INSERT INTO `like` VALUES (4, 129, 1);
INSERT INTO `like` VALUES (2, 88, 1);
INSERT INTO `like` VALUES (6, 137, 1);
INSERT INTO `like` VALUES (6, 93, 1);
INSERT INTO `like` VALUES (5, 63, 1);
INSERT INTO `like` VALUES (8, 77, 2);
INSERT INTO `like` VALUES (3, 60, 0);
INSERT INTO `like` VALUES (5, 48, 0);
INSERT INTO `like` VALUES (5, 38, 1);
INSERT INTO `like` VALUES (4, 52, 1);
INSERT INTO `like` VALUES (3, 20, 1);
INSERT INTO `like` VALUES (7, 49, 2);
INSERT INTO `like` VALUES (7, 125, 1);
INSERT INTO `like` VALUES (5, 93, 0);
INSERT INTO `like` VALUES (1, 3, 1);
INSERT INTO `like` VALUES (4, 133, 0);
INSERT INTO `like` VALUES (8, 105, 0);
INSERT INTO `like` VALUES (1, 52, 2);
INSERT INTO `like` VALUES (7, 38, 0);
INSERT INTO `like` VALUES (6, 151, 1);
INSERT INTO `like` VALUES (7, 114, 2);
INSERT INTO `like` VALUES (3, 12, 1);
INSERT INTO `like` VALUES (1, 123, 2);
INSERT INTO `like` VALUES (2, 4, 1);
INSERT INTO `like` VALUES (5, 90, 1);
INSERT INTO `like` VALUES (7, 83, 0);
INSERT INTO `like` VALUES (2, 107, 0);
INSERT INTO `like` VALUES (1, 65, 1);
INSERT INTO `like` VALUES (4, 119, 0);
INSERT INTO `like` VALUES (7, 28, 1);
INSERT INTO `like` VALUES (1, 101, 2);
INSERT INTO `like` VALUES (2, 126, 2);
INSERT INTO `like` VALUES (1, 144, 2);
INSERT INTO `like` VALUES (4, 66, 0);
INSERT INTO `like` VALUES (6, 110, 2);
INSERT INTO `like` VALUES (4, 83, 1);
INSERT INTO `like` VALUES (4, 45, 0);
INSERT INTO `like` VALUES (6, 1, 1);
INSERT INTO `like` VALUES (5, 89, 0);
INSERT INTO `like` VALUES (3, 68, 1);
INSERT INTO `like` VALUES (1, 44, 0);
INSERT INTO `like` VALUES (2, 147, 1);
INSERT INTO `like` VALUES (3, 38, 2);
INSERT INTO `like` VALUES (6, 57, 1);
INSERT INTO `like` VALUES (8, 11, 1);
INSERT INTO `like` VALUES (8, 59, 1);
INSERT INTO `like` VALUES (3, 119, 0);
INSERT INTO `like` VALUES (8, 46, 0);
INSERT INTO `like` VALUES (8, 28, 2);
INSERT INTO `like` VALUES (5, 119, 0);
INSERT INTO `like` VALUES (7, 53, 0);
INSERT INTO `like` VALUES (3, 118, 2);
INSERT INTO `like` VALUES (4, 53, 0);
INSERT INTO `like` VALUES (8, 43, 1);
INSERT INTO `like` VALUES (7, 135, 2);
INSERT INTO `like` VALUES (3, 84, 1);
INSERT INTO `like` VALUES (4, 6, 0);
INSERT INTO `like` VALUES (1, 115, 0);
INSERT INTO `like` VALUES (7, 30, 1);
INSERT INTO `like` VALUES (6, 127, 0);
INSERT INTO `like` VALUES (2, 53, 1);
INSERT INTO `like` VALUES (5, 138, 1);
INSERT INTO `like` VALUES (6, 2, 2);
INSERT INTO `like` VALUES (4, 141, 2);
INSERT INTO `like` VALUES (7, 115, 2);
INSERT INTO `like` VALUES (4, 79, 1);
INSERT INTO `like` VALUES (4, 30, 2);
INSERT INTO `like` VALUES (5, 79, 1);
INSERT INTO `like` VALUES (1, 25, 0);
INSERT INTO `like` VALUES (8, 26, 1);
INSERT INTO `like` VALUES (2, 79, 0);
INSERT INTO `like` VALUES (7, 31, 0);
INSERT INTO `like` VALUES (6, 53, 1);
INSERT INTO `like` VALUES (6, 146, 1);
INSERT INTO `like` VALUES (1, 77, 2);
INSERT INTO `like` VALUES (2, 109, 1);
INSERT INTO `like` VALUES (2, 57, 0);
INSERT INTO `like` VALUES (3, 73, 1);
INSERT INTO `like` VALUES (3, 31, 0);
INSERT INTO `like` VALUES (1, 5, 1);
INSERT INTO `like` VALUES (3, 79, 1);
INSERT INTO `like` VALUES (8, 109, 2);
INSERT INTO `like` VALUES (6, 49, 1);
INSERT INTO `like` VALUES (7, 140, 0);
INSERT INTO `like` VALUES (2, 11, 1);
INSERT INTO `like` VALUES (7, 20, 0);
INSERT INTO `like` VALUES (4, 66, 1);
INSERT INTO `like` VALUES (5, 44, 1);
INSERT INTO `like` VALUES (6, 32, 1);
INSERT INTO `like` VALUES (7, 104, 1);
INSERT INTO `like` VALUES (8, 44, 0);
INSERT INTO `like` VALUES (3, 148, 1);
INSERT INTO `like` VALUES (5, 117, 2);
INSERT INTO `like` VALUES (8, 79, 1);
INSERT INTO `like` VALUES (5, 96, 1);
INSERT INTO `like` VALUES (2, 140, 1);
INSERT INTO `like` VALUES (8, 105, 0);
INSERT INTO `like` VALUES (6, 62, 1);
INSERT INTO `like` VALUES (6, 146, 0);
INSERT INTO `like` VALUES (3, 8, 1);
INSERT INTO `like` VALUES (5, 85, 1);
INSERT INTO `like` VALUES (2, 22, 1);
INSERT INTO `like` VALUES (5, 134, 0);
INSERT INTO `like` VALUES (5, 84, 1);
INSERT INTO `like` VALUES (8, 142, 2);
INSERT INTO `like` VALUES (2, 108, 1);
INSERT INTO `like` VALUES (4, 30, 1);
INSERT INTO `like` VALUES (4, 81, 1);
INSERT INTO `like` VALUES (4, 91, 1);
INSERT INTO `like` VALUES (8, 142, 1);
INSERT INTO `like` VALUES (3, 80, 2);
INSERT INTO `like` VALUES (2, 11, 2);
INSERT INTO `like` VALUES (5, 92, 2);
INSERT INTO `like` VALUES (1, 136, 1);
INSERT INTO `like` VALUES (1, 14, 1);
INSERT INTO `like` VALUES (2, 10, 0);
INSERT INTO `like` VALUES (3, 43, 1);
INSERT INTO `like` VALUES (4, 95, 2);
INSERT INTO `like` VALUES (7, 141, 0);
INSERT INTO `like` VALUES (1, 120, 1);
INSERT INTO `like` VALUES (2, 47, 0);
INSERT INTO `like` VALUES (6, 57, 1);
INSERT INTO `like` VALUES (6, 61, 2);
INSERT INTO `like` VALUES (3, 77, 2);
INSERT INTO `like` VALUES (3, 122, 1);
INSERT INTO `like` VALUES (5, 118, 1);
INSERT INTO `like` VALUES (7, 67, 2);
INSERT INTO `like` VALUES (4, 70, 1);
INSERT INTO `like` VALUES (3, 75, 1);
INSERT INTO `like` VALUES (7, 85, 1);
INSERT INTO `like` VALUES (5, 73, 0);
INSERT INTO `like` VALUES (7, 129, 1);
INSERT INTO `like` VALUES (6, 53, 1);
INSERT INTO `like` VALUES (2, 48, 1);
INSERT INTO `like` VALUES (4, 7, 1);
INSERT INTO `like` VALUES (6, 103, 2);
INSERT INTO `like` VALUES (5, 37, 0);
INSERT INTO `like` VALUES (7, 83, 1);
INSERT INTO `like` VALUES (6, 12, 1);
INSERT INTO `like` VALUES (7, 12, 1);
INSERT INTO `like` VALUES (3, 50, 1);
INSERT INTO `like` VALUES (2, 18, 1);
INSERT INTO `like` VALUES (1, 44, 1);
INSERT INTO `like` VALUES (3, 59, 1);
INSERT INTO `like` VALUES (4, 115, 1);
INSERT INTO `like` VALUES (8, 104, 1);
INSERT INTO `like` VALUES (3, 95, 1);
INSERT INTO `like` VALUES (3, 122, 2);
INSERT INTO `like` VALUES (3, 8, 1);
INSERT INTO `like` VALUES (6, 146, 1);
INSERT INTO `like` VALUES (6, 120, 2);
INSERT INTO `like` VALUES (6, 0, 1);
INSERT INTO `like` VALUES (2, 72, 1);
INSERT INTO `like` VALUES (5, 150, 1);
INSERT INTO `like` VALUES (7, 50, 0);
INSERT INTO `like` VALUES (2, 112, 0);
INSERT INTO `like` VALUES (3, 57, 2);
INSERT INTO `like` VALUES (8, 38, 2);
INSERT INTO `like` VALUES (5, 65, 1);
INSERT INTO `like` VALUES (5, 93, 1);
INSERT INTO `like` VALUES (5, 17, 1);
INSERT INTO `like` VALUES (2, 143, 1);
INSERT INTO `like` VALUES (2, 146, 2);
INSERT INTO `like` VALUES (4, 55, 1);
INSERT INTO `like` VALUES (3, 67, 1);
INSERT INTO `like` VALUES (5, 23, 0);
INSERT INTO `like` VALUES (3, 35, 1);
INSERT INTO `like` VALUES (7, 77, 1);
INSERT INTO `like` VALUES (5, 24, 1);
INSERT INTO `like` VALUES (4, 128, 0);
INSERT INTO `like` VALUES (1, 128, 2);
INSERT INTO `like` VALUES (4, 106, 2);
INSERT INTO `like` VALUES (6, 121, 0);
INSERT INTO `like` VALUES (2, 84, 1);
INSERT INTO `like` VALUES (5, 76, 2);
INSERT INTO `like` VALUES (8, 109, 1);
INSERT INTO `like` VALUES (3, 24, 0);
INSERT INTO `like` VALUES (1, 26, 1);
INSERT INTO `like` VALUES (1, 69, 0);
INSERT INTO `like` VALUES (7, 115, 1);
INSERT INTO `like` VALUES (5, 141, 2);
INSERT INTO `like` VALUES (5, 140, 0);
INSERT INTO `like` VALUES (2, 80, 2);
INSERT INTO `like` VALUES (8, 64, 1);
INSERT INTO `like` VALUES (7, 65, 2);
INSERT INTO `like` VALUES (5, 33, 0);
INSERT INTO `like` VALUES (3, 104, 2);
INSERT INTO `like` VALUES (4, 11, 2);
INSERT INTO `like` VALUES (8, 140, 2);
INSERT INTO `like` VALUES (1, 57, 1);
INSERT INTO `like` VALUES (8, 123, 1);
INSERT INTO `like` VALUES (8, 23, 1);
INSERT INTO `like` VALUES (6, 150, 2);
INSERT INTO `like` VALUES (6, 47, 1);
INSERT INTO `like` VALUES (5, 51, 2);
INSERT INTO `like` VALUES (4, 112, 1);
INSERT INTO `like` VALUES (8, 48, 1);
INSERT INTO `like` VALUES (5, 44, 1);
INSERT INTO `like` VALUES (3, 41, 1);
INSERT INTO `like` VALUES (5, 110, 1);
INSERT INTO `like` VALUES (2, 31, 2);
INSERT INTO `like` VALUES (1, 25, 2);
INSERT INTO `like` VALUES (6, 36, 2);
INSERT INTO `like` VALUES (3, 72, 0);
INSERT INTO `like` VALUES (1, 102, 1);
INSERT INTO `like` VALUES (1, 19, 2);
INSERT INTO `like` VALUES (1, 109, 1);
INSERT INTO `like` VALUES (2, 96, 1);
INSERT INTO `like` VALUES (7, 139, 0);
INSERT INTO `like` VALUES (3, 3, 1);
INSERT INTO `like` VALUES (1, 25, 1);
INSERT INTO `like` VALUES (4, 49, 1);
INSERT INTO `like` VALUES (8, 116, 0);
INSERT INTO `like` VALUES (3, 93, 1);
INSERT INTO `like` VALUES (8, 114, 1);
INSERT INTO `like` VALUES (5, 101, 1);
INSERT INTO `like` VALUES (8, 87, 1);
INSERT INTO `like` VALUES (7, 123, 0);
INSERT INTO `like` VALUES (4, 104, 1);
INSERT INTO `like` VALUES (1, 90, 1);
INSERT INTO `like` VALUES (6, 5, 1);
INSERT INTO `like` VALUES (2, 143, 1);
INSERT INTO `like` VALUES (2, 79, 2);
INSERT INTO `like` VALUES (7, 36, 1);
INSERT INTO `like` VALUES (6, 36, 1);
INSERT INTO `like` VALUES (1, 58, 1);
INSERT INTO `like` VALUES (7, 90, 1);
INSERT INTO `like` VALUES (7, 149, 2);
INSERT INTO `like` VALUES (8, 10, 2);
INSERT INTO `like` VALUES (1, 117, 0);
INSERT INTO `like` VALUES (4, 23, 1);
INSERT INTO `like` VALUES (8, 109, 1);
INSERT INTO `like` VALUES (6, 95, 1);
INSERT INTO `like` VALUES (3, 120, 0);
INSERT INTO `like` VALUES (7, 14, 0);
INSERT INTO `like` VALUES (2, 118, 1);
INSERT INTO `like` VALUES (2, 91, 0);
INSERT INTO `like` VALUES (4, 22, 1);
INSERT INTO `like` VALUES (6, 89, 2);
INSERT INTO `like` VALUES (2, 77, 2);
INSERT INTO `like` VALUES (3, 19, 1);
INSERT INTO `like` VALUES (7, 64, 0);
INSERT INTO `like` VALUES (2, 67, 1);
INSERT INTO `like` VALUES (5, 56, 1);
INSERT INTO `like` VALUES (7, 47, 2);
INSERT INTO `like` VALUES (4, 16, 0);
INSERT INTO `like` VALUES (5, 111, 2);
INSERT INTO `like` VALUES (5, 95, 2);
INSERT INTO `like` VALUES (1, 123, 1);
INSERT INTO `like` VALUES (8, 48, 1);
INSERT INTO `like` VALUES (8, 122, 1);
INSERT INTO `like` VALUES (2, 91, 2);
INSERT INTO `like` VALUES (6, 39, 2);
INSERT INTO `like` VALUES (2, 52, 2);
INSERT INTO `like` VALUES (3, 8, 1);
INSERT INTO `like` VALUES (3, 85, 1);
INSERT INTO `like` VALUES (3, 99, 2);
INSERT INTO `like` VALUES (3, 96, 1);
INSERT INTO `like` VALUES (1, 64, 2);
INSERT INTO `like` VALUES (3, 80, 1);
INSERT INTO `like` VALUES (3, 100, 1);
INSERT INTO `like` VALUES (7, 77, 0);
INSERT INTO `like` VALUES (3, 120, 2);
INSERT INTO `like` VALUES (2, 140, 2);
INSERT INTO `like` VALUES (4, 142, 1);
INSERT INTO `like` VALUES (7, 31, 0);
INSERT INTO `like` VALUES (7, 62, 2);
INSERT INTO `like` VALUES (7, 59, 1);
INSERT INTO `like` VALUES (6, 41, 1);
INSERT INTO `like` VALUES (2, 92, 2);
INSERT INTO `like` VALUES (6, 142, 2);
INSERT INTO `like` VALUES (5, 6, 0);
INSERT INTO `like` VALUES (2, 27, 1);
INSERT INTO `like` VALUES (2, 87, 2);
INSERT INTO `like` VALUES (6, 10, 0);
INSERT INTO `like` VALUES (4, 117, 2);
INSERT INTO `like` VALUES (3, 35, 1);
INSERT INTO `like` VALUES (1, 116, 1);
INSERT INTO `like` VALUES (3, 25, 2);
INSERT INTO `like` VALUES (3, 13, 1);
INSERT INTO `like` VALUES (8, 90, 1);
INSERT INTO `like` VALUES (4, 33, 0);
INSERT INTO `like` VALUES (6, 119, 1);
INSERT INTO `like` VALUES (2, 55, 0);
INSERT INTO `like` VALUES (4, 54, 1);
INSERT INTO `like` VALUES (2, 91, 1);
INSERT INTO `like` VALUES (6, 25, 1);
INSERT INTO `like` VALUES (6, 88, 1);
INSERT INTO `like` VALUES (4, 30, 0);
INSERT INTO `like` VALUES (3, 30, 2);
INSERT INTO `like` VALUES (7, 27, 1);
INSERT INTO `like` VALUES (7, 48, 1);
INSERT INTO `like` VALUES (4, 29, 1);
INSERT INTO `like` VALUES (8, 14, 2);
INSERT INTO `like` VALUES (4, 23, 1);
INSERT INTO `like` VALUES (1, 106, 0);
INSERT INTO `like` VALUES (1, 81, 0);
INSERT INTO `like` VALUES (5, 28, 1);
INSERT INTO `like` VALUES (2, 82, 2);
INSERT INTO `like` VALUES (3, 38, 1);
INSERT INTO `like` VALUES (6, 132, 1);
INSERT INTO `like` VALUES (7, 2, 1);
INSERT INTO `like` VALUES (4, 7, 1);
INSERT INTO `like` VALUES (4, 131, 1);
INSERT INTO `like` VALUES (4, 125, 1);
INSERT INTO `like` VALUES (8, 85, 1);
INSERT INTO `like` VALUES (7, 19, 0);
INSERT INTO `like` VALUES (5, 1, 1);
INSERT INTO `like` VALUES (5, 80, 1);
INSERT INTO `like` VALUES (5, 151, 2);
INSERT INTO `like` VALUES (5, 88, 2);
INSERT INTO `like` VALUES (5, 88, 1);
INSERT INTO `like` VALUES (1, 77, 2);
INSERT INTO `like` VALUES (3, 2, 1);
INSERT INTO `like` VALUES (8, 147, 1);
INSERT INTO `like` VALUES (6, 20, 0);
INSERT INTO `like` VALUES (2, 37, 1);
INSERT INTO `like` VALUES (6, 96, 1);
INSERT INTO `like` VALUES (8, 9, 1);
INSERT INTO `like` VALUES (7, 121, 1);
INSERT INTO `like` VALUES (6, 49, 0);
INSERT INTO `like` VALUES (3, 149, 1);
INSERT INTO `like` VALUES (4, 150, 1);
INSERT INTO `like` VALUES (8, 144, 0);
INSERT INTO `like` VALUES (3, 103, 1);
INSERT INTO `like` VALUES (2, 96, 2);
INSERT INTO `like` VALUES (6, 8, 2);
INSERT INTO `like` VALUES (4, 84, 1);
INSERT INTO `like` VALUES (2, 148, 1);
INSERT INTO `like` VALUES (3, 41, 2);
INSERT INTO `like` VALUES (1, 29, 2);
INSERT INTO `like` VALUES (4, 103, 1);
INSERT INTO `like` VALUES (8, 82, 2);
INSERT INTO `like` VALUES (4, 20, 1);
INSERT INTO `like` VALUES (4, 109, 0);
INSERT INTO `like` VALUES (2, 147, 0);
INSERT INTO `like` VALUES (3, 138, 1);
INSERT INTO `like` VALUES (8, 89, 1);
INSERT INTO `like` VALUES (2, 135, 2);
INSERT INTO `like` VALUES (7, 117, 1);
INSERT INTO `like` VALUES (4, 21, 2);
INSERT INTO `like` VALUES (5, 69, 2);
INSERT INTO `like` VALUES (8, 145, 1);
INSERT INTO `like` VALUES (7, 2, 0);
INSERT INTO `like` VALUES (3, 77, 1);
INSERT INTO `like` VALUES (6, 97, 0);
INSERT INTO `like` VALUES (8, 49, 2);
INSERT INTO `like` VALUES (5, 114, 1);
INSERT INTO `like` VALUES (4, 59, 1);
INSERT INTO `like` VALUES (8, 148, 1);
INSERT INTO `like` VALUES (1, 43, 1);
INSERT INTO `like` VALUES (2, 68, 1);
INSERT INTO `like` VALUES (6, 80, 1);
INSERT INTO `like` VALUES (1, 5, 0);
INSERT INTO `like` VALUES (3, 24, 2);
INSERT INTO `like` VALUES (1, 49, 1);
INSERT INTO `like` VALUES (6, 32, 1);
INSERT INTO `like` VALUES (2, 38, 0);
INSERT INTO `like` VALUES (4, 82, 1);
INSERT INTO `like` VALUES (5, 49, 1);
INSERT INTO `like` VALUES (5, 33, 1);
INSERT INTO `like` VALUES (1, 72, 1);
INSERT INTO `like` VALUES (5, 84, 1);
INSERT INTO `like` VALUES (5, 3, 2);
INSERT INTO `like` VALUES (1, 101, 0);
INSERT INTO `like` VALUES (4, 97, 2);
INSERT INTO `like` VALUES (4, 9, 1);
INSERT INTO `like` VALUES (6, 90, 2);
INSERT INTO `like` VALUES (7, 122, 1);
INSERT INTO `like` VALUES (7, 140, 0);
INSERT INTO `like` VALUES (1, 107, 1);
INSERT INTO `like` VALUES (7, 22, 1);
INSERT INTO `like` VALUES (4, 1, 2);
INSERT INTO `like` VALUES (4, 1, 0);
INSERT INTO `like` VALUES (3, 115, 1);
INSERT INTO `like` VALUES (2, 119, 1);
INSERT INTO `like` VALUES (2, 26, 1);
INSERT INTO `like` VALUES (8, 135, 1);
INSERT INTO `like` VALUES (5, 14, 1);
INSERT INTO `like` VALUES (4, 113, 1);
INSERT INTO `like` VALUES (2, 68, 2);
INSERT INTO `like` VALUES (8, 102, 2);
INSERT INTO `like` VALUES (5, 32, 1);
INSERT INTO `like` VALUES (5, 18, 0);
INSERT INTO `like` VALUES (7, 55, 2);
INSERT INTO `like` VALUES (3, 110, 2);
INSERT INTO `like` VALUES (1, 84, 0);
INSERT INTO `like` VALUES (6, 84, 1);
INSERT INTO `like` VALUES (1, 18, 2);
INSERT INTO `like` VALUES (1, 120, 1);
INSERT INTO `like` VALUES (7, 94, 1);
INSERT INTO `like` VALUES (3, 9, 1);
INSERT INTO `like` VALUES (2, 19, 1);
INSERT INTO `like` VALUES (7, 75, 0);
INSERT INTO `like` VALUES (7, 19, 2);
INSERT INTO `like` VALUES (3, 117, 1);
INSERT INTO `like` VALUES (5, 77, 0);
INSERT INTO `like` VALUES (6, 138, 1);
INSERT INTO `like` VALUES (6, 60, 1);
INSERT INTO `like` VALUES (7, 84, 2);
INSERT INTO `like` VALUES (4, 25, 1);
INSERT INTO `like` VALUES (3, 136, 2);
INSERT INTO `like` VALUES (3, 109, 2);
INSERT INTO `like` VALUES (3, 69, 1);
INSERT INTO `like` VALUES (8, 13, 1);
INSERT INTO `like` VALUES (8, 6, 2);
INSERT INTO `like` VALUES (5, 136, 2);
INSERT INTO `like` VALUES (8, 96, 1);
INSERT INTO `like` VALUES (2, 49, 1);
INSERT INTO `like` VALUES (8, 82, 1);
INSERT INTO `like` VALUES (7, 15, 1);
INSERT INTO `like` VALUES (8, 33, 0);
INSERT INTO `like` VALUES (3, 35, 0);
INSERT INTO `like` VALUES (7, 133, 2);
INSERT INTO `like` VALUES (3, 103, 1);
INSERT INTO `like` VALUES (5, 31, 2);
INSERT INTO `like` VALUES (1, 74, 0);
INSERT INTO `like` VALUES (5, 112, 2);
INSERT INTO `like` VALUES (4, 109, 1);
INSERT INTO `like` VALUES (4, 52, 0);
INSERT INTO `like` VALUES (3, 128, 0);
INSERT INTO `like` VALUES (8, 70, 0);
INSERT INTO `like` VALUES (2, 79, 2);
INSERT INTO `like` VALUES (8, 62, 1);
INSERT INTO `like` VALUES (8, 111, 0);
INSERT INTO `like` VALUES (4, 117, 1);
INSERT INTO `like` VALUES (3, 132, 1);
INSERT INTO `like` VALUES (3, 123, 2);
INSERT INTO `like` VALUES (4, 22, 0);
INSERT INTO `like` VALUES (7, 45, 2);
INSERT INTO `like` VALUES (5, 150, 2);
INSERT INTO `like` VALUES (5, 86, 1);
INSERT INTO `like` VALUES (1, 51, 0);
INSERT INTO `like` VALUES (3, 62, 1);
INSERT INTO `like` VALUES (1, 62, 1);
INSERT INTO `like` VALUES (4, 64, 1);
INSERT INTO `like` VALUES (1, 43, 1);
INSERT INTO `like` VALUES (1, 23, 0);
INSERT INTO `like` VALUES (7, 138, 1);
INSERT INTO `like` VALUES (4, 112, 1);
INSERT INTO `like` VALUES (6, 62, 2);
INSERT INTO `like` VALUES (4, 41, 1);
INSERT INTO `like` VALUES (7, 104, 0);
INSERT INTO `like` VALUES (4, 19, 1);
INSERT INTO `like` VALUES (6, 139, 1);
INSERT INTO `like` VALUES (8, 21, 0);
INSERT INTO `like` VALUES (8, 26, 2);
INSERT INTO `like` VALUES (1, 122, 0);
INSERT INTO `like` VALUES (7, 114, 1);
INSERT INTO `like` VALUES (2, 11, 0);
INSERT INTO `like` VALUES (1, 111, 0);
INSERT INTO `like` VALUES (1, 51, 1);
INSERT INTO `like` VALUES (5, 19, 0);
INSERT INTO `like` VALUES (1, 6, 1);
INSERT INTO `like` VALUES (1, 32, 2);
INSERT INTO `like` VALUES (5, 49, 1);
INSERT INTO `like` VALUES (4, 84, 2);
INSERT INTO `like` VALUES (1, 60, 1);
INSERT INTO `like` VALUES (8, 148, 1);
INSERT INTO `like` VALUES (6, 124, 1);
INSERT INTO `like` VALUES (6, 99, 2);
INSERT INTO `like` VALUES (6, 38, 1);
INSERT INTO `like` VALUES (6, 111, 1);
INSERT INTO `like` VALUES (6, 137, 1);
INSERT INTO `like` VALUES (2, 131, 2);
INSERT INTO `like` VALUES (2, 1, 1);
INSERT INTO `like` VALUES (2, 51, 1);
INSERT INTO `like` VALUES (2, 50, 1);
INSERT INTO `like` VALUES (2, 33, 1);
INSERT INTO `like` VALUES (2, 21, 1);
INSERT INTO `like` VALUES (6, 20, 1);
INSERT INTO `like` VALUES (1, 82, 1);
INSERT INTO `like` VALUES (2, 61, 1);
INSERT INTO `like` VALUES (58962735, 71, 1);
INSERT INTO `like` VALUES (58962735, 40, 1);
INSERT INTO `like` VALUES (2, 93, 1);
INSERT INTO `like` VALUES (2, 46, 1);
INSERT INTO `like` VALUES (2, 83, 1);
INSERT INTO `like` VALUES (2, 98, 1);
INSERT INTO `like` VALUES (2, 40, 0);
INSERT INTO `like` VALUES (2, 80, 0);
INSERT INTO `like` VALUES (2, 61, 0);
INSERT INTO `like` VALUES (2, 33, 0);
INSERT INTO `like` VALUES (2, 78, 0);

-- ----------------------------
-- Table structure for star
-- ----------------------------
DROP TABLE IF EXISTS `star`;
CREATE TABLE `star`  (
  `user_id` int(11) NOT NULL,
  `article_id` int(11) NOT NULL,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  CONSTRAINT `star_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `star_ibfk_2` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of star
-- ----------------------------
INSERT INTO `star` VALUES (6, 161);
INSERT INTO `star` VALUES (5, 95);
INSERT INTO `star` VALUES (8, 131);
INSERT INTO `star` VALUES (3, 139);
INSERT INTO `star` VALUES (3, 150);
INSERT INTO `star` VALUES (5, 158);
INSERT INTO `star` VALUES (2, 94);
INSERT INTO `star` VALUES (6, 52);
INSERT INTO `star` VALUES (4, 46);
INSERT INTO `star` VALUES (1, 3);
INSERT INTO `star` VALUES (2, 2);
INSERT INTO `star` VALUES (4, 70);
INSERT INTO `star` VALUES (5, 79);
INSERT INTO `star` VALUES (5, 3);
INSERT INTO `star` VALUES (3, 116);
INSERT INTO `star` VALUES (6, 138);
INSERT INTO `star` VALUES (3, 85);
INSERT INTO `star` VALUES (8, 25);
INSERT INTO `star` VALUES (2, 138);
INSERT INTO `star` VALUES (6, 9);
INSERT INTO `star` VALUES (2, 140);
INSERT INTO `star` VALUES (8, 53);
INSERT INTO `star` VALUES (2, 3);
INSERT INTO `star` VALUES (1, 2);
INSERT INTO `star` VALUES (6, 9);
INSERT INTO `star` VALUES (6, 71);
INSERT INTO `star` VALUES (7, 19);
INSERT INTO `star` VALUES (5, 21);
INSERT INTO `star` VALUES (3, 47);
INSERT INTO `star` VALUES (7, 103);
INSERT INTO `star` VALUES (5, 85);
INSERT INTO `star` VALUES (8, 50);
INSERT INTO `star` VALUES (6, 133);
INSERT INTO `star` VALUES (4, 147);
INSERT INTO `star` VALUES (1, 122);
INSERT INTO `star` VALUES (8, 111);
INSERT INTO `star` VALUES (2, 44);
INSERT INTO `star` VALUES (3, 39);
INSERT INTO `star` VALUES (7, 114);
INSERT INTO `star` VALUES (2, 72);
INSERT INTO `star` VALUES (6, 67);
INSERT INTO `star` VALUES (7, 152);
INSERT INTO `star` VALUES (3, 47);
INSERT INTO `star` VALUES (3, 108);
INSERT INTO `star` VALUES (2, 111);
INSERT INTO `star` VALUES (1, 15);
INSERT INTO `star` VALUES (4, 117);
INSERT INTO `star` VALUES (2, 78);
INSERT INTO `star` VALUES (3, 45);
INSERT INTO `star` VALUES (6, 90);
INSERT INTO `star` VALUES (7, 109);
INSERT INTO `star` VALUES (1, 117);
INSERT INTO `star` VALUES (5, 1);
INSERT INTO `star` VALUES (4, 99);
INSERT INTO `star` VALUES (2, 108);
INSERT INTO `star` VALUES (8, 133);
INSERT INTO `star` VALUES (2, 91);
INSERT INTO `star` VALUES (8, 131);
INSERT INTO `star` VALUES (6, 29);
INSERT INTO `star` VALUES (6, 9);
INSERT INTO `star` VALUES (3, 15);
INSERT INTO `star` VALUES (1, 13);
INSERT INTO `star` VALUES (1, 60);
INSERT INTO `star` VALUES (2, 116);
INSERT INTO `star` VALUES (3, 97);
INSERT INTO `star` VALUES (5, 99);
INSERT INTO `star` VALUES (6, 148);
INSERT INTO `star` VALUES (3, 23);
INSERT INTO `star` VALUES (1, 46);
INSERT INTO `star` VALUES (3, 154);
INSERT INTO `star` VALUES (2, 161);
INSERT INTO `star` VALUES (8, 39);
INSERT INTO `star` VALUES (8, 116);
INSERT INTO `star` VALUES (8, 53);
INSERT INTO `star` VALUES (2, 145);
INSERT INTO `star` VALUES (5, 104);
INSERT INTO `star` VALUES (6, 66);
INSERT INTO `star` VALUES (4, 108);
INSERT INTO `star` VALUES (8, 137);
INSERT INTO `star` VALUES (8, 31);
INSERT INTO `star` VALUES (7, 50);
INSERT INTO `star` VALUES (8, 35);
INSERT INTO `star` VALUES (1, 2);
INSERT INTO `star` VALUES (3, 64);
INSERT INTO `star` VALUES (7, 28);
INSERT INTO `star` VALUES (5, 158);
INSERT INTO `star` VALUES (3, 109);
INSERT INTO `star` VALUES (2, 32);
INSERT INTO `star` VALUES (7, 25);
INSERT INTO `star` VALUES (8, 75);
INSERT INTO `star` VALUES (8, 23);
INSERT INTO `star` VALUES (4, 100);
INSERT INTO `star` VALUES (4, 76);
INSERT INTO `star` VALUES (3, 77);
INSERT INTO `star` VALUES (8, 16);
INSERT INTO `star` VALUES (2, 40);
INSERT INTO `star` VALUES (6, 101);
INSERT INTO `star` VALUES (4, 77);
INSERT INTO `star` VALUES (1, 18);
INSERT INTO `star` VALUES (5, 71);
INSERT INTO `star` VALUES (2, 71);
INSERT INTO `star` VALUES (2, 93);
INSERT INTO `star` VALUES (1, 82);
INSERT INTO `star` VALUES (2, 61);
INSERT INTO `star` VALUES (8, 11);
INSERT INTO `star` VALUES (2, 46);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, '前端');
INSERT INTO `tag` VALUES (2, '后端');
INSERT INTO `tag` VALUES (3, '面试');
INSERT INTO `tag` VALUES (5, '性能优化');
INSERT INTO `tag` VALUES (6, '低代码');
INSERT INTO `tag` VALUES (7, '架构');
INSERT INTO `tag` VALUES (8, 'CSS');
INSERT INTO `tag` VALUES (9, 'JavaScript');
INSERT INTO `tag` VALUES (10, 'TypeScript');
INSERT INTO `tag` VALUES (11, 'Vue.js');
INSERT INTO `tag` VALUES (12, 'React.js');
INSERT INTO `tag` VALUES (13, 'GitHub');
INSERT INTO `tag` VALUES (14, 'Java');
INSERT INTO `tag` VALUES (15, 'uni-app');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 58962736 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '123', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', NULL, NULL, NULL, '2021-07-01 14:53:08');
INSERT INTO `user` VALUES (2, '1234', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', NULL, 'public/uploads/1694312828595.png', NULL, '2023-09-10 14:54:01');
INSERT INTO `user` VALUES (3, 'anjiu', '$2a$10$L.sx/kCBWYacryO1CutjSuzU/LLjRhkLho9REzO79KD5Hts/v3YTy', '安玖', 'public/uploads/1694312828588.png', '', '2022-01-27 10:27:33');
INSERT INTO `user` VALUES (4, 'BoredWait', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', NULL, 'public/uploads/1694312828610.png', NULL, '2023-09-05 14:54:09');
INSERT INTO `user` VALUES (5, '街角小林', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', NULL, 'public/uploads/1694312828593.png', NULL, '2020-06-11 10:27:52');
INSERT INTO `user` VALUES (6, '1', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', '溪饱鱼', 'public/uploads/1694312828596.png', NULL, '2013-07-25 14:54:12');
INSERT INTO `user` VALUES (7, '2', '$2a$10$Dcg1d/D7NU7t16r1C86Xg.IsCHGIC0mL4lHfaFAnuViXHjWcAZW/m', '街头炒米粉', 'public/uploads/1694354410757.webp', NULL, '2023-09-10 22:00:42');
INSERT INTO `user` VALUES (8, 'root', '$2a$10$nyz5qcrkrbpFsSG3sqr4au/GOcBOjsDKXO4rH/p/tF.OkOYcIgdRa', NULL, 'public/uploads/1694312828597.png', NULL, '2023-08-23 10:28:10');
INSERT INTO `user` VALUES (58962735, NULL, NULL, 'Anjiu1', 'https://avatars.githubusercontent.com/u/58962735?v=4', NULL, '2023-09-20 19:45:59');

-- ----------------------------
-- Procedure structure for example_loop
-- ----------------------------
DROP PROCEDURE IF EXISTS `example_loop`;
delimiter ;;
CREATE PROCEDURE `example_loop`()
BEGIN
  DECLARE counter INT DEFAULT 4;
  DECLARE max_count INT DEFAULT 157;
	DECLARE cc INT DEFAULT 0;

  WHILE counter <= max_count DO
    -- 在这里执行循环中的操作
    -- 可以在这里使用 counter 变量来执行操作
    -- 例如，执行一些插入、更新或选择操作
    -- 请根据您的需求来编写相应的SQL语句
		 SELECT COUNT(*) INTO cc FROM `like` WHERE type_id = 1 AND content_id = counter;
		UPDATE article set like_num=cc WHERE id =counter;
	
    SET counter = counter + 1;
  END WHILE;
END
;;
delimiter ;

SET FOREIGN_KEY_CHECKS = 1;
